<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_debug.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_debug.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sdb/sdb.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TN_KEY_LEN</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TN_KEY_FMT</name></cpp:macro> <cpp:value>"%"PFMT64u</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGKILL</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__linux__</name> <operator>&amp;&amp;</operator> <name>__GNU_LIBRARY__</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_heap_glibc.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_JEMALLOC</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_heap_jemalloc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"linux_heap_jemalloc.c"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_d</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"d"</literal></expr>, <expr><literal type="string">" #Debug commands"</literal></expr>,

<expr><literal type="string">"db"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Breakpoints commands"</literal></expr>,

<expr><literal type="string">"dbt"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Display backtrace based on dbg.btdepth and dbg.btalgo"</literal></expr>,

<expr><literal type="string">"dc"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Continue execution"</literal></expr>,

<expr><literal type="string">"dd"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"File descriptors (!fd in r1)"</literal></expr>,

<expr><literal type="string">"de"</literal></expr>, <expr><literal type="string">"[-sc] [perm] [rm] [e]"</literal></expr>, <expr><literal type="string">"Debug with ESIL (see de?)"</literal></expr>,

<expr><literal type="string">"dg"</literal></expr>, <expr><literal type="string">" &lt;file&gt;"</literal></expr>, <expr><literal type="string">"Generate a core-file (WIP)"</literal></expr>,

<expr><literal type="string">"dH"</literal></expr>, <expr><literal type="string">" [handler]"</literal></expr>, <expr><literal type="string">"Transplant process to a new handler"</literal></expr>,

<expr><literal type="string">"di"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show debugger backend information (See dh)"</literal></expr>,

<expr><literal type="string">"dk"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"List, send, get, set, signal handlers of child"</literal></expr>,

<expr><literal type="string">"dL"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"List or set debugger handler"</literal></expr>,

<expr><literal type="string">"dm"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show memory maps"</literal></expr>,

<expr><literal type="string">"do"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Open process (reload, alias for 'oo')"</literal></expr>,

<expr><literal type="string">"doo"</literal></expr>, <expr><literal type="string">"[args]"</literal></expr>, <expr><literal type="string">"Reopen in debug mode with args (alias for 'ood')"</literal></expr>,

<expr><literal type="string">"doof"</literal></expr>, <expr><literal type="string">"[file]"</literal></expr>, <expr><literal type="string">"Reopen in debug mode from file (alias for 'oodf')"</literal></expr>,

<expr><literal type="string">"doc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Close debug session"</literal></expr>,

<expr><literal type="string">"dp"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"List, attach to process or thread id"</literal></expr>,

<expr><literal type="string">"dr"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Cpu registers"</literal></expr>,

<expr><literal type="string">"ds"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Step, over, source line"</literal></expr>,

<expr><literal type="string">"dt"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Display instruction traces"</literal></expr>,

<expr><literal type="string">"dw"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Block prompt until pid dies"</literal></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<expr><literal type="string">"dW"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List process windows"</literal></expr>,

<expr><literal type="string">"dWi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Identify window under cursor"</literal></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="string">"dx"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Inject and run code on target process (See gs)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_db</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: db"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" #Breakpoints commands"</literal></expr>,

<expr><literal type="string">"db"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List breakpoints"</literal></expr>,

<expr><literal type="string">"db*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List breakpoints in r commands"</literal></expr>,

<expr><literal type="string">"db"</literal></expr>, <expr><literal type="string">" sym.main"</literal></expr>, <expr><literal type="string">"Add breakpoint into sym.main"</literal></expr>,

<expr><literal type="string">"db"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Add breakpoint"</literal></expr>,

<expr><literal type="string">"dbH"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Add hardware breakpoint"</literal></expr>,

<expr><literal type="string">"db-"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Remove breakpoint"</literal></expr>,

<expr><literal type="string">"db-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Remove all the breakpoints"</literal></expr>,

<expr><literal type="string">"db."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show breakpoint info in current offset"</literal></expr>,

<expr><literal type="string">"dbj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List breakpoints in JSON format"</literal></expr>,

<expr><literal type="string">"dbc"</literal></expr>, <expr><literal type="string">" &lt;addr&gt; &lt;cmd&gt;"</literal></expr>, <expr><literal type="string">"Run command when breakpoint is hit"</literal></expr>,

<expr><literal type="string">"dbC"</literal></expr>, <expr><literal type="string">" &lt;addr&gt; &lt;cmd&gt;"</literal></expr>, <expr><literal type="string">"Run command but continue until &lt;cmd&gt; returns zero"</literal></expr>,

<expr><literal type="string">"dbd"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Disable breakpoint"</literal></expr>,

<expr><literal type="string">"dbe"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Enable breakpoint"</literal></expr>,

<expr><literal type="string">"dbs"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Toggle breakpoint"</literal></expr>,

<expr><literal type="string">"dbf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Put a breakpoint into every no-return function"</literal></expr>,

<expr><literal type="string">"dbm"</literal></expr>, <expr><literal type="string">" &lt;module&gt; &lt;offset&gt;"</literal></expr>, <expr><literal type="string">"Add a breakpoint at an offset from a module's base"</literal></expr>,

<expr><literal type="string">"dbn"</literal></expr>, <expr><literal type="string">" [&lt;name&gt;]"</literal></expr>, <expr><literal type="string">"Show or set name for current breakpoint"</literal></expr>,

<expr><literal type="string">"dbi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List breakpoint indexes"</literal></expr>,

<expr><literal type="string">"dbi"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Show breakpoint index in givengiven offset"</literal></expr>,

<expr><literal type="string">"dbi."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show breakpoint index in current offset"</literal></expr>,

<expr><literal type="string">"dbi-"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Remove breakpoint by index"</literal></expr>,

<expr><literal type="string">"dbix"</literal></expr>, <expr><literal type="string">" &lt;idx&gt; [expr]"</literal></expr>, <expr><literal type="string">"Set expression for bp at given index"</literal></expr>,

<expr><literal type="string">"dbic"</literal></expr>, <expr><literal type="string">" &lt;idx&gt; &lt;cmd&gt;"</literal></expr>, <expr><literal type="string">"Run command at breakpoint index"</literal></expr>,

<expr><literal type="string">"dbie"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Enable breakpoint by index"</literal></expr>,

<expr><literal type="string">"dbid"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Disable breakpoint by index"</literal></expr>,

<expr><literal type="string">"dbis"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Swap Nth breakpoint"</literal></expr>,

<expr><literal type="string">"dbite"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Enable breakpoint Trace by index"</literal></expr>,

<expr><literal type="string">"dbitd"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Disable breakpoint Trace by index"</literal></expr>,

<expr><literal type="string">"dbits"</literal></expr>, <expr><literal type="string">" &lt;idx&gt;"</literal></expr>, <expr><literal type="string">"Swap Nth breakpoint trace"</literal></expr>,

<expr><literal type="string">"dbh"</literal></expr>, <expr><literal type="string">" x86"</literal></expr>, <expr><literal type="string">"Set/list breakpoint plugin handlers"</literal></expr>,

<expr><literal type="string">"dbh-"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Remove breakpoint plugin handler"</literal></expr>,

<expr><literal type="string">"dbt"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show backtrace. See dbt? for more details"</literal></expr>,

<expr><literal type="string">"dbx"</literal></expr>, <expr><literal type="string">" [expr]"</literal></expr>, <expr><literal type="string">"Set expression for bp in current offset"</literal></expr>,

<expr><literal type="string">"dbw"</literal></expr>, <expr><literal type="string">" &lt;addr&gt; &lt;r/w/rw&gt;"</literal></expr>, <expr><literal type="string">"Add watchpoint"</literal></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<expr><literal type="string">"dbW"</literal></expr>, <expr><literal type="string">" &lt;WM_DEFINE&gt; [?|handle|name]"</literal></expr>, <expr><literal type="string">"Set cond. breakpoint on a window message handler"</literal></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="string">"drx"</literal></expr>, <expr><literal type="string">" number addr len perm"</literal></expr>, <expr><literal type="string">"Modify hardware breakpoint"</literal></expr>,

<expr><literal type="string">"drx-"</literal></expr>, <expr><literal type="string">"number"</literal></expr>, <expr><literal type="string">"Clear hardware breakpoint"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dbt</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dbt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" #Backtrace commands"</literal></expr>,

<expr><literal type="string">"dbt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display backtrace based on dbg.btdepth and dbg.btalgo"</literal></expr>,

<expr><literal type="string">"dbt*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display backtrace in flags"</literal></expr>,

<expr><literal type="string">"dbt="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display backtrace in one line (see dbt=s and dbt=b for sp or bp)"</literal></expr>,

<expr><literal type="string">"dbtv"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display backtrace with local vars if any"</literal></expr>,

<expr><literal type="string">"dbtj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display backtrace in JSON"</literal></expr>,

<expr><literal type="string">"dbta"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display ascii-art representation of the stack backtrace"</literal></expr>,

<expr><literal type="string">"dbte"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Enable Breakpoint Trace"</literal></expr>,

<expr><literal type="string">"dbtd"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Disable Breakpoint Trace"</literal></expr>,

<expr><literal type="string">"dbts"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>, <expr><literal type="string">"Swap Breakpoint Trace"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dbw</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dbw"</literal></expr>, <expr><literal type="string">"&lt;addr&gt; &lt;r/w/rw&gt;"</literal></expr>,<expr><literal type="string">" #Add watchpoint"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Execution continuation commands"</literal></expr>,

<expr><literal type="string">"dc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue execution of all children"</literal></expr>,

<expr><literal type="string">"dc"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Continue execution of pid"</literal></expr>,

<expr><literal type="string">"dc"</literal></expr>, <expr><literal type="string">"[-pid]"</literal></expr>, <expr><literal type="string">"Stop execution of pid"</literal></expr>,

<expr><literal type="string">"dca"</literal></expr>, <expr><literal type="string">" [sym] [sym]."</literal></expr>, <expr><literal type="string">"Continue at every hit on any given symbol"</literal></expr>,

<expr><literal type="string">"dcb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue back until breakpoint"</literal></expr>,

<expr><literal type="string">"dcc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until call (use step into)"</literal></expr>,

<expr><literal type="string">"dccu"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until unknown call (call reg)"</literal></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<expr><literal type="string">"dce"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue execution (pass exception to program)"</literal></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="string">"dcf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until fork (TODO)"</literal></expr>,

<expr><literal type="string">"dck"</literal></expr>, <expr><literal type="string">" &lt;signal&gt; &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Continue sending signal to process"</literal></expr>,

<expr><literal type="string">"dcp"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until program code (mapped io section)"</literal></expr>,

<expr><literal type="string">"dcr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until ret (uses step over)"</literal></expr>,

<expr><literal type="string">"dcs"</literal></expr>, <expr><literal type="string">"[?] &lt;num&gt;"</literal></expr>, <expr><literal type="string">"Continue until syscall"</literal></expr>,

<expr><literal type="string">"dct"</literal></expr>, <expr><literal type="string">" &lt;len&gt;"</literal></expr>, <expr><literal type="string">"Traptrace from curseek to len, no argument to list"</literal></expr>,

<expr><literal type="string">"dcu"</literal></expr>, <expr><literal type="string">"[?] [..end|addr] ([end])"</literal></expr>, <expr><literal type="string">"Continue until address (or range)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dcs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dcs"</literal></expr>, <expr><literal type="string">" Continue until syscall"</literal></expr>,

<expr><literal type="string">"dcs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until next syscall"</literal></expr>,

<expr><literal type="string">"dcs [str]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until next call to the 'str' syscall"</literal></expr>,

<expr><literal type="string">"dcs"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"Trace all syscalls, a la strace"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dcu</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dcu"</literal></expr>, <expr><literal type="string">" Continue until address"</literal></expr>,

<expr><literal type="string">"dcu."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Alias for dcu $$ (continue until current address"</literal></expr>,

<expr><literal type="string">"dcu"</literal></expr>, <expr><literal type="string">" address"</literal></expr>, <expr><literal type="string">"Continue until address"</literal></expr>,

<expr><literal type="string">"dcu"</literal></expr>, <expr><literal type="string">" [..tail]"</literal></expr>, <expr><literal type="string">"Continue until the range"</literal></expr>,

<expr><literal type="string">"dcu"</literal></expr>, <expr><literal type="string">" [from] [to]"</literal></expr>, <expr><literal type="string">"Continue until the range"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dd</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Descriptors commands"</literal></expr>,

<expr><literal type="string">"dd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List file descriptors"</literal></expr>,

<expr><literal type="string">"dd"</literal></expr>, <expr><literal type="string">" &lt;file&gt;"</literal></expr>, <expr><literal type="string">"Open and map that file into the UI"</literal></expr>,

<expr><literal type="string">"dd-"</literal></expr>, <expr><literal type="string">"&lt;fd&gt;"</literal></expr>, <expr><literal type="string">"Close stdout fd"</literal></expr>,

<expr><literal type="string">"dd*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List file descriptors (in radare commands)"</literal></expr>,

<expr><literal type="string">"dds"</literal></expr>, <expr><literal type="string">" &lt;fd&gt; &lt;off&gt;"</literal></expr>, <expr><literal type="string">"Seek given fd)"</literal></expr>,

<expr><literal type="string">"ddd"</literal></expr>, <expr><literal type="string">" &lt;fd1&gt; &lt;fd2&gt;"</literal></expr>, <expr><literal type="string">"Dup2 from fd1 to fd2"</literal></expr>,

<expr><literal type="string">"ddr"</literal></expr>, <expr><literal type="string">" &lt;fd&gt; &lt;size&gt;"</literal></expr>, <expr><literal type="string">"Read N bytes from fd"</literal></expr>,

<expr><literal type="string">"ddw"</literal></expr>, <expr><literal type="string">" &lt;fd&gt; &lt;hexpairs&gt;"</literal></expr>, <expr><literal type="string">"Write N bytes to fd"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_de</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"de"</literal></expr>, <expr><literal type="string">"[-sc] [perm] [rm] [expr]"</literal></expr>,

<expr><literal type="string">"de"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List esil watchpoints"</literal></expr>,

<expr><literal type="string">"de-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Delete all esil watchpoints"</literal></expr>,

<expr><literal type="string">"de"</literal></expr>, <expr><literal type="string">" [perm] [rm] [addr|reg|from..to]"</literal></expr>, <expr><literal type="string">"Stop on condition"</literal></expr>,

<expr><literal type="string">"dec"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue execution until matching expression"</literal></expr>,

<expr><literal type="string">"des"</literal></expr>, <expr><literal type="string">"[?] [N]"</literal></expr>, <expr><literal type="string">"Step-in N instructions with esildebug"</literal></expr>,

<expr><literal type="string">"desu"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"Esildebug until specific address"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_des</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"des"</literal></expr>, <expr><literal type="string">"[u] [arg]"</literal></expr>,

<expr><literal type="string">"des"</literal></expr>, <expr><literal type="string">" [N]"</literal></expr>, <expr><literal type="string">"step-in N instructions with esildebug"</literal></expr>,

<expr><literal type="string">"desu"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"esildebug until specific address"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_di</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: di"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Debugger target information"</literal></expr>,

<expr><literal type="string">"di"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show debugger target information"</literal></expr>,

<expr><literal type="string">"di*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Same as above, but in r2 commands"</literal></expr>,

<expr><literal type="string">"diq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Same as above, but in one line"</literal></expr>,

<expr><literal type="string">"dij"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Same as above, but in JSON format"</literal></expr>,

<expr><literal type="string">"dif"</literal></expr>, <expr><literal type="string">" [$a] [$b]"</literal></expr>, <expr><literal type="string">"Compare two files (or $alias files)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dk</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dk"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Signal commands"</literal></expr>,

<expr><literal type="string">"dk"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all signal handlers of child process"</literal></expr>,

<expr><literal type="string">"dk"</literal></expr>, <expr><literal type="string">" &lt;signal&gt;"</literal></expr>, <expr><literal type="string">"Send KILL signal to child"</literal></expr>,

<expr><literal type="string">"dk"</literal></expr>, <expr><literal type="string">" &lt;signal&gt;=1"</literal></expr>, <expr><literal type="string">"Set signal handler for &lt;signal&gt; in child"</literal></expr>,

<expr><literal type="string">"dk?"</literal></expr>, <expr><literal type="string">"&lt;signal&gt;"</literal></expr>, <expr><literal type="string">"Name/signum resolver"</literal></expr>,

<expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">"[?] &lt;signal&gt;"</literal></expr>, <expr><literal type="string">"Reset skip or cont options for given signal"</literal></expr>,

<expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">" &lt;signal&gt; [|skip|cont]"</literal></expr>, <expr><literal type="string">"On signal SKIP handler or CONT into"</literal></expr>,

<expr><literal type="string">"dkj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all signal handlers in JSON"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dko</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">" #Signal handling commands"</literal></expr>,

<expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List existing signal handling"</literal></expr>,

<expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">" [signal]"</literal></expr>, <expr><literal type="string">"Clear handling for a signal"</literal></expr>,

<expr><literal type="string">"dko"</literal></expr>, <expr><literal type="string">" [signal] [skip|cont]"</literal></expr>, <expr><literal type="string">"Set handling for a signal"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dm</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dm"</literal></expr>, <expr><literal type="string">" #Memory maps commands"</literal></expr>,

<expr><literal type="string">"dm"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memory maps of target process"</literal></expr>,

<expr><literal type="string">"dm"</literal></expr>, <expr><literal type="string">" address size"</literal></expr>, <expr><literal type="string">"Allocate &lt;size&gt; bytes at &lt;address&gt; (anywhere if address is -1) in child process"</literal></expr>,

<expr><literal type="string">"dm="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memory maps of target process (ascii-art bars)"</literal></expr>,

<expr><literal type="string">"dm."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show map name of current address"</literal></expr>,

<expr><literal type="string">"dm*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memmaps in radare commands"</literal></expr>,

<expr><literal type="string">"dm-"</literal></expr>, <expr><literal type="string">" address"</literal></expr>, <expr><literal type="string">"Deallocate memory map of &lt;address&gt;"</literal></expr>,

<expr><literal type="string">"dmd"</literal></expr>, <expr><literal type="string">"[a] [file]"</literal></expr>, <expr><literal type="string">"Dump current (all) debug map region to a file (from-to.dmp) (see Sd)"</literal></expr>,

<expr><literal type="string">"dmh"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show map of heap"</literal></expr>,

<expr><literal type="string">"dmi"</literal></expr>, <expr><literal type="string">" [addr|libname] [symname]"</literal></expr>, <expr><literal type="string">"List symbols of target lib"</literal></expr>,

<expr><literal type="string">"dmi*"</literal></expr>, <expr><literal type="string">" [addr|libname] [symname]"</literal></expr>, <expr><literal type="string">"List symbols of target lib in radare commands"</literal></expr>,

<expr><literal type="string">"dmi."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List closest symbol to the current address"</literal></expr>,

<expr><literal type="string">"dmiv"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show address of given symbol for given lib"</literal></expr>,

<expr><literal type="string">"dmj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memmaps in JSON format"</literal></expr>,

<expr><literal type="string">"dml"</literal></expr>, <expr><literal type="string">" &lt;file&gt;"</literal></expr>, <expr><literal type="string">"Load contents of file into the current map region"</literal></expr>,

<expr><literal type="string">"dmm"</literal></expr>, <expr><literal type="string">"[?][j*]"</literal></expr>, <expr><literal type="string">"List modules (libraries, binaries loaded in memory)"</literal></expr>,

<expr><literal type="string">"dmp"</literal></expr>, <expr><literal type="string">"[?] &lt;address&gt; &lt;size&gt; &lt;perms&gt;"</literal></expr>, <expr><literal type="string">"Change page at &lt;address&gt; with &lt;size&gt;, protection &lt;perms&gt; (perm)"</literal></expr>,

<expr><literal type="string">"dms"</literal></expr>, <expr><literal type="string">"[?] &lt;id&gt; &lt;mapaddr&gt;"</literal></expr>, <expr><literal type="string">"Take memory snapshot"</literal></expr>,

<expr><literal type="string">"dms-"</literal></expr>, <expr><literal type="string">" &lt;id&gt; &lt;mapaddr&gt;"</literal></expr>, <expr><literal type="string">"Restore memory snapshot"</literal></expr>,

<expr><literal type="string">"dmS"</literal></expr>, <expr><literal type="string">" [addr|libname] [sectname]"</literal></expr>, <expr><literal type="string">"List sections of target lib"</literal></expr>,

<expr><literal type="string">"dmS*"</literal></expr>, <expr><literal type="string">" [addr|libname] [sectname]"</literal></expr>, <expr><literal type="string">"List sections of target lib in radare commands"</literal></expr>,

<expr><literal type="string">"dmL"</literal></expr>, <expr><literal type="string">" address size"</literal></expr>, <expr><literal type="string">"Allocate &lt;size&gt; bytes at &lt;address&gt; and promote to huge page"</literal></expr>,

<expr><literal type="string">"TODO:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"map files in process memory. (dmf file @ [addr])"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dmi</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dmi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" #List/Load Symbols"</literal></expr>,

<expr><literal type="string">"dmi"</literal></expr>, <expr><literal type="string">"[libname] [symname]"</literal></expr>, <expr><literal type="string">"List symbols of target lib"</literal></expr>,

<expr><literal type="string">"dmi*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List symbols of target lib in radare commands"</literal></expr>,

<expr><literal type="string">"dmi."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List closest symbol to the current address"</literal></expr>,

<expr><literal type="string">"dmiv"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show address of given symbol for given lib"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dmm</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dmm"</literal></expr>, <expr><literal type="string">" #Module memory maps commands"</literal></expr>,

<expr><literal type="string">"dmm"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List modules of target process"</literal></expr>,

<expr><literal type="string">"dmm*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List modules of target process (r2 commands)"</literal></expr>,

<expr><literal type="string">"dmm."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memory map of current module"</literal></expr>,

<expr><literal type="string">"dmmj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List modules of target process (JSON)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dmp</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dmp"</literal></expr>, <expr><literal type="string">" Change page permissions"</literal></expr>,

<expr><literal type="string">"dmp"</literal></expr>, <expr><literal type="string">" [addr] [size] [perms]"</literal></expr>, <expr><literal type="string">"Change permissions"</literal></expr>,

<expr><literal type="string">"dmp"</literal></expr>, <expr><literal type="string">" [perms]"</literal></expr>, <expr><literal type="string">"Change dbg.map permissions"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dms</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dms"</literal></expr>, <expr><literal type="string">" #Memory map snapshots"</literal></expr>,

<expr><literal type="string">"dms"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List memory snapshots"</literal></expr>,

<expr><literal type="string">"dmsj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List snapshots in JSON"</literal></expr>,

<expr><literal type="string">"dms*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List snapshots in r2 commands"</literal></expr>,

<expr><literal type="string">"dms"</literal></expr>, <expr><literal type="string">" addr"</literal></expr>, <expr><literal type="string">"Take snapshot with given id of map at address"</literal></expr>,

<expr><literal type="string">"dms"</literal></expr>, <expr><literal type="string">"-id"</literal></expr>, <expr><literal type="string">"Delete memory snapshot"</literal></expr>,

<expr><literal type="string">"dmsA"</literal></expr>, <expr><literal type="string">" id"</literal></expr>, <expr><literal type="string">"Apply memory snapshot"</literal></expr>,

<expr><literal type="string">"dmsC"</literal></expr>, <expr><literal type="string">" id comment"</literal></expr>, <expr><literal type="string">"Add comment for given snapshot"</literal></expr>,

<expr><literal type="string">"dmsd"</literal></expr>, <expr><literal type="string">" id"</literal></expr>, <expr><literal type="string">"Hexdiff given snapshot. See `ccc`."</literal></expr>,

<expr><literal type="string">"dmsw"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Snapshot of the writable maps"</literal></expr>,

<expr><literal type="string">"dmsa"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Full snapshot of all `dm` maps"</literal></expr>,

<expr><literal type="string">"dmsf"</literal></expr>, <expr><literal type="string">" [file] @ addr"</literal></expr>, <expr><literal type="string">"Read snapshot from disk"</literal></expr>,

<expr><literal type="string">"dmst"</literal></expr>, <expr><literal type="string">" [file] @ addr"</literal></expr>, <expr><literal type="string">"Dump snapshot to disk"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_do</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"do"</literal></expr>, <expr><literal type="string">" #Debug (re)open commands"</literal></expr>,

<expr><literal type="string">"do"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Open process (reload, alias for 'oo')"</literal></expr>,

<expr><literal type="string">"dor"</literal></expr>, <expr><literal type="string">" [rarun2]"</literal></expr>, <expr><literal type="string">"Comma separated list of k=v rarun2 profile options (e dbg.profile)"</literal></expr>,

<expr><literal type="string">"doo"</literal></expr>, <expr><literal type="string">" [args]"</literal></expr>, <expr><literal type="string">"Reopen in debug mode with args (alias for 'ood')"</literal></expr>,

<expr><literal type="string">"doof"</literal></expr>, <expr><literal type="string">" [args]"</literal></expr>, <expr><literal type="string">"Reopen in debug mode from file (alias for 'oodf')"</literal></expr>,

<expr><literal type="string">"doc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Close debug session"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dp</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dp"</literal></expr>, <expr><literal type="string">" #Process commands"</literal></expr>,

<expr><literal type="string">"dp"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List current pid and children"</literal></expr>,

<expr><literal type="string">"dp"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"List children of pid"</literal></expr>,

<expr><literal type="string">"dpj"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"List children of pid in JSON format"</literal></expr>,

<expr><literal type="string">"dpl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all attachable pids"</literal></expr>,

<expr><literal type="string">"dplj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all attachable pids in JSON format"</literal></expr>,

<expr><literal type="string">"dp-"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Detach select pid"</literal></expr>,

<expr><literal type="string">"dp="</literal></expr>, <expr><literal type="string">"&lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Select pid"</literal></expr>,

<expr><literal type="string">"dpa"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"Attach and select pid"</literal></expr>,

<expr><literal type="string">"dpc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Select forked pid (see dbg.forks)"</literal></expr>,

<expr><literal type="string">"dpc*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display forked pid (see dbg.forks)"</literal></expr>,

<expr><literal type="string">"dpe"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show path to executable"</literal></expr>,

<expr><literal type="string">"dpf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Attach to pid like file fd // HACK"</literal></expr>,

<expr><literal type="string">"dpk"</literal></expr>, <expr><literal type="string">" &lt;pid&gt; [&lt;signal&gt;]"</literal></expr>, <expr><literal type="string">"Send signal to process (default 0)"</literal></expr>,

<expr><literal type="string">"dpn"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Create new process (fork)"</literal></expr>,

<expr><literal type="string">"dptn"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Create new thread (clone)"</literal></expr>,

<expr><literal type="string">"dpt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List threads of current pid"</literal></expr>,

<expr><literal type="string">"dptj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List threads of current pid in JSON format"</literal></expr>,

<expr><literal type="string">"dpt"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"List threads of process"</literal></expr>,

<expr><literal type="string">"dptj"</literal></expr>, <expr><literal type="string">" &lt;pid&gt;"</literal></expr>, <expr><literal type="string">"List threads of process in JSON format"</literal></expr>,

<expr><literal type="string">"dpt="</literal></expr>, <expr><literal type="string">"&lt;thread&gt;"</literal></expr>, <expr><literal type="string">"Attach to thread"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dr</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Registers commands"</literal></expr>,

<expr><literal type="string">"dr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show 'gpr' registers"</literal></expr>,

<expr><literal type="string">"dr"</literal></expr>, <expr><literal type="string">" &lt;register&gt;=&lt;val&gt;"</literal></expr>, <expr><literal type="string">"Set register value"</literal></expr>,

<expr><literal type="string">"dr."</literal></expr>, <expr><literal type="string">" &gt;$snapshot"</literal></expr>, <expr><literal type="string">"Capture current register values in r2 alias file"</literal></expr>,

<expr><literal type="string">"dr,"</literal></expr>, <expr><literal type="string">" [table-query]"</literal></expr>, <expr><literal type="string">"Enumerate registers in table format"</literal></expr>,

<expr><literal type="string">"dr8"</literal></expr>, <expr><literal type="string">"[1|2|4|8] [type]"</literal></expr>, <expr><literal type="string">"Display hexdump of gpr arena (WIP)"</literal></expr>,

<expr><literal type="string">"dr="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show registers in columns"</literal></expr>,

<expr><literal type="string">"dr?"</literal></expr>, <expr><literal type="string">"&lt;register&gt;"</literal></expr>, <expr><literal type="string">"Show value of given register"</literal></expr>,

<expr><literal type="string">"dr??"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Same as dr?`drp~=[0]+` #list all reg roles alias names and values"</literal></expr>,

<expr><literal type="string">"dra"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Manage register arenas. see ara?"</literal></expr>,

<expr><literal type="string">"drb"</literal></expr>, <expr><literal type="string">"[1|2|4|8] [type]"</literal></expr>, <expr><literal type="string">"Display hexdump of gpr arena (WIP)"</literal></expr>,

<expr><literal type="string">"drc"</literal></expr>, <expr><literal type="string">" [name]"</literal></expr>, <expr><literal type="string">"Related to conditional flag registers"</literal></expr>,

<expr><literal type="string">"drC"</literal></expr>, <expr><literal type="string">" [register]"</literal></expr>, <expr><literal type="string">"Show register comments"</literal></expr>,

<expr><literal type="string">"drd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show only different registers"</literal></expr>,

<expr><literal type="string">"drf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show fpu registers (80 bit long double)"</literal></expr>,

<expr><literal type="string">"dri"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show inverse registers dump (sorted by value)"</literal></expr>,

<expr><literal type="string">"drl"</literal></expr>, <expr><literal type="string">"[j]"</literal></expr>, <expr><literal type="string">"List all register names"</literal></expr>,

<expr><literal type="string">"drm"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show multimedia packed registers"</literal></expr>,

<expr><literal type="string">"dro"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show previous (old) values of registers"</literal></expr>,

<expr><literal type="string">"drp"</literal></expr>, <expr><literal type="string">"[?] "</literal></expr>, <expr><literal type="string">"Display current register profile"</literal></expr>,

<expr><literal type="string">"drr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show registers references (telescoping)"</literal></expr>,

<expr><literal type="string">"drrj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show registers references (telescoping) in JSON format"</literal></expr>,

<expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Stack register states"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show all register types"</literal></expr>,

<expr><literal type="string">"drw"</literal></expr>,<expr><literal type="string">" &lt;hexnum&gt;"</literal></expr>, <expr><literal type="string">"Set contents of the register arena"</literal></expr>,

<expr><literal type="string">"drx"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show debug registers"</literal></expr>,

<expr><literal type="string">".dr"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"Include common register values in flags"</literal></expr>,

<expr><literal type="string">".dr"</literal></expr>, <expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"Unflag all registers"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_drp</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"drp"</literal></expr>, <expr><literal type="string">" #Register profile commands"</literal></expr>,

<expr><literal type="string">"drp"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show the current register profile"</literal></expr>,

<expr><literal type="string">"drp"</literal></expr>, <expr><literal type="string">" [regprofile-file]"</literal></expr>, <expr><literal type="string">"Set the current register profile"</literal></expr>,

<expr><literal type="string">"drp"</literal></expr>, <expr><literal type="string">" [gdb] [regprofile-file]"</literal></expr>, <expr><literal type="string">"Parse gdb register profile and dump an r2 profile string"</literal></expr>,

<expr><literal type="string">"drpc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show register profile comments"</literal></expr>,

<expr><literal type="string">"drpi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show internal representation of the register profile"</literal></expr>,

<expr><literal type="string">"drp."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show the current fake size"</literal></expr>,

<expr><literal type="string">"drpj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show the current register profile (JSON)"</literal></expr>,

<expr><literal type="string">"drps"</literal></expr>, <expr><literal type="string">" [new fake size]"</literal></expr>, <expr><literal type="string">"Set the fake size"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_drs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">"register states commands"</literal></expr>,

<expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list register stack"</literal></expr>,

<expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"push register state"</literal></expr>,

<expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"pop register state"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_drt</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" [type] [size] #debug register types"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all available register types"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" [size]"</literal></expr>, <expr><literal type="string">"Show all regs in the profile of size"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" 16"</literal></expr>, <expr><literal type="string">"Show 16 bit registers"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show all regs in the profile of this type"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" all"</literal></expr>, <expr><literal type="string">"Show all registers"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" fpu"</literal></expr>, <expr><literal type="string">"Show fpu registers"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" [type] [size]"</literal></expr>, <expr><literal type="string">"Same as above for type and size"</literal></expr>,

<expr><literal type="string">"drt"</literal></expr>, <expr><literal type="string">" [type] [size]"</literal></expr>, <expr><literal type="string">"Same as above for type and size"</literal></expr>,

<expr><literal type="string">"drt*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List flags in r commands"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_drx</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: drx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Hardware breakpoints commands"</literal></expr>,

<expr><literal type="string">"drx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all (x86?) hardware breakpoints"</literal></expr>,

<expr><literal type="string">"drx"</literal></expr>, <expr><literal type="string">" &lt;number&gt; &lt;address&gt; &lt;length&gt; &lt;perms&gt;"</literal></expr>, <expr><literal type="string">"Modify hardware breakpoint"</literal></expr>,

<expr><literal type="string">"drx-"</literal></expr>, <expr><literal type="string">"&lt;number&gt;"</literal></expr>, <expr><literal type="string">"Clear hardware breakpoint"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_drm</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: drm"</literal></expr>, <expr><literal type="string">" [reg] [idx] [wordsize] [= value]"</literal></expr>, <expr><literal type="string">"Show multimedia packed registers"</literal></expr>,

<expr><literal type="string">"drm"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show XMM registers"</literal></expr>,

<expr><literal type="string">"drm"</literal></expr>, <expr><literal type="string">" xmm0"</literal></expr>, <expr><literal type="string">"Show all packings of xmm0"</literal></expr>,

<expr><literal type="string">"drm"</literal></expr>, <expr><literal type="string">" xmm0 0 32 = 12"</literal></expr>, <expr><literal type="string">"Set the first 32 bit word of the xmm0 reg to 12"</literal></expr>,

<expr><literal type="string">"drmb"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as bytes"</literal></expr>,

<expr><literal type="string">"drmw"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as words"</literal></expr>,

<expr><literal type="string">"drmd"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as doublewords"</literal></expr>,

<expr><literal type="string">"drmq"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as quadwords"</literal></expr>,

<expr><literal type="string">"drmq"</literal></expr>, <expr><literal type="string">" xmm0~[0]"</literal></expr>, <expr><literal type="string">"Show first quadword of xmm0"</literal></expr>,

<expr><literal type="string">"drmf"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as 32-bit floating point"</literal></expr>,

<expr><literal type="string">"drml"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show registers as 64-bit floating point"</literal></expr>,

<expr><literal type="string">"drmyb"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as bytes"</literal></expr>,

<expr><literal type="string">"drmyw"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as words"</literal></expr>,

<expr><literal type="string">"drmyd"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as doublewords"</literal></expr>,

<expr><literal type="string">"drmyq"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as quadwords"</literal></expr>,

<expr><literal type="string">"drmq"</literal></expr>, <expr><literal type="string">" ymm0~[3]"</literal></expr>, <expr><literal type="string">"Show fourth quadword of ymm0"</literal></expr>,

<expr><literal type="string">"drmyf"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as 32-bit floating point"</literal></expr>,

<expr><literal type="string">"drmyl"</literal></expr>, <expr><literal type="string">" [reg]"</literal></expr>, <expr><literal type="string">"Show YMM registers as 64-bit floating point"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ds</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: ds"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step commands"</literal></expr>,

<expr><literal type="string">"ds"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step one instruction"</literal></expr>,

<expr><literal type="string">"ds"</literal></expr>, <expr><literal type="string">" &lt;num&gt;"</literal></expr>, <expr><literal type="string">"Step &lt;num&gt; instructions"</literal></expr>,

<expr><literal type="string">"dsb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step back one instruction"</literal></expr>,

<expr><literal type="string">"dsf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step until end of frame"</literal></expr>,

<expr><literal type="string">"dsi"</literal></expr>, <expr><literal type="string">" &lt;cond&gt;"</literal></expr>, <expr><literal type="string">"Continue until condition matches"</literal></expr>,

<expr><literal type="string">"dsl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step one source line"</literal></expr>,

<expr><literal type="string">"dsl"</literal></expr>, <expr><literal type="string">" &lt;num&gt;"</literal></expr>, <expr><literal type="string">"Step &lt;num&gt; source lines"</literal></expr>,

<expr><literal type="string">"dso"</literal></expr>, <expr><literal type="string">" &lt;num&gt;"</literal></expr>, <expr><literal type="string">"Step over &lt;num&gt; instructions"</literal></expr>,

<expr><literal type="string">"dsp"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step into program (skip libs)"</literal></expr>,

<expr><literal type="string">"dss"</literal></expr>, <expr><literal type="string">" &lt;num&gt;"</literal></expr>, <expr><literal type="string">"Skip &lt;num&gt; step instructions"</literal></expr>,

<expr><literal type="string">"dsu"</literal></expr>, <expr><literal type="string">"[?] &lt;address&gt;"</literal></expr>, <expr><literal type="string">"Step until &lt;address&gt;. See 'dsu?' for other step until cmds."</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dsu</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dsu"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Step until commands"</literal></expr>,

<expr><literal type="string">"dsu"</literal></expr>, <expr><literal type="string">" &lt;address&gt;"</literal></expr>, <expr><literal type="string">"Step until &lt;address&gt;"</literal></expr>,

<expr><literal type="string">"dsui"</literal></expr>, <expr><literal type="string">"[r] &lt;instr&gt;"</literal></expr>, <expr><literal type="string">"Step until an instruction that matches &lt;instr&gt;, use dsuir for regex match"</literal></expr>,

<expr><literal type="string">"dsuo"</literal></expr>, <expr><literal type="string">" &lt;optype&gt; [&lt;optype&gt; ...]"</literal></expr>, <expr><literal type="string">"Step until an instr matches one of the &lt;optype&gt;s."</literal></expr>,

<expr><literal type="string">"dsue"</literal></expr>, <expr><literal type="string">" &lt;esil&gt;"</literal></expr>, <expr><literal type="string">"Step until &lt;esil&gt; expression matches"</literal></expr>,

<expr><literal type="string">"dsuf"</literal></expr>, <expr><literal type="string">" &lt;flag&gt;"</literal></expr>, <expr><literal type="string">"Step until pc == &lt;flag&gt; matching name"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dt</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Trace commands"</literal></expr>,

<expr><literal type="string">"dt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all traces "</literal></expr>,

<expr><literal type="string">"dt"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"Show trace info at address"</literal></expr>,

<expr><literal type="string">"dt%"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"TODO"</literal></expr>,

<expr><literal type="string">"dt*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all traced opcode offsets"</literal></expr>,

<expr><literal type="string">"dt+"</literal></expr>,<expr><literal type="string">" [addr] [times]"</literal></expr>, <expr><literal type="string">"Add trace for address N times"</literal></expr>,

<expr><literal type="string">"dt-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Reset traces (instruction/calls)"</literal></expr>,

<expr><literal type="string">"dt="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show ascii-art color bars with the debug trace ranges"</literal></expr>,

<expr><literal type="string">"dta"</literal></expr>, <expr><literal type="string">" 0x804020 ..."</literal></expr>, <expr><literal type="string">"Only trace given addresses"</literal></expr>,

<expr><literal type="string">"dtc[?][addr]|([from] [to] [addr])"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Trace call/ret"</literal></expr>,

<expr><literal type="string">"dtd"</literal></expr>, <expr><literal type="string">"[qi] [nth-start]"</literal></expr>, <expr><literal type="string">"List all traced disassembled (quiet, instructions)"</literal></expr>,

<expr><literal type="string">"dte"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show esil trace logs"</literal></expr>,

<expr><literal type="string">"dtg"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Graph call/ret trace"</literal></expr>,

<expr><literal type="string">"dtg*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Graph in agn/age commands. use .dtg*;aggi for visual"</literal></expr>,

<expr><literal type="string">"dtgi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Interactive debug trace"</literal></expr>,

<expr><literal type="string">"dts"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Trace sessions"</literal></expr>,

<expr><literal type="string">"dtt"</literal></expr>, <expr><literal type="string">" [tag]"</literal></expr>, <expr><literal type="string">"Select trace tag (no arg unsets)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dte</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dte"</literal></expr>, <expr><literal type="string">" Show esil trace logs"</literal></expr>,

<expr><literal type="string">"dte"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Esil trace log for a single instruction"</literal></expr>,

<expr><literal type="string">"dte"</literal></expr>, <expr><literal type="string">" [idx]"</literal></expr>, <expr><literal type="string">"Show commands for that index log"</literal></expr>,

<expr><literal type="string">"dte"</literal></expr>, <expr><literal type="string">"-*"</literal></expr>, <expr><literal type="string">"Delete all esil traces"</literal></expr>,

<expr><literal type="string">"dtei"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Esil trace log single instruction"</literal></expr>,

<expr><literal type="string">"dtek"</literal></expr>, <expr><literal type="string">" [sdb query]"</literal></expr>, <expr><literal type="string">"Esil trace log single instruction from sdb"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dts</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"dts[*]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"dts"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all trace sessions"</literal></expr>,

<expr><literal type="string">"dts+"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Add trace session"</literal></expr>,

<expr><literal type="string">"dts-"</literal></expr>, <expr><literal type="string">"id"</literal></expr>, <expr><literal type="string">"Delete trace session"</literal></expr>,

<expr><literal type="string">"dtsf"</literal></expr>, <expr><literal type="string">" [file] "</literal></expr>, <expr><literal type="string">"Read trace sessions from disk"</literal></expr>,

<expr><literal type="string">"dtst"</literal></expr>, <expr><literal type="string">" [file] "</literal></expr>, <expr><literal type="string">"Save trace sessions to disk"</literal></expr>,

<expr><literal type="string">"dtsC"</literal></expr>, <expr><literal type="string">" id comment"</literal></expr>, <expr><literal type="string">"Add comment for given trace session"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dx</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" #Code injection commands"</literal></expr>,

<expr><literal type="string">"dx"</literal></expr>, <expr><literal type="string">" &lt;opcode&gt;..."</literal></expr>, <expr><literal type="string">"Inject opcodes"</literal></expr>,

<expr><literal type="string">"dxa"</literal></expr>, <expr><literal type="string">" nop"</literal></expr>, <expr><literal type="string">"Assemble code and inject"</literal></expr>,

<expr><literal type="string">"dxe"</literal></expr>, <expr><literal type="string">" egg-expr"</literal></expr>, <expr><literal type="string">"Compile egg expression and inject it"</literal></expr>,

<expr><literal type="string">"dxr"</literal></expr>, <expr><literal type="string">" &lt;opcode&gt;..."</literal></expr>, <expr><literal type="string">"Inject opcodes and restore state"</literal></expr>,

<expr><literal type="string">"dxs"</literal></expr>, <expr><literal type="string">" write 1, 0x8048, 12"</literal></expr>, <expr><literal type="string">"Syscall injection (see gs)"</literal></expr>,

<expr><literal type="string">"\nExamples:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"dx"</literal></expr>, <expr><literal type="string">" 9090"</literal></expr>, <expr><literal type="string">"Inject two x86 nop"</literal></expr>,

<expr><literal type="string">"\"dxa mov eax,6;mov ebx,0;int 0x80\""</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Inject and restore state"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dL</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: dL"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" #List or set debugger handler"</literal></expr>,

<expr><literal type="string">"dL"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List debugger handlers"</literal></expr>,

<expr><literal type="string">"dLq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List debugger handlers in quiet mode"</literal></expr>,

<expr><literal type="string">"dLj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List debugger handlers in json mode"</literal></expr>,

<expr><literal type="string">"dL"</literal></expr>, <expr><literal type="string">" &lt;handler&gt;"</literal></expr>, <expr><literal type="string">"Set debugger handler"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>dot_trace_ght</name> <block>{

<decl_stmt><decl><type><name>RGraph</name> <modifier>*</modifier></type><name>graph</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>graphnodes</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>trace_node</name> <block>{

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>refs</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dbt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dcu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dko</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dmi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dmm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument>core</argument>, <argument>do</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>drp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>drs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>drt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>drx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setRarunProfileString</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>r_file_temp</name> <argument_list>(<argument><expr><literal type="string">"rarun2"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.profile"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_replace_char</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_file_dump</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_file_dump</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_cont_syscall</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>syscalls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>_str</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>_str</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>syscalls</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sysnumstr</name> <init>= <expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sig</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>sysnumstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>syscalls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>r_syscall_get_num</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>sysnumstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall number\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>syscalls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>syscalls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sig</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Running child until syscalls:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><name><name>syscalls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Running child until next syscall\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_continue_syscalls</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>syscalls</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>syscalls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>showreg</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rname</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>role</name> <init>= <expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>role</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rname</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>rname</name></expr></argument> , <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>utX</name></type> <name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_reg_get_value_big</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">80</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%04x%016"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v80</name><operator>.</operator><name>High</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v80</name><operator>.</operator><name>Low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">96</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08x%016"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v96</name><operator>.</operator><name>High</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v96</name><operator>.</operator><name>Low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">128</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">"%016"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v128</name><operator>.</operator><name>High</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v128</name><operator>.</operator><name>Low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">256</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">"%016"</literal><name>PFMT64x</name><literal type="string">"%016"</literal><name>PFMT64x</name><literal type="string">"%016"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>value</name><operator>.</operator><name>v256</name><operator>.</operator><name>High</name><operator>.</operator><name>High</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v256</name><operator>.</operator><name>High</name><operator>.</operator><name>Low</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v256</name><operator>.</operator><name>Low</name><operator>.</operator><name>High</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>v256</name><operator>.</operator><name>Low</name><operator>.</operator><name>Low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Error while retrieving reg '%s' of %i bits\n"</literal></expr></argument>, <argument><expr><name>str</name> <operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>get_graphtrace_node</name> <parameter_list>(<parameter><decl><type><name>RGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>tn_key</name><index>[<expr><name>TN_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>tn_key</name></expr></argument>, <argument><expr><name>TN_KEY_LEN</name></expr></argument>, <argument><expr><name>TN_KEY_FMT</name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gn</name> <operator>=</operator> <operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>tn_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>r_graph_add_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>tn_key</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>gn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>gn</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dot_trace_create_node</name> <parameter_list>(<parameter><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>RTreeVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dot_trace_ght</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>dot_trace_ght</name> <operator>*</operator><operator>)</operator><name><name>vis</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tn</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>get_graphtrace_node</name> <argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>graphnodes</name></name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dot_trace_discover_child</name> <parameter_list>(<parameter><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>RTreeVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dot_trace_ght</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>dot_trace_ght</name> <operator>*</operator><operator>)</operator><name><name>vis</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>graph</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>gnodes</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>graphnodes</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn_parent</name> <init>= <expr><name><name>parent</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tn</name> <operator>&amp;&amp;</operator> <name>tn_parent</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>get_graphtrace_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gnodes</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn_parent</name> <init>= <expr><call><name>get_graphtrace_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gnodes</name></expr></argument>, <argument><expr><name>tn_parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_graph_adjacent</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn_parent</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_graph_add_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn_parent</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dot_trace_traverse</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RTree</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gfont</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.font"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dot_trace_ght</name></name></type> <name>aux_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTreeVisitor</name></type> <name>vis</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-;.dtg*;aggi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>aux_data</name><operator>.</operator><name>graph</name></name> <operator>=</operator> <call><name>r_graph_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aux_data</name><operator>.</operator><name>graphnodes</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vis</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name>aux_data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vis</name><operator>.</operator><name>pre_visit</name></name> <operator>=</operator> <operator>(</operator><name>RTreeNodeVisitCb</name><operator>)</operator><name>dot_trace_create_node</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vis</name><operator>.</operator><name>discover_child</name></name> <operator>=</operator> <operator>(</operator><name>RTreeNodeVisitCb</name><operator>)</operator><name>dot_trace_discover_child</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_tree_bfs</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>aux_data</name><operator>.</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"digraph code {\n"</literal>

<literal type="string">"graph [bgcolor=white];\n"</literal>

<literal type="string">" node [color=lightgray, style=filled"</literal>

<literal type="string">" shape=box fontname=\"%s\" fontsize=\"8\"];\n"</literal></expr></argument>, <argument><expr><name>gfont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>nodes</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn</name> <init>= <expr><operator>(</operator>struct <name>trace_node</name> <operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neighbours</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>aux_data</name><operator>.</operator><name>graph</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it_n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name> <operator>&amp;&amp;</operator> <name>tn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" [URL=\"0x%08"</literal><name>PFMT64x</name>

<literal type="string">"\" color=\"lightgray\" label=\"0x%08"</literal><name>PFMT64x</name>

<literal type="string">" (%d)\"]\n"</literal></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>neighbours</argument>, <argument>it_n</argument>, <argument>w</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>(</operator>struct <name>trace_node</name> <operator>*</operator><operator>)</operator><name><name>w</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>&amp;&amp;</operator> <name>tn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name>

<literal type="string">"\" [color=\"red\"];\n"</literal></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tv</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_graph_free</name> <argument_list>(<argument><expr><name><name>aux_data</name><operator>.</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>aux_data</name><operator>.</operator><name>graphnodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>off</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot 'drn PC'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot continue until address 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>off</name> <operator>!=</operator> <name>addr</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until_esil</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name>esilstr</name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>anal</name></name> \

<operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Not initialized %p. Run 'aei' first.\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_condition</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ESIL BREAK!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_repeatable_inst</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_op_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>op</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>prefix</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_PREFIX_REP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>prefix</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_PREFIX_REPNE</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until_inst</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>regex</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_x86</name> <init>= <expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>instr</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name>instr</name><operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Wrong state\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_x86</name> <operator>&amp;&amp;</operator> <call><name>is_repeatable_inst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step_over</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %d %s\n"</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf_asm</name> <init>= <expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regex</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_regex_match</name> <argument_list>(<argument><expr><name>instr</name></expr></argument>, <argument><expr><literal type="string">"e"</literal></expr></argument>, <argument><expr><name>buf_asm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Stop.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>buf_asm</name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Stop.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until_optype</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_optypes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>optypes_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optype</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>optypes</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>_optypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Wrong state\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optypes</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>optypes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing optypes. Usage example: 'dsuo ucall ujmp'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>debugMode</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>optypes_list</name> <operator>=</operator> <call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>optypes</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>debugMode</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_PC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ERROR\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>cleanup_after_push</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ERROR\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>cleanup_after_push</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: r_anal_op failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>cleanup_after_push</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optype_str</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>optypes_list</argument>, <argument>iter</argument>, <argument>optype</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>optype_str</name></expr></argument>, <argument><expr><name>optype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>cleanup_after_push</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></for>

<label><name>cleanup_after_push</name>:</label>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>optypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>optypes_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until_flag</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>instr</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name>instr</name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Wrong state\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_flag_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instr</name><operator>||</operator> <operator>!</operator><operator>*</operator><name>instr</name> <operator>||</operator> <operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>realname</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[ 0x%08"</literal><name>PFMT64x</name><literal type="string">" ] %s\n"</literal></expr></argument>,

<argument><expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></for>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_until_eof</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>maxLoops</name> <init>= <expr><literal type="number">200000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>now</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step_over</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>maxLoops</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Step loop limit exceeded\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><name>off</name> <operator>&lt;=</operator> <name>now</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>step_line</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>times</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>file</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>file2</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>find_meta</name></decl>, <decl><type ref="prev"/><name>line</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>line2</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot 'drn PC'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>file2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_bin_addr2line</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><call><name>r_file_slurp_line</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s : %d\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; %s\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>find_meta</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; Stepping until dwarf line\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>find_meta</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_bin_addr2line</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>file2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>line2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>find_meta</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot retrieve dwarf info at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>line</name> <operator>==</operator> <name>line2</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s : %d\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><name>line2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_ptr</name> <operator>=</operator> <call><name>r_file_slurp_line</name> <argument_list>(<argument><expr><name>file2</name></expr></argument>, <argument><expr><name>line2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; %s\n"</literal></expr></argument>, <argument><expr><name>tmp_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_pid</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>sig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Selected: %d %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_detach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_detach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>forked_pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"dp %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>forked_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>forked_pid</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>main_pid</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>forked_pid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>n_threads</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>forked_pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No recently forked children\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sig</name> <operator>=</operator> <ternary><condition><expr><name>ptr</name></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Sending signal '%d' to pid '%d'\n"</literal></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cmd_debug_pid: Invalid arguments (%s)\n"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: debug_fork: %d\n"</literal></expr></argument>, <argument><expr><call><name>r_debug_child_fork</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_thread_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_thread_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_thread_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_thread_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: debug_clone: %d\n"</literal></expr></argument>, <argument><expr><call><name>r_debug_child_clone</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_attach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_num_math</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_attach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><call><name>r_io_fd_get_pid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.swstep"</literal></expr></argument>,

<argument><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>canstep</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"=!pid %d"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_io_fd_get_pid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_io_fd_get_tid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>main_pid</name></name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exe</name> <init>= <expr><call><name>r_sys_pid_to_path</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exe</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>exe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>exe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_pid_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_backtrace</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>analop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_traptrace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>oaddr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Trap tracing 0x%08"</literal><name>PFMT64x</name><literal type="string">"-0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>+</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bp_traptrace_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bp_traptrace_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>+</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bp_traptrace_enable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_continue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"pc=0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>oaddr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"pc=opc\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oaddr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><call><name>r_bp_traptrace_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>analop</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_bp_traptrace_enable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__r_debug_snap_diff</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>oflags</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>columns</name></name><operator>&gt;</operator><literal type="number">123</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugSnap</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>R_PRINT_FLAGS_DIFFOUT</name></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>dbg-&gt;snaps</argument>, <argument>iter</argument>, <argument>snap</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>idx</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate snapshot\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument> , <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_hexdiff</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>,

<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,

<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>,

<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>oflags</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_map_snapshot</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugSnap</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">".dump"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>r_debug_snap_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>snap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_snap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>r_debug_snap_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>snap</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>fsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fsz</name> <operator>&gt;=</operator> <name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This file is smaller than the snapshot size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot slurp '%s'\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unable to find a snapshot for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugSnap</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">".dump"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>r_debug_snap_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>snap</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_file_dump</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot slurp '%s'\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unable to find a snapshot for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_snap_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_snap_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap_set_idx</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap_comment</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>__r_debug_snap_diff</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_PERM_RW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_snap_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>grab_bits</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcbits2</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcbits2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"avr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pcbits</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcbits2</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pcname</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pcname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>!=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pcbits</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>pcbits</name></expr> ?</condition><then> <expr><name>pcbits</name></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MAP_SIZE</name></cpp:macro> <cpp:value>1024*1024*512</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dump_maps</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>do_dump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>do_dump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>perm</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>do_dump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>perm</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>do_dump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>perm</name> <operator>==</operator> <operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>perm</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>do_dump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_dump</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate 0x%08"</literal><name>PFMT64x</name><literal type="string">" bytes\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>MAX_MAP_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Do not dumping 0x%08"</literal><name>PFMT64x</name><literal type="string">" because it's too big\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><ternary><condition><expr><name>filename</name></expr>

?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"-0x%08"</literal><name>PFMT64x</name><literal type="string">"-%s.dmp"</literal></expr></argument>,

<argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>, <argument><expr><call><name>r_str_rwx_i</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_file_dump</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot write '%s'\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Dumped %d byte(s) into %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_modules</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<label><name>show_help</name>:</label>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dmm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_modules_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr_end"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">':'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>(</operator><name>mode</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> \

<name>addr</name><operator>&gt;=</operator><name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escaped_path</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filtered_name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_name_filter</name> <argument_list>(<argument><expr><name>filtered_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f mod.%s = 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>filtered_name</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"oba 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>escaped_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>escaped_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>filtered_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>show_help</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block>

<label><name>beach</name>:</label>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__linux__</name> <operator>&amp;&amp;</operator> <name>__GNU_LIBRARY__</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmd_dbg_map_heap_glibc_32</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmd_dbg_map_heap_glibc_64</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_map_heap_win</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>addroflib</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libname</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name>libname</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_debug_modules_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><call><name>r_file_basename</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><call><name>r_file_basename</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RDebugMap</name> <modifier>*</modifier></type><name>get_closest_map</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_debug_modules_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>map</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>map</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_debug_heap</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.malloc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><literal type="string">"glibc"</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__linux__</name> <operator>&amp;&amp;</operator> <name>__GNU_LIBRARY__</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dbg_map_heap_glibc_64</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dbg_map_heap_glibc_32</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"glibc not supported for this platform\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_JEMALLOC</name></expr></cpp:if>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>m</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><literal type="string">"jemalloc"</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dbg_map_jemalloc_64</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dbg_map_jemalloc_32</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if> <else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<expr_stmt><expr><call><name>cmd_debug_map_heap_win</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"MALLOC algorithm not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_map</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_debug_map_snapshot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_map_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_debug_modules</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>cmd_debug_modules</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>perms</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>addr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>perms</name> <operator>=</operator> <call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_map_protect</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>perms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See dmp?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>perms</name> <operator>=</operator> <call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>perms</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_map_protect</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>perms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See dmp?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See dmp?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><call><name>dump_maps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> <return>return <expr><call><name>dump_maps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_RW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <return>return <expr><call><name>dump_maps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><call><name>dump_maps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dmd[aw] - dump (all-or-writable) debug maps\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dml [file]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate 0x%08"</literal><name>PFMT64x</name><literal type="string">" byte(s)\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_write_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"File size differs from region size (%"</literal><name>PFMT64u</name><literal type="string">" vs %"</literal><name>PFMT64d</name><literal type="string">")\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Loaded %"</literal><name>PFMT64u</name><literal type="string">" byte(s) into the map region at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>sz</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No debug region found here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dmm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>symname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mode</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>baddr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"-r "</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dmm"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>symname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>a0</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>||</operator> <name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>libname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>libname</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>addroflib</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>libname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown library, or not found in dm\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>get_closest_map</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RCoreBinFilter</name></type> <name>filter</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>symname</name></expr>;</expr_stmt>

<expr_stmt><expr><name>baddr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>libname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><ternary><condition><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr>?</condition><then> <expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></then><else>: <expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_file_exists</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newfile</name> <operator>=</operator> <call><name>r_file_temp</name> <argument_list>(<argument><expr><literal type="string">"memlib"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newfile</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>file</name> <operator>=</operator> <name>newfile</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wtf %s 0x%"</literal><name>PFMT64x</name><literal type="string">" @ 0x%"</literal><name>PFMT64x</name><literal type="string">" 2&gt; %s"</literal></expr></argument>,

<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>, <argument><expr><name>R_SYS_DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>symname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"rabin2 %s-B 0x%08"</literal><name>PFMT64x</name><literal type="string">" -s %s | grep %s"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>symname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"rabin2 %s-B 0x%08"</literal><name>PFMT64x</name><literal type="string">" -s %s"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_sys_cmd_str</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newfile</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>newfile</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error when removing %s\n"</literal></expr></argument>, <argument><expr><name>newfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>newfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_bin_set_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_bin_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_CORE_BIN_ACC_SYMBOLS</name></expr></argument>, <argument><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal><operator>)</operator></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bin_set_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<block>{<block_content>

<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>get_closest_map</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>closest_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>symbols</name> <init>= <expr><call><name>r_bin_get_symbols</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>symbol</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>closest_symbol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>symbols</argument>, <argument>iter</argument>, <argument>symbol</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&gt;</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>-</operator> <name>addr</name> <operator>&lt;</operator> <name>closest_addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>closest_addr</name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>-</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>closest_symbol</name> <operator>=</operator> <name>symbol</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>-</operator> <name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&lt;</operator> <name>closest_addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>closest_addr</name> <operator>=</operator> <name>addr</name> <operator>-</operator> <name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>closest_symbol</name> <operator>=</operator> <name>symbol</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>closest_symbol</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RCoreBinFilter</name></type> <name>filter</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>filter</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>closest_symbol</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bin_set_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_bin_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_CORE_BIN_ACC_SYMBOLS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dmi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case> 

<block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sectname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mode</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>baddr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"-r "</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name>sectname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>||</operator> <name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>libname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_debug_modules_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>libname</name> <operator>||</operator>

<operator>(</operator><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>libname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strstr</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>libname</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>baddr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><ternary><condition><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr>?</condition><then> <expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></then><else>: <expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_file_basename</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filesc</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sectname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sect</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>sectname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_sys_cmd_strf</name> <argument_list>(<argument><expr><literal type="string">"env RABIN2_PREFIX=\"%s\" rabin2 %s-B 0x%08"</literal>

<name>PFMT64x</name><literal type="string">" -S \"%s\" | grep \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>, <argument><expr><name>filesc</name></expr></argument>, <argument><expr><name>sect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_sys_cmd_strf</name> <argument_list>(<argument><expr><literal type="string">"env RABIN2_PREFIX=\"%s\" rabin2 %s-B 0x%08"</literal>

<name>PFMT64x</name><literal type="string">" -S \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>baddr</name></expr></argument>, <argument><expr><name>filesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>filesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>libname</name> <operator>||</operator> <name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content> 

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_map_alloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dm addr size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|ERROR| Usage: dm- [addr]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_map_dealloc</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"The address doesn't match with any map.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'L'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_map_alloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dmL addr size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_debug_map_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_map_list_visual</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>,

<argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> 

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_debug_heap</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__linux__</name> <operator>&amp;&amp;</operator> <name>__GNU_LIBRARY__</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"linux_heap_glibc.c"</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"windows_heap.c"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPTYPE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static x* x##_new(x n) {x *m = malloc(sizeof (x));return m? *m = n, m: m; }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>HEAPTYPE</name><argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>regcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name> <modifier>*</modifier></type><name>A</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ut64</name><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name> <modifier>*</modifier></type><name>B</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ut64</name><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>A</name> <operator>&gt;</operator> <operator>*</operator><name>B</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>A</name> <operator>==</operator> <operator>*</operator><name>B</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>regcb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>sorted</name> <init>= <expr><operator>(</operator><name>RList</name><operator>*</operator><operator>)</operator> <name>u</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>ut64_new</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_add_sorted</name> <argument_list>(<argument><expr><name>sorted</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>regcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_debug_ri</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>value</name> <init>= <expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_up_update</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>sorted</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ht_up_foreach</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>regcb</name></expr></argument>, <argument><expr><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>sorted</argument>, <argument>iter</argument>, <argument>addr</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rwx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_debug_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>*</operator><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rwx</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><call><name>r_str_rwx_i</name> <argument_list>(<argument><expr><name>rwx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><operator>*</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>*</operator><name>addr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>Color_YELLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>Color_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rrstr</name> <init>= <expr><call><name>r_core_anal_hasrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>*</operator><name>addr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rrstr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>rrstr</name> <operator>&amp;&amp;</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>rrstr</name></expr></argument>, <argument><expr><literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" ;%s"</literal><name>Color_RESET</name></expr></argument>, <argument><expr><name>rrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_debug_rr</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colorend</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>use_colors</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>diff</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ConsP</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConsP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(core-&gt;cons &amp;&amp; core-&gt;cons-&gt;context-&gt;pal.x) ? core-&gt;cons-&gt;context-&gt;pal.x</cpp:value></cpp:define>

<expr_stmt><expr><name>color</name> <operator>=</operator> <call><name>ConsP</name><argument_list>(<argument><expr><name>creg</name></expr></argument>)</argument_list></call><operator>:</operator> <name>Color_BWHITE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_set_columnsf</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"ssss"</literal></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>, <argument><expr><literal type="string">"reg"</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>bits</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regSize</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regSize</name> <operator>&lt;</operator> <literal type="number">80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>value</name><operator>-</operator><name>diff</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>color</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>delta</name> <operator>&amp;&amp;</operator> <name>use_colors</name><operator>)</operator></expr>?</condition><then> <expr><name>color</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>colorend</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>delta</name> <operator>&amp;&amp;</operator> <name>use_colors</name><operator>)</operator></expr>?</condition><then> <expr><name>Color_RESET</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_NAME_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>role</name> <operator>=</operator> <call><name>r_reg_get_role</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>namestr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>colorend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>valuestr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%"</literal><name>PFMT64x</name><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>colorend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rrstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_core_anal_hasrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>refs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rrstr</name> <operator>=</operator> <name>refs</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_add_rowf</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"ssss"</literal></expr></argument>, <argument><expr><name>role</name></expr></argument>, <argument><expr><name>namestr</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>, <argument><expr><name>rrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>namestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_table_tojson</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>r_table_tostring</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>use_colors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_drpi</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Aliases (Reg-&gt;name)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_NAME_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>r_reg_get_role</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_TYPE_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nmi</name> <init>= <expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"regset %d (%s)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>nmi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>regset</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"* arena %s size %d\n"</literal></expr></argument>, <argument><expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>arena</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;regs</argument>, <argument>iter</argument>, <argument>ri</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tpe</name> <init>= <expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arn</name> <init>= <expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>arena</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s %s @ %s (offset: %d size: %d)"</literal></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>tpe</name></expr></argument>, <argument><expr><name>arn</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>offset</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ri</name><operator>-&gt;</operator><name>offset</name></name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>ri</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator> <operator>&gt;</operator> <name><name>rs</name><operator>-&gt;</operator><name>arena</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" *OVERFLOW*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_reg_profile</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_str</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No register profile defined. Try 'dr.'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_cmt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_cmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>isspace</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"gdb "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_parse_gdb_profile</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_reg_set_profile</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_plugin_set_reg_profile</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"size = %d\n"</literal></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>arena</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<expr_stmt><expr><call><name>show_drpi</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>n</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name> <operator>&amp;&amp;</operator> <name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegArena</name> <modifier>*</modifier></type><name>arena</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;pool</argument>, <argument>iter</argument>, <argument>arena</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>newbytes</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newbytes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>arena</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <name>newbytes</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arena</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid arena size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>rs</name><operator>-&gt;</operator><name>arena</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find GPR register arena.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"alias_info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_NAME_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"role_str"</literal></expr></argument>, <argument><expr><call><name>r_reg_get_role</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"reg"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"reg_info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_TYPE_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;reg-&gt;regset[i].regs</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type_str"</literal></expr></argument>, <argument><expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>from_a</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"arp"</literal></expr>, <expr><literal type="string">"arpi"</literal></expr>, <expr><literal type="string">"arp."</literal></expr>, <expr><literal type="string">"arpj"</literal></expr>, <expr><literal type="string">"arps"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>help_msg</name> <init>= <expr><name>help_msg_drp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>help_msg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>help_msg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>help_msg</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>help_msg</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>from_a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>help_msg</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name><name>from_a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>help_msg</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name><name>from_a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>help_msg</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <name><name>from_a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>help_msg</name><index>[<expr><literal type="number">21</literal></expr>]</index></name> <operator>=</operator> <name><name>from_a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static int showreg(RCore *core, const char *str, bool use_color) {

ut64 off;

utX value;

int err;

int bits = atoi (str);

r_debug_reg_sync (core-&gt;dbg, R_REG_TYPE_ALL, false); 

if (bits) {

r_debug_reg_list (core-&gt;dbg, R_REG_TYPE_GPR, bits, str[0], use_color? Color_GREEN: NULL);

} else {

off = r_debug_reg_get_err (core-&gt;dbg, str + 1, &amp;err, &amp;value);

core-&gt;num-&gt;value = off;

switch (err) {

case 0:

r_cons_printf ("0x%08"PFMT64x"\n", off);

break;

case 1:

r_cons_printf ("Unknown register '%s'\n", str + 1);

break;

case 80:

r_cons_printf ("0x%04x%016"PFMT64x"\n", value.v80.High, value.v80.Low);

break;

case 96:

r_cons_printf ("0x%08x%016"PFMT64x"\n", value.v96.High, value.v96.Low);

break;

case 128:

r_cons_printf ("0x%016"PFMT64x"%016"PFMT64x"\n", value.v128.High, value.v128.Low);

break;

default:

r_cons_printf ("Error %i while retrieving '%s' \n", err, str + 1);

core-&gt;num-&gt;value = 0;

}

}

return bits;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PACK_TYPES</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_INT_PACK_TYPES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name><name>pack_sizes</name><index>[<expr><name>NUM_PACK_TYPES</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">64</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>pack_format</name><index>[<expr><name>NUM_PACK_TYPES</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"%s0x%02"</literal> <name>PFMT64x</name></expr>, <expr><literal type="string">"%s0x%04"</literal> <name>PFMT64x</name></expr>, <expr><literal type="string">"%s0x%08"</literal> <name>PFMT64x</name></expr>,

<expr><literal type="string">"%s0x%016"</literal> <name>PFMT64x</name></expr>, <expr><literal type="string">"%s%lf"</literal></expr> , <expr><literal type="string">"%s%lf"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pack_print</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>reg</name></type></parameter>, <parameter><type><name>pack_type_index</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_cons_printf (pack_format[pack_type_index], i != 0 ? " " : "", reg);</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_reg_print_packed_reg</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>explicit_size</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>pack_show</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pi</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pi</name> <operator>&lt;</operator> <name>NUM_PACK_TYPES</name></expr>;</condition> <incr><expr><name>pi</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>explicit_size</name> <operator>||</operator> <name><name>pack_show</name><index>[<expr><name>pi</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>packed_size</name></name> <operator>/</operator> <name><name>pack_sizes</name><index>[<expr><name>pi</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><call><name>r_reg_get_pack</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pack_sizes</name><index>[<expr><name>pi</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>( <expr><name>pi</name> <operator>&gt;</operator> <name>NUM_INT_PACK_TYPES</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>pack_sizes</name><index>[<expr><name>pi</name></expr>]</index></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>dres</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dres</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pack_print</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>dres</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pack_sizes</name><index>[<expr><name>pi</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>float</name></type> <name>fres</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>fres</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pack_print</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>fres</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pack_print</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>__table_format_string</name><parameter_list>(<parameter><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <return>return <expr><call><name>r_table_tojson</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> <return>return <expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><call><name>r_table_tofancystring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__tableRegList</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeString</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeNumber</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeBoolean</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"boolean"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"psize"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"arena"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeBoolean</name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"flags"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"comment"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_TYPE_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>e</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_table_add_row</name> <argument_list>(<argument><expr><name>t</name></expr></argument>,

<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>packed_size</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>arena</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>is_float</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr>?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name></expr>?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>flags</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>comment</name></name></expr>?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>comment</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>fmt</name> <init>= <expr><operator>*</operator><name>str</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>__table_format_string</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_reg</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>r_reg_item_t</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>use_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>R_REG_TYPE_GPR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_64</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">64</literal></expr></then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>use_colors</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newbits</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>str</name><operator>&amp;&amp;</operator><operator>*</operator><name>str</name><operator>)</operator></expr>?</condition><then> <expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newbits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <name>newbits</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ConsP</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConsP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(core-&gt;cons &amp;&amp; core-&gt;cons-&gt;context-&gt;pal.x)? core-&gt;cons-&gt;context-&gt;pal.x</cpp:value></cpp:define>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <call><name>ConsP</name><argument_list>(<argument><expr><name>creg</name></expr></argument>)</argument_list></call><operator>:</operator> <name>Color_BWHITE</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>json_out</name> <init>= <expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <ternary><condition><expr><name>json_out</name></expr> ?</condition><then> <expr><name>str</name> <operator>+</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument> , <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json_out</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>comment</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_knull</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>comment</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register %s doesn't have any comments\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register %s not found\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: drC [register]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>all</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>all</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"drp~=[0]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>all</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>all</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>all</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>args</argument>, <argument>iter</argument>, <argument>arg</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%3s %3s 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>json_out</name> <init>= <expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>json_out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;regs</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json_out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>json_out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'8'</literal></expr>:</case> 

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>R_REG_TYPE_GPR</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>string</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_reg_type_by_name</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_REG_TYPE_GPR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_reg_get_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'8'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_print_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0ll</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegFlags</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"s:%d z:%d c:%d o:%d p:%d\n"</literal></expr></argument>,

<argument><expr><name><name>rf</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>eq</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>v</name> <init>= <expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>eq</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>r_reg_cond_from_string</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegFlags</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_cond_bits_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_cond_apply</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown condition register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_cond_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>r_reg_cond_from_string</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegFlags</name><modifier>*</modifier></type> <name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>o</name> <init>= <expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"unknown conditional or flag register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RRegFlags</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name><operator>==</operator><literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>R_REG_COND_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s:%d "</literal></expr></argument>,

<argument><expr><call><name>r_reg_cond_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>R_REG_COND_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s\n"</literal></expr></argument>,

<argument><expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_reg_cond_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_drx_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_drx_unset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>sl</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>perm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sl</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sl</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>arg</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_str_word_get0(s,x)</cpp:value></cpp:define>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>arg</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>perm</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>r_str_rwx</name> <argument_list>(<argument><expr><call><name>arg</name> <argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_drx_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_drx_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_DRX</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|usage: drx n [address] [length] [perm]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_drx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_drs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_drm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal>

<operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\x00'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>explicit_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>explicit_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>explicit_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>pack_show</name><index>[<expr><name>NUM_PACK_TYPES</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegisterType</name></type> <name>reg_type</name> <init>= <expr><name>R_REG_TYPE_XMM</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\x00'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\x00'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>str</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>explicit_name</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>eq</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>eq</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>explicit_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_PACK_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name><name>pack_sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>explicit_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>explicit_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported wordsize %d\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>explicit_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reg_type</name> <operator>=</operator> <name>R_REG_TYPE_YMM</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\x00'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>explicit_name</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>pack_sizes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pack_show</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unkown comamnd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>explicit_name</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reg_type</name> <operator>==</operator> <name>R_REG_TYPE_YMM</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Setting ymm registers not supported yet!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>val</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_set_pack</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>reg_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>reg_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>explicit_index</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_debug_reg_print_packed_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>explicit_size</name></expr></argument>, <argument><expr><name>pack_show</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><call><name>r_reg_get_pack</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot find multimedia register '%s'\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>reg_type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>head</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter</argument>, <argument>item</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>reg_type</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%-5s = "</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_debug_reg_print_packed_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>explicit_size</name></expr></argument>, <argument><expr><name>pack_show</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_YMM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_YMM</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_XMM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_XMM</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: drf [fpureg] [= value]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>eq</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>val</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__windows__</name></expr></cpp:if>

<decl_stmt><decl><type><name>double</name></type> <name>dval</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>eq</name></expr></argument>, <argument><expr><literal type="string">"%lf"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>dval</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>eq</name></expr></argument>, <argument><expr><literal type="string">"%Lf"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>r_reg_set_double</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_FPU</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_FPU</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>res</name> <init>= <expr><call><name>r_reg_get_longdouble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%Lf\n"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot find multimedia register '%s'\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>-</operator><name>R_REG_TYPE_FPU</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_reg_profile</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name></type> <name>rad</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><name>rad</name> <operator>=</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>role</name> <init>= <expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_reg_type_by_name</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>R_REG_TYPE_LAST</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cmd_debug_reg: unknown type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_drt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>foo</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_case</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"oops. try drn [pc|sp|bp|a0|a1|a2|a3|a4|r0|r1|zf|sf|nf|of]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">','</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__tableRegList</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot retrieve registers from pid %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits2</name></decl>, <decl><type ref="prev"/><name>pcbits</name> <init>= <expr><call><name>grab_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcbits2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pcbits</name> <operator>&amp;&amp;</operator> <name>pcbits</name> <operator>!=</operator> <name>bits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>pcbits2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits2</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt> 

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>orig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits</name> <operator>&amp;&amp;</operator> <name>pcbits</name> <operator>!=</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>orig</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits2</name></decl>, <decl><type ref="prev"/><name>pcbits</name> <init>= <expr><call><name>grab_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcbits2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits2</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits2</name></decl>, <decl><type ref="prev"/><name>pcbits</name> <init>= <expr><call><name>grab_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcbits2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs+regs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits2</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs-\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_debug_ri</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_debug_rr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_debug_rr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pcname</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pcname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>!=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pcbits</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot retrieve registers from pid %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>flags</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" -&gt;"</literal></expr></argument>,

<argument><expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_set_bvalue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>arg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" -&gt;"</literal></expr></argument>,

<argument><expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"unknown register '%s'\n"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*%d"</literal></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>argc</name> <init>= <expr><call><name>r_str_split</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>showreg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>showreg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>backtrace_vars</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>frames</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <literal type="string">"SP"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <literal type="string">"BP"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dsp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dbp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>frames</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>s</name> <init>= <expr><ternary><condition><expr><name><name>f</name><operator>-&gt;</operator><name>sp</name></name></expr> ?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>sp</name></name></expr> </then><else>: <expr><name>dsp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><name><name>f</name><operator>-&gt;</operator><name>bp</name></name></expr> ?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>bp</name></name></expr> </then><else>: <expr><name>dbp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>flagdesc</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>flagdesc2</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>flagdesc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>flagdesc2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>fi</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><literal type="string">"%s+%d"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d 0x%08"</literal><name>PFMT64x</name><literal type="string">" sp: 0x%08"</literal><name>PFMT64x</name><literal type="string">" %-5d"</literal>

<literal type="string">"[%s] %s %s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>f</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"??"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>flagdesc</name></expr></argument>, <argument><expr><name>flagdesc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afvd @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_push</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvd@0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_pop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>dbp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>dsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>asciiart_backtrace</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>frames</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>mymap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <literal type="string">"SP"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <literal type="string">"BP"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dsp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dbp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_debug_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>dsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mymap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RDebugMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">" STACK END ^^^\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">" STACK POINTER: %s\n"</literal></expr></argument>, <argument><expr><name>dsp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" .------------------------.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>frames</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>s</name> <init>= <expr><ternary><condition><expr><name><name>f</name><operator>-&gt;</operator><name>sp</name></name></expr> ?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>sp</name></name></expr> </then><else>: <expr><name>dsp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><name><name>f</name><operator>-&gt;</operator><name>bp</name></name></expr> ?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>bp</name></name></expr> </then><else>: <expr><name>dbp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"[frame %d]"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">" |%4s %10s | ; size %d\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name> <operator>-</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" | ... |\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">" |%4s 0x%016"</literal><name>PFMT64x</name><literal type="string">" | %s\n"</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="string">"; return address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" )------------------------(\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" | ... |\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" `------------------------'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%016"</literal><name>PFMT64x</name><literal type="string">" STACK BOTTOM\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mymap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_map_free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_backtrace_info</name><parameter_list>(<parameter><decl><type><name>RCore</name><modifier>*</modifier></type> <name>core</name></decl></parameter>, <parameter><decl><type><name>RDebugFrame</name><modifier>*</modifier></type> <name>frame</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>flagdesc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>flagdesc2</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>pcstr</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>spstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hex_format</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>flagdesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s+%d"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s+%d"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s+1"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_str_cmp</name> <argument_list>(<argument><expr><operator>*</operator><name>flagdesc</name></expr></argument>, <argument><expr><operator>*</operator><name>flagdesc2</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><operator>*</operator><name>flagdesc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>flagdesc2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hex_format</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%-16"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%-16"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_32</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%-8"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%-8"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_32</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pcstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>spstr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PFMT64d</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>static_debug_stop</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name> <init>= <expr><operator>(</operator><name>RDebug</name> <operator>*</operator><operator>)</operator><name>u</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_stop</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>core_cmd_dbi</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bpi</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>idx</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>r_bp_get_index_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_bp_del_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Breakpoint with index %d not found\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>r_bp_get_index_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>bps_idx_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>bps_idx</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d 0x%08"</literal><name>PFMT64x</name><literal type="string">" E:%d T:%d\n"</literal></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name></expr></argument>, <argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>bps_idx_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>bps_idx</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bp</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|Usage: dbic #cmd\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|Usage: dbic #cmd\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>!</operator><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_index</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>!</operator><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"..\debug\p\native\windows\windows_message.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_ARG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_str_word_get0(str, x)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_breakpoint</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hwbp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>watch</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bpi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sl</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sl</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>watch</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>watch</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sl</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rw</name> <operator>=</operator> <name>R_BP_PROT_READ</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rw</name> <operator>=</operator> <name>R_BP_PROT_WRITE</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"rw"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rw</name> <operator>=</operator> <name>R_BP_PROT_ACCESS</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dbw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dbw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>watch</name></expr></argument>, <argument><expr><name>rw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"$$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_core_flag_get_by_spaces</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s+0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>-</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set breakpoint at '%s'\n"</literal></expr></argument>, <argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_cmd_bp</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bpi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hwbp</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.hwbp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>hex_format</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>watch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <ternary><condition><expr><name>p</name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>UT64_MAX</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unable to add breakpoint (%s)\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"breakpoint %s %s %s\n"</literal></expr></argument>,

<argument><expr><call><name>r_str_rwx_i</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>bpi</name><operator>-&gt;</operator><name>enabled</name></name></expr> ?</condition><then> <expr><literal type="string">"enabled"</literal></expr> </then><else>: <expr><literal type="string">"disabled"</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>symbols</name> <init>= <expr><call><name>r_bin_get_symbols</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>symbol</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>symbols</argument>, <argument>iter</argument>, <argument>symbol</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>symbol</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>R_BIN_TYPE_FUNC_STR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_noreturn_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><literal type="string">"sym"</literal></expr></argument>, <argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unable to add a breakpoint"</literal>

<literal type="string">"into a noreturn function %s at addr 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;bp-&gt;bps</argument>, <argument>iter</argument>, <argument>bp</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>bp</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_str_get2</name> <argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>backtrace_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>asciiart_backtrace</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_set_trace_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>r_bp_set_trace</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">' '</literal></expr>;</condition><incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_set_trace_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>r_bp_set_trace</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>!</operator><name><name>bpi</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot unset tracepoint\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hex_format</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flagdesc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flagdesc2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pcstr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>spstr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_backtrace_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagdesc2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spstr</name></expr></argument>, <argument><expr><name>hex_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s{\"idx\":%d,\"pc\":%s,\"sp\":%s,\"frame_size\":%d,"</literal>

<literal type="string">"\"fname\":\"%s\",\"desc\":\"%s%s\"}"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><literal type="string">" ,"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name>i</name></expr></argument>,

<argument><expr><name>pcstr</name></expr></argument>, <argument><expr><name>spstr</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>frame</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>flagdesc</name></expr> ?</condition><then> <expr><name>flagdesc</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>flagdesc2</name></expr> ?</condition><then> <expr><name>flagdesc2</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>flagdesc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pcstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>spstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_reverse</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name>i</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"db?~dbt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_reverse</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f-bt.*\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f bt.frame%d = 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f bt.frame%d.stack %d 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hex_format</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flagdesc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flagdesc2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pcstr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>spstr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_backtrace_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>frame</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagdesc2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spstr</name></expr></argument>, <argument><expr><name>hex_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s sp: %s %-5d"</literal>

<literal type="string">"[%s] %s %s\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>,

<argument><expr><name>pcstr</name></expr></argument>, <argument><expr><name>spstr</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>frame</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"??"</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>flagdesc</name></expr> ?</condition><then> <expr><name>flagdesc</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>flagdesc2</name></expr> ?</condition><then> <expr><name>flagdesc2</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>flagdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>flagdesc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pcstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>spstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dbt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <operator>(</operator><name>st64</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64d</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>module</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set breakpoint.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <expr_stmt><expr><call><name>r_bp_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <expr_stmt><expr><call><name>r_bp_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <expr_stmt><expr><call><name>r_bp_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_del_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_ARG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_str_word_get0(str, x)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sl</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>DB_ARG</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No breakpoint defined at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"- Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot strdup. Your heap is fucked up\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Use: dbc [addr] [command]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No breakpoint defined at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"1 Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot strdup. Your heap is fucked up\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Use: dbC [addr] [command]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set breakpoint (%s)\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_bp_enable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><name>bpi</name> <operator>=</operator> <call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find breakpoint at "</literal>

<literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bpi</name> <operator>&amp;&amp;</operator> <name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>bpi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>r_bp_enable_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><call><name>r_bp_enable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>r_bp_enable_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><call><name>r_bp_enable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_bp_plugin_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_bp_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid name: '%s'.\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_bp_plugin_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid name: '%s'.\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dh [plugin-name] #select a debug handler plugin\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<case>case <expr><literal type="char">'W'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_w32_add_winmsg_breakpoint</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"Breakpoint set.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"Breakpoint not set.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<expr_stmt><expr><call><name>add_breakpoint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'H'</literal></expr>:</case> 

<expr_stmt><expr><call><name>add_breakpoint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>watch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><call><name>add_breakpoint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>watch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<expr_stmt><expr><call><name>core_cmd_dbi</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RTreeNode</name> <modifier>*</modifier></type><name>add_trace_tree_child</name> <parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>RTree</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>t_node</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>dbkey</name><index>[<expr><name>TN_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>dbkey</name></expr></argument>, <argument><expr><name>TN_KEY_LEN</name></expr></argument>, <argument><expr><name>TN_KEY_FMT</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t_node</name> <operator>=</operator> <operator>(</operator>struct <name>trace_node</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>dbkey</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t_node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t_node</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>trace_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t_node</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t_node</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>dbkey</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>t_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>t_node</name><operator>-&gt;</operator><name>refs</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>r_tree_add_node</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>t_node</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>RCore</name> <modifier>*</modifier></type><name>_core</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trace_traverse_pre</name> <parameter_list>(<parameter><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>RTreeVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_node</name></name> <modifier>*</modifier></type><name>tn</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tn</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>depth</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>_core</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>_core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" refs %d %s\n"</literal></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>tn</name><operator>-&gt;</operator><name>refs</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trace_traverse</name> <parameter_list>(<parameter><decl><type><name>RTree</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RTreeVisitor</name></type> <name>vis</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\x1b[2K\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fflush</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vis</name><operator>.</operator><name>pre_visit</name></name> <operator>=</operator> <operator>(</operator><name>RTreeNodeVisitCb</name><operator>)</operator><name>trace_traverse_pre</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_tree_dfs</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_debug_trace_calls</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>final_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>trace_libs</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.trace.libs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>shallow_trace</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.trace.inrange"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>tracenodes</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tracenodes</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTree</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tree</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>debug_to</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTreeNode</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trace_libs</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOOP</name></expr></cpp:if>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>bounds</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"dbg.program"</literal></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_tree_add_node</name> <argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>tr</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>addr_in_range</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>debug_to</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_debug_continue_until</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>debug_to</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_step</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>debug_to</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>final_addr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr_in_range</name> <operator>=</operator> <name>addr</name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name>to</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%d %"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name>n</name><operator>++</operator></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>called_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>called_in_range</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>called_addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>called_in_range</name> <operator>=</operator> <name>called_addr</name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>called_addr</name> <operator>&lt;</operator> <name>to</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called_in_range</name> <operator>&amp;&amp;</operator> <name>addr_in_range</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>shallow_trace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>debug_to</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>aop</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_in_range</name> <operator>||</operator> <name>shallow_trace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>add_trace_tree_child</name> <argument_list>(<argument><expr><name>tracenodes</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>debug_to</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>called_in_range</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>jump</name></name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>jump</name></name> <operator>&lt;</operator> <name>to</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called_in_range</name> <operator>&amp;&amp;</operator> <name>addr_in_range</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>shallow_trace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>debug_to</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>aop</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_in_range</name> <operator>||</operator> <name>shallow_trace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>add_trace_tree_child</name> <argument_list>(<argument><expr><name>tracenodes</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>debug_to</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

r_debug_step (dbg, 1);

r_debug_reg_sync (dbg, R_REG_TYPE_GPR, false);

addr = r_debug_reg_get (dbg, "PC");

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>!=</operator> <name><name>tr</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (addr != gn-&gt;addr) {

eprintf ("Oops. invalid return address 0x%08"PFMT64x

"\n0x%08"PFMT64x"\n", addr, gn-&gt;addr);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>debug_trace_calls</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bp_final</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>final_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No process to debug."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>first_n</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name>first_n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>final_addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>final_addr</name> <operator>=</operator> <name>first_n</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>static_debug_stop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>final_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hwbp</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.hwbp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bp_final</name> <operator>=</operator> <call><name>r_debug_bp_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>final_addr</name></expr></argument>, <argument><expr><name>hwbp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp_final</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set breakpoint at final address (%"</literal><name>PFMT64x</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><name>final_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>do_debug_trace_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>final_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bp_final</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>final_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>_core</name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>trace_traverse</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_debug_esil</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_esil_watch_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>perm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>perm</name> <operator>|=</operator> <name>R_PERM_R</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>perm</name> <operator>|=</operator> <name>R_PERM_W</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>perm</name> <operator>|=</operator> <name>R_PERM_X</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dev</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_esil_watch</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>dev</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_de_msg</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"de"</literal></expr>, <expr><literal type="string">" [perm] [reg|mem] [expr]"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_de_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_esil_watch_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_debug_esil_watch_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: no esil watchpoints defined\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_esil_prestep</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.prestep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_esil_continue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>naddr</name></decl>, <decl><type ref="prev"/><name>fin</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>addr</name> <operator>!=</operator> <name>fin</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_esil_prestep</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_config_get_i</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.prestep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_esil_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>naddr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>naddr</name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Detected loophole\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>naddr</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_des</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_esil_prestep</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.prestep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_esil_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Examples:\n"</literal>

<literal type="string">" de r r rip #stop when reads rip\n"</literal>

<literal type="string">" de rw m ADDR #stop when read or write in ADDR\n"</literal>

<literal type="string">" de w r rdx #stop when rdx register is modified\n"</literal>

<literal type="string">" de x m FROM..TO #stop when rip in range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_debug_kill</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>input</name> <operator>||</operator> <operator>*</operator><name>input</name><operator>==</operator><literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>signame</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>signum</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>signum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>signame</name> <operator>=</operator> <call><name>r_signal_to_string</name> <argument_list>(<argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>signame</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>signame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>signum</name> <operator>=</operator> <call><name>r_signal_from_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>signum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>input</name><operator>==</operator><literal type="char">'o'</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_signal_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>signum</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>signum</name><operator>&lt;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>signum</name> <operator>=</operator> <call><name>r_signal_from_string</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>signum</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>!</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_signal_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_signal_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><name>R_DBG_SIGNAL_SKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_debug_signal_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><name>R_DBG_SIGNAL_CONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid option: %s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid signal: %s\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dko</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"NOTE: [signal] can be a number or a string that resolves with dk?\n"</literal>

<literal type="string">" skip means do not enter into the signal handler\n"</literal>

<literal type="string">" continue means enter into the signal handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_signal_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_signal_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

RListIter *iter;

RDebugSignal *ds;

eprintf ("TODO: list signal handlers of child\n");

RList *list = r_debug_kill_list (core-&gt;dbg);

r_list_foreach (list, iter, ds) {

eprintf ("--&gt; %d\n", ds-&gt;num);

}

r_list_free (list);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sig</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_kill_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_x86_call</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> 

<case>case <expr><literal type="number">0x65</literal></expr>:</case>

<case>case <expr><literal type="number">0x64</literal></expr>:</case>

<case>case <expr><literal type="number">0x26</literal></expr>:</case>

<case>case <expr><literal type="number">0x3e</literal></expr>:</case>

<case>case <expr><literal type="number">0x36</literal></expr>:</case>

<case>case <expr><literal type="number">0x2e</literal></expr>:</case>

<expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xe8</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> 

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x30</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x10</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_x86_ret</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0xc3</literal></expr>:</case>

<case>case <expr><literal type="number">0xcb</literal></expr>:</case>

<case>case <expr><literal type="number">0xc2</literal></expr>:</case>

<case>case <expr><literal type="number">0xca</literal></expr>:</case>

<return>return <expr><name>true</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>cmd_dcu</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>, <decl><type ref="prev"/><name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>dcu_range</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>invalid</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>invalid</name> <operator>||</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dcu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>dcu_range</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>dcu_range</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>nc</name><operator>.</operator><name>errors</name></name> <operator>&amp;&amp;</operator> <call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot continue until unknown address '%s'\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>nc</name><operator>.</operator><name>calc_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dcu_range</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Continue 0x%08"</literal><name>PFMT64x</name><literal type="string">" &gt; 0x%08"</literal><name>PFMT64x</name><literal type="string">" &lt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>from</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name><name>pc</name> <argument_list type="generic">&lt; <argument><expr><name>from</name> <operator>||</operator> <name>pc</name></expr></argument> &gt;</argument_list></name> <name>to</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>btalgo</name></name></expr></argument>, <argument><expr><literal type="string">"trace"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>arch</name></name>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>steps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc_name</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_PC</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>prev_pc</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>prev_call</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>prev_ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp_name</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>old_sp</name></decl>, <decl><type ref="prev"/><name>cur_sp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>old_sp</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>sp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_call</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>ret_addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RDebugFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cur_sp</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>sp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>cur_sp</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ret_addr</name></expr></argument>,

<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ret_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>ret_addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>old_sp</name> <operator>-</operator> <name>cur_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>cur_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <name>old_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_prepend</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name></name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%ld Call from 0x%08"</literal><name>PFMT64x</name><literal type="string">" to 0x%08"</literal><name>PFMT64x</name><literal type="string">" ret 0x%08"</literal><name>PFMT32x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>level</name></expr></argument>, <argument><expr><name>prev_pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>ret_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>old_sp</name> <operator>=</operator> <name>cur_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_call</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prev_ret</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><call><name>r_list_get_bottom</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>head</name> <operator>&amp;&amp;</operator> <name><name>head</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>pc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_pop_head</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>call_frames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" Ret from 0x%08"</literal><name>PFMT64x</name><literal type="string">" to 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>prev_pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>steps</name> <operator>%</operator> <literal type="number">500</literal> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pc</name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"At 0x%08"</literal><name>PFMT64x</name><literal type="string">" after %lu steps\n"</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call> <operator>||</operator> <call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pc</name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_x86_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev_pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_call</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_x86_ret</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev_pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>steps</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Continue until 0x%08"</literal><name>PFMT64x</name><literal type="string">" using %d bpsize\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bpsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_bp_add_sw</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bpsize</name></name></expr></argument>, <argument><expr><name>R_BP_PROT_EXEC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot continue, run ood?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_continue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set breakpoint of size %d at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bpsize</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_continue</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>, <decl><type ref="prev"/><name>old_pid</name></decl>, <decl><type ref="prev"/><name>signum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__linux__</name></expr></cpp:if>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>continue_all_threads</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot continue, run ood?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_continue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: dca\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_continue_back</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot continue back\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_continue_pass_exception</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] Running 'dcs vfork fork clone' behind the scenes...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dcs vfork fork clone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_continue_until_optype</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_TYPE_UCALL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_continue_until_optype</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_TYPE_CALL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_continue_until_optype</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_TYPE_RET</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>signum</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>old_pid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_tid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><name>pid</name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_continue_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>old_pid</name></expr></argument>, <argument><expr><name>old_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_continue_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_debug_cont_syscall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_debug_cont_syscall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_debug_cont_syscall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<block>{<block_content> 

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>t</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>static_debug_stop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" %d %"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name>n</name><operator>++</operator></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dcu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dcu</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"cu $$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_dcu</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><name>old_pid</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_continue</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>old_pid</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_debug_backtrace</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_corefile_name</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>*</operator><name>raw_name</name><operator>)</operator></expr>?</condition><then>

<expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"core.%u"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>raw_name</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_step</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>times</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>times</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>times</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>times</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_trace_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Step failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"%daes"</literal></expr></argument>, <argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>static_debug_stop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_is_dead</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>r_num_conditional</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Stopped after %d instructions\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"3 Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>step_until_eof</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>step_until_flag</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>step_until_inst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>step_until_inst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><call><name>step_until_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>step_until_optype</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>step_until</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dsu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>times</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_bin_get_section_at</name> <argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_step_over</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_step</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>delb</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bpi</name> <init>= <expr><call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>delb</name></expr></argument>, <argument><expr><literal type="string">"db 0x%"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>times</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (aop.jump != UT64_MAX &amp;&amp; aop.fail != UT64_MAX) {

eprintf ("Don't know how to skip this instruction\n");

if (bpi) r_core_cmd0 (core, delb);

break;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name><name>aop</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_debug_reg_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>delb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.skipover"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dss%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>delb</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RBreakpointItem</name> <modifier>*</modifier></type><name>bpi</name> <init>= <expr><call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>delb</name></expr></argument>, <argument><expr><literal type="string">"db 0x%"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_bp_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_step_over</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bpi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>delb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeso%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_step_back</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot step back\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_core_esil_step_back</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot step back\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>step_line</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut8</name><modifier>*</modifier></type><name>getFileData</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator> <call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>consumeBuffer</name><parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errmsg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_buf_seek</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>R_BUF_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><call><name>r_buf_read8</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>follow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugPid</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Debugger commands disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"ate"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_date_get_now</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="char">'q'</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>r_debug_trace_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"offset = 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"opsize = %d\n"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"times = %d\n"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>times</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"count = %d\n"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_trace_tag</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: dtc [addr] ([from] [to] [addr]) - trace calls in debugger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>debug_trace_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;trace-&gt;traces</argument>, <argument>iter</argument>, <argument>trace</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>min</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;trace-&gt;traces</argument>, <argument>iter</argument>, <argument>trace</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>min</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;trace-&gt;traces</argument>, <argument>iter</argument>, <argument>trace</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>min</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;trace-&gt;traces</argument>, <argument>iter</argument>, <argument>trace</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<expr_stmt><expr><call><name>dot_trace_traverse</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_tree_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_trace_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_tracenodes_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <call><name>r_debug_trace_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>args</argument>, <argument>iter</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_debug_trace_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_op_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><call><name>r_debug_trace_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_trace_bb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot analyze opcode at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nonull</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.nonull"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>nonull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_esil_trace_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_esil_trace</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: dte- cannot delete specific logs. Use dte-*\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_esil_trace_show</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dtek [query]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_session_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_session_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_session_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: dts- [id] - Delete trace session"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_session_save</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: dtst [file] - save trace sessions to disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_session_restore</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: dtsf [file] - read trace sessions from disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_session_comment</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: dtsC id comment - add comment for given trace session"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_session_set_idx</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Current Tag: %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_desc_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_desc_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <operator>!</operator><call><name>r_debug_desc_seek</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"lseek"</literal></expr></argument>, <argument><expr><literal type="string">"%d, 0x%"</literal><name>PFMT64x</name><literal type="string">", %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><literal type="string">"Cannot seek"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dd-0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>newfd</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <operator>!</operator><call><name>r_debug_desc_dup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dup2"</literal></expr></argument>, <argument><expr><literal type="string">"%d, %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>newfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot dup %d %d\n"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>off</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> \

<operator>!</operator><call><name>r_debug_desc_read</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>, <argument><expr><literal type="string">"%d, 0x%"</literal><name>PFMT64x</name><literal type="string">", %d"</literal></expr></argument>,

<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><literal type="string">"Cannot read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>off</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> \

<operator>!</operator><call><name>r_debug_desc_write</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"write"</literal></expr></argument>, <argument><expr><literal type="string">"%d, 0x%"</literal><name>PFMT64x</name><literal type="string">", %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><literal type="string">"Cannot write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><literal type="string">"Cannot close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_core_syscallf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"open"</literal></expr></argument>, <argument><expr><literal type="string">"%s, %d, %d"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>consumeBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx "</literal></expr></argument>, <argument><expr><literal type="string">"Cannot open"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>cmd_debug_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>follow</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_bp</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'H'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: transplant process\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>static_debug_stop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmd_debug_continue</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>follow</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_debug_map</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_debug_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>void</name></type> <name>cmd_anal_reg</name> <argument_list>(<argument><expr><name>RCore</name> <operator>*</operator><name>core</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>str</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cmd_anal_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_debug_pid</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'L'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_plugin_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="char">'q'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_debug_plugin_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.backend"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_debug_plugin_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RDebugInfo</name> <modifier>*</modifier></type><name>rdi</name> <init>= <expr><call><name>r_debug_info</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugReasonType</name></type> <name>stop</name> <init>= <expr><call><name>r_debug_stop_reason</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escaped_str</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P</name></cpp:macro> <cpp:value>r_cons_printf</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PS</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{escaped_str = r_str_escape (Y);r_cons_printf(X, escaped_str);free(escaped_str);}</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><name>rdi</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_signal_to_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"type=%s\n"</literal></expr></argument>, <argument><expr><call><name>r_debug_reason_to_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"signal=%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>s</name></expr>?</condition><then> <expr><name>s</name></expr></then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"signum=%d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"sigpid=%d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"addr=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"bp_addr=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>bp_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"inbp=%s\n"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>bp_addr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"baddr=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><call><name>r_debug_get_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"pid=%d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"tid=%d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"stopaddr=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>stopaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>uid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"uid=%d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>gid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"gid=%d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>usr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"usr=%s\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>usr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"exe=%s\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>cmdline</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>rdi</name><operator>-&gt;</operator><name>cmdline</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"cmdline=%s\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>cmdline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>cwd</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>rdi</name><operator>-&gt;</operator><name>cwd</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"cwd=%s\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>cwd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>kernel_stack</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>rdi</name><operator>-&gt;</operator><name>kernel_stack</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"kernel_stack=\n%s\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>kernel_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stop</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"stopreason=%d\n"</literal></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dif $a $b #diff two alias files\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg2</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>getFileData</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>getFileData</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>al</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bl</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDiff</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_diff_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>uni</name> <init>= <expr><call><name>r_diff_buffers_to_string</name> <argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_diff_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>uni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open those alias files\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: dif $a $b #diff two alias files\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>rdi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.signal = %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.sigpid = %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.inbp = %d\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>bp_addr</name></name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.sigaddr = 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.baddr = 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><call><name>r_debug_get_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.pid = %d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.tid = %d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.uid = %d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f dbg.gid = %d\n"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rdi</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_signal_to_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"type\":\"%s\","</literal></expr></argument>, <argument><expr><call><name>r_debug_reason_to_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"signal\":\"%s\","</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>s</name></expr>?</condition><then> <expr><name>s</name></expr></then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"signum\":%d,"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"sigpid\":%d,"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"addr\":%"</literal><name>PFMT64d</name><literal type="string">","</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"inbp\":%s,"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>bp_addr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"baddr\":%"</literal><name>PFMT64d</name><literal type="string">","</literal></expr></argument>, <argument><expr><call><name>r_debug_get_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"stopaddr\":%"</literal><name>PFMT64d</name><literal type="string">","</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>stopaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"pid\":%d,"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"tid\":%d,"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"uid\":%d,"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"gid\":%d,"</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>usr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PS</name><argument_list>(<argument><expr><literal type="string">"\"usr\":\"%s\","</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>usr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PS</name><argument_list>(<argument><expr><literal type="string">"\"exe\":\"%s\","</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>cmdline</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PS</name> <argument_list>(<argument><expr><literal type="string">"\"cmdline\":\"%s\","</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>cmdline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rdi</name><operator>-&gt;</operator><name>cwd</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>PS</name> <argument_list>(<argument><expr><literal type="string">"\"cwd\":\"%s\","</literal></expr></argument>, <argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>cwd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>P</name> <argument_list>(<argument><expr><literal type="string">"\"stopreason\":%d}\n"</literal></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>P</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PS</name></cpp:undef>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>r_debug_reason_to_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>stopaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_debug_info_free</name> <argument_list>(<argument><expr><name>rdi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_debug_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>gcore</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Not debugging, can't write core.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>corefile</name> <init>= <expr><call><name>get_corefile_name</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Writing to file '%s'\n"</literal></expr></argument>, <argument><expr><name>corefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>corefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_buf_new_file</name> <argument_list>(<argument><expr><name>corefile</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dst</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>gcore</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"dg: coredump failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"r_buf_new_file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>corefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_debug_kill</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_file_reopen</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>setRarunProfileString</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_sys_cmd</name> <argument_list>(<argument><expr><literal type="string">"rarun2 -h"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"oodf %s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_file_reopen_debug</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name></name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name> <operator>||</operator> <operator>!</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No open debug session\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_detach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_detach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"oo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"~dr-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_do</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<case>case <expr><literal type="char">'W'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_w32_identify_window</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_w32_print_windows</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>static_debug_stop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition><expr><operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>r_debug_kill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_sys_usleep</name> <argument_list>(<argument><expr><literal type="number">200</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>ut8</name></type> <name><name>bytes</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bytes_len</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes_len</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>r_debug_execute</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>bytes_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid hexpairs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Injection opcodes so long\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RAsmCode</name> <modifier>*</modifier></type><name>acode</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>acode</name> <operator>=</operator> <call><name>r_asm_massemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>acode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_execute</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>acode</name><operator>-&gt;</operator><name>bytes</name></name></expr></argument>, <argument><expr><name><name>acode</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_asm_code_free</name> <argument_list>(<argument><expr><name>acode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>REgg</name> <modifier>*</modifier></type><name>egg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>egg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>asm_arch</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asm_bits</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>asm_os</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.os"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_egg_setup</name> <argument_list>(<argument><expr><name>egg</name></expr></argument>, <argument><expr><name>asm_arch</name></expr></argument>, <argument><expr><name>asm_bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>asm_os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_egg_reset</name> <argument_list>(<argument><expr><name>egg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_egg_load</name> <argument_list>(<argument><expr><name>egg</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_egg_compile</name> <argument_list>(<argument><expr><name>egg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>r_egg_get_bin</name> <argument_list>(<argument><expr><name>egg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>tmpsz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_buf_data</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_execute</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmpsz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>bytes</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bytes_len</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,

<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_execute</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>,

<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>bytes_len</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid hexpairs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Injection opcodes so long\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"gs %s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dx %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing parameter used in gs by dxs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>follow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pc</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pc</name> <operator>&gt;</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>follow</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"sr PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
