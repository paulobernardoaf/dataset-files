<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_search_rop.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_types_base.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>RList</name><modifier>*</modifier></type> <name>parse_list</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str_n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str_n</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>str_n</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>data</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name><modifier>*</modifier></type> <name>get_constants</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strtol</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isFlag</name> <parameter_list>(<parameter><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"flg"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>simulate_op</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>src1</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>src2</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>old_src1</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>old_src2</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>limit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>size</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>^</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>+</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&gt;</operator> <name>src1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <operator>(</operator><name>src1</name> <operator>-</operator> <name>src2</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>-</operator> <name>src2</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>*</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>|</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>/</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>%</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&lt;&lt;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&gt;&gt;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&amp;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"+="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>old_src1</name> <operator>+</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"-="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&gt;</operator> <name>old_src1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <operator>(</operator><name>old_src1</name> <operator>-</operator> <name>src2</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>old_src1</name> <operator>-</operator> <name>src2</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"*="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>old_src1</name> <operator>*</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"/="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>old_src1</name> <operator>/</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"%="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>old_src1</name> <operator>%</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&lt;&lt;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&gt;&gt;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"&amp;="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>&amp;</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"^="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>^</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"|="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>src1</name> <operator>|</operator> <name>src2</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fillRegisterValues</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg_item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regs</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>regs</argument>, <argument>iter_reg</argument>, <argument>reg_item</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg_item</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>esil_split_flg</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>esil_main</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>esil_flg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>split</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><literal type="string">"f,="</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>kCommaHits</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>hits</name> <operator>!=</operator> <name>kCommaHits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>split</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>split</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hits</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>esil_flg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><operator>++</operator><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>esil_main</name> <operator>=</operator> <call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><operator>*</operator><name>esil_flg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ROP</name></cpp:macro> <cpp:value>{ R_FREE (out); R_FREE (esil_flg); R_FREE (esil_main); r_list_free (ops_list); ops_list = NULL; r_list_free (flg_read); flg_read = NULL; r_list_free (flg_write); flg_write = NULL; r_list_free (reg_read); reg_read = NULL; r_list_free (reg_write); reg_write = NULL; r_list_free (mem_read); mem_read = NULL; r_list_free (mem_write); mem_write = NULL; }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>rop_classify_constant</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>constant</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ct</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_main</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_flg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_dst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_const</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>constants</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ops_list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>reg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_read</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>mem_write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>romem</name> <operator>||</operator> <operator>!</operator><name>stats</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ropList</argument>, <argument>iter_r</argument>, <argument>esil_str</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>constants</name> <operator>=</operator> <call><name>get_constants</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>constants</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fillRegisterValues</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>esil_split_flg</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_main</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_flg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><ternary><condition><expr><name>esil_main</name></expr>?</condition><then> <expr><name>esil_main</name></expr></then><else>: <expr><name>esil_str</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ops_list</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ops.list"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>ops_list</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_dst</argument>, <argument>item_dst</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>diff_dst</name></decl>, <decl><type ref="prev"/><name>value_dst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_write</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>, <argument><expr><name>diff_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>value_dst</name> <operator>!=</operator> <name>diff_dst</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>constants</argument>, <argument>iter_const</argument>, <argument>constant</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>value_dst</name> <operator>==</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><literal type="string">"%s &lt;-- 0x%"</literal><name>PFMT64x</name><literal type="string">";"</literal></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>value_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<label><name>continue_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>constants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><name>ct</name></expr>;</return>

<label><name>out_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>constants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>rop_classify_mov</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mov</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_main</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_flg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item_src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>item_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ops_list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>reg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_read</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>mem_write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>romem</name> <operator>||</operator> <operator>!</operator><name>stats</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ropList</argument>, <argument>iter_r</argument>, <argument>esil_str</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>fillRegisterValues</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>esil_split_flg</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_main</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_flg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><ternary><condition><expr><name>esil_main</name></expr>?</condition><then> <expr><name>esil_main</name></expr></then><else>: <expr><name>esil_str</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ops_list</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ops.list"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>ops_list</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_dst</argument>, <argument>item_dst</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>diff_dst</name></decl>, <decl><type ref="prev"/><name>value_dst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_write</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isFlag</name> <argument_list>(<argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_src</argument>, <argument>item_src</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>diff_src</name></decl>, <decl><type ref="prev"/><name>value_src</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_read</name></expr></argument>, <argument><expr><name><name>item_src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item_src</name> <operator>==</operator> <name>item_dst</name> <operator>||</operator> <call><name>isFlag</name> <argument_list>(<argument><expr><name>item_src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>value_src</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_src</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src</name></expr></argument>, <argument><expr><name>diff_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>value_dst</name> <operator>==</operator> <name>value_src</name> <operator>&amp;&amp;</operator> <name>value_dst</name> <operator>!=</operator> <name>diff_dst</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mov</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>mov</name></expr></argument>, <argument><expr><literal type="string">"%s &lt;-- %s;"</literal></expr></argument>,

<argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item_src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<label><name>continue_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><name>mov</name></expr>;</return>

<label><name>out_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>rop_classify_arithmetic</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arithmetic</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_flg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_main</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_src1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_src2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_dst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_ops</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item_src1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>item_src2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>item_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ops_list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>reg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_read</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>mem_write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>op_result</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>op_result_r</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>romem</name> <operator>||</operator> <operator>!</operator><name>stats</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ropList</argument>, <argument>iter_r</argument>, <argument>esil_str</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>fillRegisterValues</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>esil_split_flg</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_main</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_flg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>esil_main</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esil_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ops_list</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ops.list"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ops_list</argument>, <argument>iter_ops</argument>, <argument>op</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_src1</argument>, <argument>item_src1</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_src1</name></decl>, <decl><type ref="prev"/><name>diff_src1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>value_src1</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_src1</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_read</name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_src2</argument>, <argument>item_src2</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_src2</name></decl>, <decl><type ref="prev"/><name>diff_src2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>value_src2</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_src2</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_read</name></expr></argument>, <argument><expr><name><name>item_src2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>iter_src1</name> <operator>==</operator> <name>iter_src2</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_dst</argument>, <argument>item_dst</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>redundant</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>simulate</name></decl>, <decl><type ref="prev"/><name>simulate_r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>value_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_write</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isFlag</name> <argument_list>(<argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>simulate</name> <operator>=</operator> <call><name>simulate_op</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>value_src1</name></expr></argument>, <argument><expr><name>value_src2</name></expr></argument>, <argument><expr><name>diff_src1</name></expr></argument>, <argument><expr><name>diff_src2</name></expr></argument>, <argument><expr><name>op_result</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>simulate_r</name> <operator>=</operator> <call><name>simulate_op</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>value_src2</name></expr></argument>, <argument><expr><name>value_src1</name></expr></argument>, <argument><expr><name>diff_src2</name></expr></argument>, <argument><expr><name>diff_src1</name></expr></argument>, <argument><expr><name>op_result_r</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>simulate</name> <operator>&amp;&amp;</operator> <name>value_dst</name> <operator>==</operator> <operator>*</operator><name>op_result</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &lt;-- %s %s %s;"</literal></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>item_src2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arithmetic</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>arithmetic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>redundant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>redundant</name> <operator>&amp;&amp;</operator> <name>simulate_r</name> <operator>&amp;&amp;</operator> <name>value_dst</name> <operator>==</operator> <operator>*</operator><name>op_result_r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &lt;-- %s %s %s;"</literal></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item_src2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arithmetic</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>arithmetic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block>

<label><name>continue_error</name>:</label> 

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arithmetic</name></expr>;</return>

<label><name>out_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>rop_classify_arithmetic_const</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>constant</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arithmetic</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_flg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>esil_main</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_src1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_dst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_ops</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_const</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item_src1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>item_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>constants</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ops_list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reg_read</name> <init>= <expr><name>NULL</name></expr></init></decl>,

<decl><type ref="prev"><modifier>*</modifier></type><name>reg_write</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_read</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>op_result</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>op_result_r</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>romem</name> <operator>||</operator> <operator>!</operator><name>stats</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ropList</argument>, <argument>iter_r</argument>, <argument>esil_str</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>constants</name> <operator>=</operator> <call><name>get_constants</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>constants</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fillRegisterValues</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>esil_split_flg</name> <argument_list>(<argument><expr><name>esil_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_main</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_flg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>esil_main</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esil_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ops_list</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"ops.list"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"flg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"reg.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_read</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.read"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mem_write</name> <operator>=</operator> <call><name>parse_list</name> <argument_list>(<argument><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem.write"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>continue_error</name>;</goto>

</block_content>}</block></else></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ops_list</argument>, <argument>iter_ops</argument>, <argument>op</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_src1</argument>, <argument>item_src1</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_src1</name></decl>, <decl><type ref="prev"/><name>diff_src1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>value_src1</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_src1</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_read</name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter_dst</argument>, <argument>item_dst</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_dst</name></decl>, <decl><type ref="prev"/><name>diff_dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>redundant</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>simulate</name></decl>, <decl><type ref="prev"/><name>simulate_r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>value_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>diff_dst</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>reg_write</name></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isFlag</name> <argument_list>(<argument><expr><name>item_dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>value_dst</name> <operator>!=</operator> <name>diff_dst</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>constants</argument>, <argument>iter_const</argument>, <argument>constant</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>value_ct</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>simulate</name> <operator>=</operator> <call><name>simulate_op</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>value_src1</name></expr></argument>, <argument><expr><name>value_ct</name></expr></argument>, 

<argument><expr><name>diff_src1</name></expr></argument>, <argument><expr><name>value_ct</name></expr></argument>, <argument><expr><name>op_result</name></expr></argument>, 

<argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>simulate_r</name> <operator>=</operator> <call><name>simulate_op</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>value_ct</name></expr></argument>, <argument><expr><name>value_src1</name></expr></argument>, 

<argument><expr><name>value_ct</name></expr></argument>, <argument><expr><name>diff_src1</name></expr></argument>, <argument><expr><name>op_result_r</name></expr></argument>, 

<argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>simulate</name> <operator>&amp;&amp;</operator> <name>op_result</name> <operator>&amp;&amp;</operator> <name>value_dst</name> <operator>==</operator> <operator>*</operator><name>op_result</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &lt;-- %s %s %s;"</literal></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arithmetic</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>arithmetic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>redundant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>redundant</name> <operator>&amp;&amp;</operator> <name>simulate_r</name> <operator>&amp;&amp;</operator> <name>value_dst</name> <operator>==</operator> <operator>*</operator><name>op_result_r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &lt;-- %s %s %s;"</literal></expr></argument>, <argument><expr><name><name>item_dst</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>constant</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>item_src1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arithmetic</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>arithmetic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arithmetic</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>arithmetic</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block>

<label><name>continue_error</name>:</label>

<expr_stmt><expr><name>FREE_ROP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>constants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_result_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arithmetic</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>rop_classify_nops</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>changes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter_r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>romem</name> <operator>||</operator> <operator>!</operator><name>stats</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ropList</argument>, <argument>iter_r</argument>, <argument>esil_str</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>fillRegisterValues</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block>

<return>return <expr><name>changes</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rop_classify</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><call><name>rop_classify_nops</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mov</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ct</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arithm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arithm_ct</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_nop</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"nop"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_mov</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"mov"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_ct</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"const"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_aritm</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"arithm"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_aritm_ct</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"arithm_ct"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_nop</name> <operator>||</operator> <operator>!</operator><name>db_mov</name> <operator>||</operator> <operator>!</operator><name>db_ct</name> <operator>||</operator> <operator>!</operator><name>db_aritm</name> <operator>||</operator> <operator>!</operator><name>db_aritm_ct</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Could not create SDB 'rop' sub-namespaces\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nop</name> <operator>=</operator> <call><name>rop_classify_nops</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mov</name> <operator>=</operator> <call><name>rop_classify_mov</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <call><name>rop_classify_constant</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arithm</name> <operator>=</operator> <call><name>rop_classify_arithmetic</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arithm_ct</name> <operator>=</operator> <call><name>rop_classify_arithmetic_const</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nop</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_nop</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s NOP"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db_nop</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str_nop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_nop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mov</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_mov</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s MOV { %s }"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>mov</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db_mov</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str_mov</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_mov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_ct</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s LOAD_CONST { %s }"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db_ct</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str_ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arithm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_arithm</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s ARITHMETIC { %s }"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>arithm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db_aritm</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str_arithm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_arithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arithm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arithm_ct</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_arithm_ct</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s ARITHMETIC_CONST { %s }"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>arithm_ct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db_aritm_ct</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str_arithm_ct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_arithm_ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arithm_ct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
