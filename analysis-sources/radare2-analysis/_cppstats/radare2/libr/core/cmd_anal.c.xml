<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_anal.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_a</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">"[abdefFghoprxstc] [...]"</literal></expr>,

<expr><literal type="string">"a"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"alias for aai - analysis information"</literal></expr>,

<expr><literal type="string">"a*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as afl*;ah*;ax*"</literal></expr>,

<expr><literal type="string">"aa"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"analyze all (fcns + bbs) (aa0 to avoid sub renaming)"</literal></expr>,

<expr><literal type="string">"a8"</literal></expr>, <expr><literal type="string">" [hexpairs]"</literal></expr>, <expr><literal type="string">"analyze bytes"</literal></expr>,

<expr><literal type="string">"ab"</literal></expr>, <expr><literal type="string">"[b] [addr]"</literal></expr>, <expr><literal type="string">"analyze block at given address"</literal></expr>,

<expr><literal type="string">"abb"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"analyze N basic blocks in [len] (section.size by default)"</literal></expr>,

<expr><literal type="string">"ac"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manage classes"</literal></expr>,

<expr><literal type="string">"aC"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"analyze function call"</literal></expr>,

<expr><literal type="string">"aCe"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"same as aC, but uses esil with abte to emulate the function"</literal></expr>,

<expr><literal type="string">"ad"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"analyze data trampoline (wip)"</literal></expr>,

<expr><literal type="string">"ad"</literal></expr>, <expr><literal type="string">" [from] [to]"</literal></expr>, <expr><literal type="string">"analyze data pointers to (from-to)"</literal></expr>,

<expr><literal type="string">"ae"</literal></expr>, <expr><literal type="string">"[?] [expr]"</literal></expr>, <expr><literal type="string">"analyze opcode eval expression (see ao)"</literal></expr>,

<expr><literal type="string">"af"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"analyze Functions"</literal></expr>,

<expr><literal type="string">"aF"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as above, but using anal.depth=1"</literal></expr>,

<expr><literal type="string">"ag"</literal></expr>, <expr><literal type="string">"[?] [options]"</literal></expr>, <expr><literal type="string">"draw graphs in various formats"</literal></expr>,

<expr><literal type="string">"ah"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"analysis hints (force opcode size, ...)"</literal></expr>,

<expr><literal type="string">"ai"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"address information (show perms, stack, heap, ...)"</literal></expr>,

<expr><literal type="string">"aj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as a* but in json (aflj)"</literal></expr>,

<expr><literal type="string">"aL"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all asm/anal plugins (e asm.arch=?)"</literal></expr>,

<expr><literal type="string">"an"</literal></expr>,<expr><literal type="string">" [name] [@addr]"</literal></expr>,<expr><literal type="string">"show/rename/create whatever flag/function is used at addr"</literal></expr>,

<expr><literal type="string">"ao"</literal></expr>, <expr><literal type="string">"[?] [len]"</literal></expr>, <expr><literal type="string">"analyze Opcodes (or emulate it)"</literal></expr>,

<expr><literal type="string">"aO"</literal></expr>, <expr><literal type="string">"[?] [len]"</literal></expr>, <expr><literal type="string">"Analyze N instructions in M bytes"</literal></expr>,

<expr><literal type="string">"ap"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"find prelude for current offset"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"like 'dr' but for the esil vm. (registers)"</literal></expr>,

<expr><literal type="string">"as"</literal></expr>, <expr><literal type="string">"[?] [num]"</literal></expr>, <expr><literal type="string">"analyze syscall using dbg.reg"</literal></expr>,

<expr><literal type="string">"av"</literal></expr>, <expr><literal type="string">"[?] [.]"</literal></expr>, <expr><literal type="string">"show vtables"</literal></expr>,

<expr><literal type="string">"ax"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manage refs/xrefs (see also afx?)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aa</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"aa[0*?]"</literal></expr>, <expr><literal type="string">" #see also 'af' and 'afna'"</literal></expr>,

<expr><literal type="string">"aa"</literal></expr>, <expr><literal type="string">" "</literal></expr>, <expr><literal type="string">"alias for 'af@@ sym.*;af@entry0;afva'"</literal></expr>, 

<expr><literal type="string">"aaa"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"autoname functions after aa (see afna)"</literal></expr>,

<expr><literal type="string">"aab"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"abb across bin.sections.rx"</literal></expr>,

<expr><literal type="string">"aac"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"analyze function calls (af @@ `pi len~call[1]`)"</literal></expr>,

<expr><literal type="string">"aac*"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"flag function calls without performing a complete analysis"</literal></expr>,

<expr><literal type="string">"aad"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"analyze data references to code"</literal></expr>,

<expr><literal type="string">"aae"</literal></expr>, <expr><literal type="string">" [len] ([addr])"</literal></expr>, <expr><literal type="string">"analyze references with ESIL (optionally to address)"</literal></expr>,

<expr><literal type="string">"aaf"</literal></expr>, <expr><literal type="string">"[e|r|t] "</literal></expr>, <expr><literal type="string">"analyze all functions (e anal.hasnext=1;afr @@c:isq) (aafe=aef@@f)"</literal></expr>,

<expr><literal type="string">"aaF"</literal></expr>, <expr><literal type="string">" [sym*]"</literal></expr>, <expr><literal type="string">"set anal.in=block for all the spaces between flags matching glob"</literal></expr>,

<expr><literal type="string">"aaFa"</literal></expr>, <expr><literal type="string">" [sym*]"</literal></expr>, <expr><literal type="string">"same as aaF but uses af/a2f instead of af+/afb+ (slower but more accurate)"</literal></expr>,

<expr><literal type="string">"aai"</literal></expr>, <expr><literal type="string">"[j]"</literal></expr>, <expr><literal type="string">"show info of all analysis parameters"</literal></expr>,

<expr><literal type="string">"aan"</literal></expr>, <expr><literal type="string">"[gr?]"</literal></expr>, <expr><literal type="string">"autoname functions (aang = golang, aanr = noreturn propagation)"</literal></expr>,

<expr><literal type="string">"aao"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze all objc references"</literal></expr>,

<expr><literal type="string">"aap"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"find and analyze function preludes"</literal></expr>,

<expr><literal type="string">"aar"</literal></expr>, <expr><literal type="string">"[?] [len]"</literal></expr>, <expr><literal type="string">"analyze len bytes of instructions for references"</literal></expr>,

<expr><literal type="string">"aas"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"analyze symbols (af @@= `isq~[0]`)"</literal></expr>,

<expr><literal type="string">"aaS"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze all flags starting with sym. (af @@ sym.*)"</literal></expr>,

<expr><literal type="string">"aat"</literal></expr>, <expr><literal type="string">" [fcn]"</literal></expr>, <expr><literal type="string">"Analyze all/given function to convert immediate to linked structure offsets (see tl?)"</literal></expr>,

<expr><literal type="string">"aaT"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"analyze code after trap-sleds"</literal></expr>,

<expr><literal type="string">"aau"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"list mem areas (larger than len bytes) not covered by functions"</literal></expr>,

<expr><literal type="string">"aav"</literal></expr>, <expr><literal type="string">" [sat]"</literal></expr>, <expr><literal type="string">"find values referencing a specific section or map"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afls</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afls"</literal></expr>, <expr><literal type="string">"[afls] #sort function list"</literal></expr>,

<expr><literal type="string">"afls"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as aflsa"</literal></expr>,

<expr><literal type="string">"aflsa"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"sort by address (same as afls)"</literal></expr>,

<expr><literal type="string">"aflss"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"sort by size"</literal></expr>,

<expr><literal type="string">"aflsn"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"sort by name"</literal></expr>,

<expr><literal type="string">"aflsb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"sort by number of basic blocks"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ai</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ai"</literal></expr>, <expr><literal type="string">"[j*] [sz] #analysis/address information/imports"</literal></expr>,

<expr><literal type="string">"aii"</literal></expr>, <expr><literal type="string">" [namespace]"</literal></expr>, <expr><literal type="string">"global import (like afii, but global)"</literal></expr>,

<expr><literal type="string">"aii"</literal></expr>, <expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"delete all global imports"</literal></expr>,

<expr><literal type="string">"ai"</literal></expr>, <expr><literal type="string">" @addr"</literal></expr>, <expr><literal type="string">"show address information"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aar</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"aar"</literal></expr>, <expr><literal type="string">"[j*] [sz] #search and analyze xrefs"</literal></expr>,

<expr><literal type="string">"aar"</literal></expr>, <expr><literal type="string">" [sz]"</literal></expr>, <expr><literal type="string">"analyze xrefs in current section or sz bytes of code"</literal></expr>,

<expr><literal type="string">"aar*"</literal></expr>, <expr><literal type="string">" [sz]"</literal></expr>, <expr><literal type="string">"list found xrefs in radare commands format"</literal></expr>,

<expr><literal type="string">"aarj"</literal></expr>, <expr><literal type="string">" [sz]"</literal></expr>, <expr><literal type="string">"list found xrefs in JSON format"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ab</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ab"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"ab"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show basic block information at given address"</literal></expr>,

<expr><literal type="string">"aba"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"analyze esil accesses in basic block (see aea?)"</literal></expr>,

<expr><literal type="string">"abb"</literal></expr>, <expr><literal type="string">" [length]"</literal></expr>, <expr><literal type="string">"analyze N bytes and extract basic blocks"</literal></expr>,

<expr><literal type="string">"abj"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"display basic block information in JSON (alias to afbj)"</literal></expr>,

<expr><literal type="string">"abx"</literal></expr>, <expr><literal type="string">" [hexpair-bytes]"</literal></expr>, <expr><literal type="string">"analyze N bytes"</literal></expr>,

<expr><literal type="string">"abt[?]"</literal></expr>, <expr><literal type="string">" [addr] [num]"</literal></expr>, <expr><literal type="string">"find num paths from current offset to addr"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_abt</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"abt"</literal></expr>, <expr><literal type="string">"[addr] [num] #find num paths from current offset to addr"</literal></expr>,

<expr><literal type="string">"abt"</literal></expr>, <expr><literal type="string">" [addr] [num]"</literal></expr>, <expr><literal type="string">"find num paths from current offset to addr"</literal></expr>,

<expr><literal type="string">"abte"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"emulate from beginning of function to the given address"</literal></expr>,

<expr><literal type="string">"abtj"</literal></expr>, <expr><literal type="string">" [addr] [num]"</literal></expr>, <expr><literal type="string">"display paths in JSON"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ac</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ac"</literal></expr>, <expr><literal type="string">"anal classes commands"</literal></expr>,

<expr><literal type="string">"acl[lj*]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all classes"</literal></expr>,

<expr><literal type="string">"ac"</literal></expr>, <expr><literal type="string">" [class name]"</literal></expr>, <expr><literal type="string">"add class"</literal></expr>,

<expr><literal type="string">"ac-"</literal></expr>, <expr><literal type="string">" [class name]"</literal></expr>, <expr><literal type="string">"delete class"</literal></expr>,

<expr><literal type="string">"acn"</literal></expr>, <expr><literal type="string">" [class name] [new class name]"</literal></expr>, <expr><literal type="string">"rename class"</literal></expr>,

<expr><literal type="string">"acv"</literal></expr>, <expr><literal type="string">" [class name] [addr] ([offset]) ([size])"</literal></expr>, <expr><literal type="string">"add vtable address to class"</literal></expr>,

<expr><literal type="string">"acvf"</literal></expr>, <expr><literal type="string">" [offset] ([class name])"</literal></expr>, <expr><literal type="string">"lookup function address on vtable offset"</literal></expr>,

<expr><literal type="string">"acv-"</literal></expr>, <expr><literal type="string">" [class name] [vtable id]"</literal></expr>, <expr><literal type="string">"delete vtable by id (from acv [class name])"</literal></expr>,

<expr><literal type="string">"acb"</literal></expr>, <expr><literal type="string">" [class name]"</literal></expr>, <expr><literal type="string">"list bases of class"</literal></expr>,

<expr><literal type="string">"acb"</literal></expr>, <expr><literal type="string">" [class name] [base class name] ([offset])"</literal></expr>, <expr><literal type="string">"add base class"</literal></expr>,

<expr><literal type="string">"acb-"</literal></expr>, <expr><literal type="string">" [class name] [base class id]"</literal></expr>, <expr><literal type="string">"delete base by id (from acb [class name])"</literal></expr>,

<expr><literal type="string">"acm"</literal></expr>, <expr><literal type="string">" [class name] [method name] [offset] ([vtable offset])"</literal></expr>, <expr><literal type="string">"add/edit method"</literal></expr>,

<expr><literal type="string">"acm-"</literal></expr>, <expr><literal type="string">" [class name] [method name]"</literal></expr>, <expr><literal type="string">"delete method"</literal></expr>,

<expr><literal type="string">"acmn"</literal></expr>, <expr><literal type="string">" [class name] [method name] [new name]"</literal></expr>, <expr><literal type="string">"rename method"</literal></expr>,

<expr><literal type="string">"ac?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ad</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ad"</literal></expr>, <expr><literal type="string">"[kt] [...]"</literal></expr>,

<expr><literal type="string">"ad"</literal></expr>, <expr><literal type="string">" [N] [D]"</literal></expr>, <expr><literal type="string">"analyze N data words at D depth"</literal></expr>,

<expr><literal type="string">"ad4"</literal></expr>, <expr><literal type="string">" [N] [D]"</literal></expr>, <expr><literal type="string">"analyze N data words at D depth (asm.bits=32)"</literal></expr>,

<expr><literal type="string">"ad8"</literal></expr>, <expr><literal type="string">" [N] [D]"</literal></expr>, <expr><literal type="string">"analyze N data words at D depth (asm.bits=64)"</literal></expr>,

<expr><literal type="string">"adf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze data in function (use like .adf @@=`afl~[0]`"</literal></expr>,

<expr><literal type="string">"adfg"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze data in function gaps"</literal></expr>,

<expr><literal type="string">"adt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze data trampolines (wip)"</literal></expr>,

<expr><literal type="string">"adk"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze data kind (code, text, data, invalid, ...)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ae</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ae[idesr?] [arg]"</literal></expr>, <expr><literal type="string">"ESIL code emulation"</literal></expr>,

<expr><literal type="string">"ae"</literal></expr>, <expr><literal type="string">" [expr]"</literal></expr>, <expr><literal type="string">"evaluate ESIL expression"</literal></expr>,

<expr><literal type="string">"ae?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><literal type="string">"ae??"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show ESIL help"</literal></expr>,

<expr><literal type="string">"ae[aA]"</literal></expr>, <expr><literal type="string">"[f] [count]"</literal></expr>, <expr><literal type="string">"analyse esil accesses (regs, mem..)"</literal></expr>,

<expr><literal type="string">"aeC"</literal></expr>, <expr><literal type="string">"[arg0 arg1..] @ addr"</literal></expr>, <expr><literal type="string">"appcall in esil"</literal></expr>,

<expr><literal type="string">"aec"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"continue until ^C"</literal></expr>,

<expr><literal type="string">"aecs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"continue until syscall"</literal></expr>,

<expr><literal type="string">"aecc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"continue until call"</literal></expr>,

<expr><literal type="string">"aecu"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"continue until address"</literal></expr>,

<expr><literal type="string">"aecue"</literal></expr>, <expr><literal type="string">" [esil]"</literal></expr>, <expr><literal type="string">"continue until esil expression match"</literal></expr>,

<expr><literal type="string">"aef"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"emulate function"</literal></expr>,

<expr><literal type="string">"aefa"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"emulate function to find out args in given or current offset"</literal></expr>,

<expr><literal type="string">"aeg"</literal></expr>, <expr><literal type="string">" [expr]"</literal></expr>, <expr><literal type="string">"esil graph"</literal></expr>,

<expr><literal type="string">"aei"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"initialize ESIL VM state (aei- to deinitialize)"</literal></expr>,

<expr><literal type="string">"aeim"</literal></expr>, <expr><literal type="string">" [addr] [size] [name]"</literal></expr>, <expr><literal type="string">"initialize ESIL VM stack (aeim- remove)"</literal></expr>,

<expr><literal type="string">"aeip"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"initialize ESIL program counter to curseek"</literal></expr>,

<expr><literal type="string">"aek"</literal></expr>, <expr><literal type="string">" [query]"</literal></expr>, <expr><literal type="string">"perform sdb query on ESIL.info"</literal></expr>,

<expr><literal type="string">"aek-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"resets the ESIL.info sdb instance"</literal></expr>,

<expr><literal type="string">"aeli"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list loaded ESIL interrupts"</literal></expr>,

<expr><literal type="string">"aeli"</literal></expr>, <expr><literal type="string">" [file]"</literal></expr>, <expr><literal type="string">"load ESIL interrupts from shared object"</literal></expr>,

<expr><literal type="string">"aelir"</literal></expr>, <expr><literal type="string">" [interrupt number]"</literal></expr>, <expr><literal type="string">"remove ESIL interrupt and free it if needed"</literal></expr>,

<expr><literal type="string">"aep"</literal></expr>, <expr><literal type="string">"[?] [addr]"</literal></expr>, <expr><literal type="string">"manage esil pin hooks"</literal></expr>,

<expr><literal type="string">"aepc"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"change esil PC to this address"</literal></expr>,

<expr><literal type="string">"aer"</literal></expr>, <expr><literal type="string">" [..]"</literal></expr>, <expr><literal type="string">"handle ESIL registers like 'ar' or 'dr' does"</literal></expr>,

<expr><literal type="string">"aets"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"ESIL Trace session"</literal></expr>,

<expr><literal type="string">"aes"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"perform emulated debugger step"</literal></expr>,

<expr><literal type="string">"aesp"</literal></expr>, <expr><literal type="string">" [X] [N]"</literal></expr>, <expr><literal type="string">"evaluate N instr from offset X"</literal></expr>,

<expr><literal type="string">"aesb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"step back"</literal></expr>,

<expr><literal type="string">"aeso"</literal></expr>, <expr><literal type="string">" "</literal></expr>, <expr><literal type="string">"step over"</literal></expr>,

<expr><literal type="string">"aesou"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"step over until given address"</literal></expr>,

<expr><literal type="string">"aess"</literal></expr>, <expr><literal type="string">" "</literal></expr>, <expr><literal type="string">"step skip (in case of CALL, just skip, instead of step into)"</literal></expr>,

<expr><literal type="string">"aesu"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"step until given address"</literal></expr>,

<expr><literal type="string">"aesue"</literal></expr>, <expr><literal type="string">" [esil]"</literal></expr>, <expr><literal type="string">"step until esil expression match"</literal></expr>,

<expr><literal type="string">"aesuo"</literal></expr>, <expr><literal type="string">" [optype]"</literal></expr>, <expr><literal type="string">"step until given opcode type"</literal></expr>,

<expr><literal type="string">"aetr"</literal></expr>, <expr><literal type="string">"[esil]"</literal></expr>, <expr><literal type="string">"Convert an ESIL Expression to REIL"</literal></expr>,

<expr><literal type="string">"aex"</literal></expr>, <expr><literal type="string">" [hex]"</literal></expr>, <expr><literal type="string">"evaluate opcode expression"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_detail_ae</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">"ESIL"</literal></expr>, <expr><literal type="string">" examples and documentation"</literal></expr>,

<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"assign updating internal flags"</literal></expr>,

<expr><literal type="string">":="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"assign without updating internal flags"</literal></expr>,

<expr><literal type="string">"+="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"A+=B =&gt; B,A,+="</literal></expr>,

<expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"A=A+B =&gt; B,A,+,A,="</literal></expr>,

<expr><literal type="string">"++"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"increment, 2,A,++ == 3 (see rsi,--=[1], ... )"</literal></expr>,

<expr><literal type="string">"--"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"decrement, 2,A,-- == 1"</literal></expr>,

<expr><literal type="string">"*="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"A*=B =&gt; B,A,*="</literal></expr>,

<expr><literal type="string">"/="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"A/=B =&gt; B,A,/="</literal></expr>,

<expr><literal type="string">"%="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"A%=B =&gt; B,A,%="</literal></expr>,

<expr><literal type="string">"&amp;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"and ax, bx =&gt; bx,ax,&amp;="</literal></expr>,

<expr><literal type="string">"|"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"or r0, r1, r2 =&gt; r2,r1,|,r0,="</literal></expr>,

<expr><literal type="string">"!="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"negate all bits"</literal></expr>,

<expr><literal type="string">"^="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"xor ax, bx =&gt; bx,ax,^="</literal></expr>,

<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[]"</literal></expr>, <expr><literal type="string">"mov eax,[eax] =&gt; eax,[],eax,="</literal></expr>,

<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"[]"</literal></expr>, <expr><literal type="string">"mov [eax+3], 1 =&gt; 1,3,eax,+,=[]"</literal></expr>,

<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"[1]"</literal></expr>, <expr><literal type="string">"mov byte[eax],1 =&gt; 1,eax,=[1]"</literal></expr>,

<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"[8]"</literal></expr>, <expr><literal type="string">"mov [rax],1 =&gt; 1,rax,=[8]"</literal></expr>,

<expr><literal type="string">"[]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"peek from random position"</literal></expr>,

<expr><literal type="string">"[N]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"peek word of N bytes from popped address"</literal></expr>,

<expr><literal type="string">"[*]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"peek some from random position"</literal></expr>,

<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"[*]"</literal></expr>, <expr><literal type="string">"poke some at random position"</literal></expr>,

<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"int 0x80 =&gt; 0x80,$"</literal></expr>,

<expr><literal type="string">"$$"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"simulate a hardware trap"</literal></expr>,

<expr><literal type="string">"=="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"pops twice, compare and update esil flags"</literal></expr>,

<expr><literal type="string">"&lt;"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"compare for smaller"</literal></expr>,

<expr><literal type="string">"&lt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"compare for smaller or equal"</literal></expr>,

<expr><literal type="string">"&gt;"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"compare for bigger"</literal></expr>,

<expr><literal type="string">"&gt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"compare bigger for or equal"</literal></expr>,

<expr><literal type="string">"&gt;&gt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"shr ax, bx =&gt; bx,ax,&gt;&gt;= #shift right"</literal></expr>,

<expr><literal type="string">"&lt;&lt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"shl ax, bx =&gt; bx,ax,&lt;&lt;= #shift left"</literal></expr>,

<expr><literal type="string">"&gt;&gt;&gt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"ror ax, bx =&gt; bx,ax,&gt;&gt;&gt;= #rotate right"</literal></expr>,

<expr><literal type="string">"&lt;&lt;&lt;="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"rol ax, bx =&gt; bx,ax,&lt;&lt;&lt;= #rotate left"</literal></expr>,

<expr><literal type="string">"?{"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"if popped value != 0 run the block until }"</literal></expr>,

<expr><literal type="string">"POP"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"drops last element in the esil stack"</literal></expr>,

<expr><literal type="string">"DUP"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"duplicate last value in stack"</literal></expr>,

<expr><literal type="string">"NUM"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"evaluate last item in stack to number"</literal></expr>,

<expr><literal type="string">"SWAP"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"swap last two values in stack"</literal></expr>,

<expr><literal type="string">"TRAP"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"stop execution"</literal></expr>,

<expr><literal type="string">"BITS"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"16,BITS #change bits, useful for arm/thumb"</literal></expr>,

<expr><literal type="string">"TODO"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"the instruction is not yet esilized"</literal></expr>,

<expr><literal type="string">"STACK"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show contents of stack"</literal></expr>,

<expr><literal type="string">"CLEAR"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"clears the esil stack"</literal></expr>,

<expr><literal type="string">"REPEAT"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"repeat n times"</literal></expr>,

<expr><literal type="string">"BREAK"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"terminates the string parsing"</literal></expr>,

<expr><literal type="string">"SETJT"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"set jump target"</literal></expr>,

<expr><literal type="string">"SETJTS"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"set jump target set"</literal></expr>,

<expr><literal type="string">"SETD"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"set delay slot"</literal></expr>,

<expr><literal type="string">"GOTO"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"jump to the Nth word popped from the stack"</literal></expr>,

<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"esil interrupt"</literal></expr>,

<expr><literal type="string">"$z"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: zero"</literal></expr>,

<expr><literal type="string">"$c"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: carry"</literal></expr>,

<expr><literal type="string">"$b"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: borrow"</literal></expr>,

<expr><literal type="string">"$p"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: parity"</literal></expr>,

<expr><literal type="string">"$s"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: sign"</literal></expr>,

<expr><literal type="string">"$o"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: overflow"</literal></expr>,

<expr><literal type="string">"$ds"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: delay-slot"</literal></expr>,

<expr><literal type="string">"$jt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: jump-target"</literal></expr>,

<expr><literal type="string">"$js"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: jump-target-set"</literal></expr>,

<expr><literal type="string">"$$"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"internal flag: pc address"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aea</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">"aea"</literal></expr>, <expr><literal type="string">" show regs and memory accesses used in a range"</literal></expr>,

<expr><literal type="string">"aea"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Show regs/memory accesses used in N instructions "</literal></expr>,

<expr><literal type="string">"aea*"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Create mem.* flags for memory accesses"</literal></expr>,

<expr><literal type="string">"aeab"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show regs used in current basic block"</literal></expr>,

<expr><literal type="string">"aeaf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show regs used in current function"</literal></expr>,

<expr><literal type="string">"aear"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Show regs read in N instructions"</literal></expr>,

<expr><literal type="string">"aeaw"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Show regs written in N instructions"</literal></expr>,

<expr><literal type="string">"aean"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Show regs not written in N instructions"</literal></expr>,

<expr><literal type="string">"aeaj"</literal></expr>, <expr><literal type="string">" [ops]"</literal></expr>, <expr><literal type="string">"Show aea output in JSON format"</literal></expr>,

<expr><literal type="string">"aeA"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"Show regs used in N bytes (subcommands are the same)"</literal></expr>,

<expr><literal type="string">"Legend:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"I"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"input registers (read before being set)"</literal></expr>,

<expr><literal type="string">"A"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"all regs accessed"</literal></expr>,

<expr><literal type="string">"R"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"register values read"</literal></expr>,

<expr><literal type="string">"W"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"registers written"</literal></expr>,

<expr><literal type="string">"N"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"read but never written"</literal></expr>,

<expr><literal type="string">"V"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"values"</literal></expr>,

<expr><literal type="string">"@R"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"memreads"</literal></expr>,

<expr><literal type="string">"@W"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"memwrites"</literal></expr>,

<expr><literal type="string">"NOTE:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"mem{reads,writes} with PIC only fetch the offset"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aec</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">"aec"</literal></expr>, <expr><literal type="string">" continue until ^c"</literal></expr>,

<expr><literal type="string">"aec"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until exception"</literal></expr>,

<expr><literal type="string">"aecs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until syscall"</literal></expr>,

<expr><literal type="string">"aecc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Continue until call"</literal></expr>,

<expr><literal type="string">"aecu"</literal></expr>, <expr><literal type="string">"[addr]"</literal></expr>, <expr><literal type="string">"Continue until address"</literal></expr>,

<expr><literal type="string">"aecue"</literal></expr>, <expr><literal type="string">"[addr]"</literal></expr>, <expr><literal type="string">"Continue until esil expression"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aeC</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">"aeC"</literal></expr>, <expr><literal type="string">" arg0 arg1 ... @ calladdr"</literal></expr>,

<expr><literal type="string">"aeC"</literal></expr>, <expr><literal type="string">" 1 2 @ sym._add"</literal></expr>, <expr><literal type="string">"Call sym._add(1,2)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aep</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"aep[-c] "</literal></expr>, <expr><literal type="string">" [...]"</literal></expr>,

<expr><literal type="string">"aepc"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"change program counter for esil"</literal></expr>,

<expr><literal type="string">"aep"</literal></expr>, <expr><literal type="string">"-[addr]"</literal></expr>, <expr><literal type="string">"remove pin"</literal></expr>,

<expr><literal type="string">"aep"</literal></expr>, <expr><literal type="string">" [name] @ [addr]"</literal></expr>, <expr><literal type="string">"set pin"</literal></expr>,

<expr><literal type="string">"aep"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list pins"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aets</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"aets "</literal></expr>, <expr><literal type="string">" [...]"</literal></expr>,

<expr><literal type="string">"aets"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all ESIL trace sessions"</literal></expr>,

<expr><literal type="string">"aets+"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Add ESIL trace session"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_af</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"af"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"af"</literal></expr>, <expr><literal type="string">" ([name]) ([addr])"</literal></expr>, <expr><literal type="string">"analyze functions (start at addr or $$)"</literal></expr>,

<expr><literal type="string">"afr"</literal></expr>, <expr><literal type="string">" ([name]) ([addr])"</literal></expr>, <expr><literal type="string">"analyze functions recursively"</literal></expr>,

<expr><literal type="string">"af+"</literal></expr>, <expr><literal type="string">" addr name [type] [diff]"</literal></expr>, <expr><literal type="string">"hand craft a function (requires afb+)"</literal></expr>,

<expr><literal type="string">"af-"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"clean all function analysis data (or function at addr)"</literal></expr>,

<expr><literal type="string">"afa"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze function arguments in a call (afal honors dbg.funcarg)"</literal></expr>,

<expr><literal type="string">"afb+"</literal></expr>, <expr><literal type="string">" fcnA bbA sz [j] [f] ([t]( [d]))"</literal></expr>, <expr><literal type="string">"add bb to function @ fcnaddr"</literal></expr>,

<expr><literal type="string">"afb"</literal></expr>, <expr><literal type="string">"[?] [addr]"</literal></expr>, <expr><literal type="string">"List basic blocks of given function"</literal></expr>,

<expr><literal type="string">"afbF"</literal></expr>, <expr><literal type="string">"([0|1])"</literal></expr>, <expr><literal type="string">"Toggle the basic-block 'folded' attribute"</literal></expr>,

<expr><literal type="string">"afB"</literal></expr>, <expr><literal type="string">" 16"</literal></expr>, <expr><literal type="string">"set current function as thumb (change asm.bits)"</literal></expr>,

<expr><literal type="string">"afC[lc]"</literal></expr>, <expr><literal type="string">" ([addr])@[addr]"</literal></expr>, <expr><literal type="string">"calculate the Cycles (afC) or Cyclomatic Complexity (afCc)"</literal></expr>,

<expr><literal type="string">"afc"</literal></expr>, <expr><literal type="string">"[?] type @[addr]"</literal></expr>, <expr><literal type="string">"set calling convention for function"</literal></expr>,

<expr><literal type="string">"afd"</literal></expr>, <expr><literal type="string">"[addr]"</literal></expr>,<expr><literal type="string">"show function + delta for given offset"</literal></expr>,

<expr><literal type="string">"afF"</literal></expr>, <expr><literal type="string">"[1|0|]"</literal></expr>, <expr><literal type="string">"fold/unfold/toggle"</literal></expr>,

<expr><literal type="string">"afi"</literal></expr>, <expr><literal type="string">" [addr|fcn.name]"</literal></expr>, <expr><literal type="string">"show function(s) information (verbose afl)"</literal></expr>,

<expr><literal type="string">"afj"</literal></expr>, <expr><literal type="string">" [tableaddr] [count]"</literal></expr>, <expr><literal type="string">"analyze function jumptable"</literal></expr>,

<expr><literal type="string">"afl"</literal></expr>, <expr><literal type="string">"[?] [ls*] [fcn name]"</literal></expr>, <expr><literal type="string">"list functions (addr, size, bbs, name) (see afll)"</literal></expr>,

<expr><literal type="string">"afm"</literal></expr>, <expr><literal type="string">" name"</literal></expr>, <expr><literal type="string">"merge two functions"</literal></expr>,

<expr><literal type="string">"afM"</literal></expr>, <expr><literal type="string">" name"</literal></expr>, <expr><literal type="string">"print functions map"</literal></expr>,

<expr><literal type="string">"afn"</literal></expr>, <expr><literal type="string">"[?] name [addr]"</literal></expr>, <expr><literal type="string">"rename name for function at address (change flag too)"</literal></expr>,

<expr><literal type="string">"afna"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"suggest automatic name for current offset"</literal></expr>,

<expr><literal type="string">"afo"</literal></expr>, <expr><literal type="string">"[?j] [fcn.name]"</literal></expr>, <expr><literal type="string">"show address for the function name or current offset"</literal></expr>,

<expr><literal type="string">"afs"</literal></expr>, <expr><literal type="string">"[!] ([fcnsign])"</literal></expr>, <expr><literal type="string">"get/set function signature at current address (afs! uses cfg.editor)"</literal></expr>,

<expr><literal type="string">"afS"</literal></expr>, <expr><literal type="string">"[stack_size]"</literal></expr>, <expr><literal type="string">"set stack frame size for function at current address"</literal></expr>,

<expr><literal type="string">"afsr"</literal></expr>, <expr><literal type="string">" [function_name] [new_type]"</literal></expr>, <expr><literal type="string">"change type for given function"</literal></expr>,

<expr><literal type="string">"aft"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"type matching, type propagation"</literal></expr>,

<expr><literal type="string">"afu"</literal></expr>, <expr><literal type="string">" addr"</literal></expr>, <expr><literal type="string">"resize and analyze function from current address until addr"</literal></expr>,

<expr><literal type="string">"afv[bsra]"</literal></expr>, <expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"manipulate args, registers and variables in function"</literal></expr>,

<expr><literal type="string">"afx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list function references"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afb</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afb"</literal></expr>, <expr><literal type="string">" List basic blocks of given function"</literal></expr>,

<expr><literal type="string">".afbr-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Set breakpoint on every return address of the function"</literal></expr>,

<expr><literal type="string">".afbr-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Remove breakpoint on every return address of the function"</literal></expr>,

<expr><literal type="string">"afb"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"list basic blocks of function"</literal></expr>,

<expr><literal type="string">"afb."</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show info of current basic block"</literal></expr>,

<expr><literal type="string">"afb="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display ascii-art bars for basic block regions"</literal></expr>,

<expr><literal type="string">"afb+"</literal></expr>, <expr><literal type="string">" fcn_at bbat bbsz [jump] [fail] ([diff])"</literal></expr>, <expr><literal type="string">"add basic block by hand"</literal></expr>,

<expr><literal type="string">"afbc"</literal></expr>, <expr><literal type="string">" [addr] [color(ut32)]"</literal></expr>, <expr><literal type="string">"set a color for the bb at a given address"</literal></expr>,

<expr><literal type="string">"afbe"</literal></expr>, <expr><literal type="string">" bbfrom bbto"</literal></expr>, <expr><literal type="string">"add basic-block edge for switch-cases"</literal></expr>,

<expr><literal type="string">"afbi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print current basic block information"</literal></expr>,

<expr><literal type="string">"afbj"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show basic blocks information in json"</literal></expr>,

<expr><literal type="string">"afbr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show addresses of instructions which leave the function"</literal></expr>,

<expr><literal type="string">"afbt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show basic blocks of current function in a table"</literal></expr>,

<expr><literal type="string">"afB"</literal></expr>, <expr><literal type="string">" [bits]"</literal></expr>, <expr><literal type="string">"define asm.bits for the given function"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afc[agl?]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"afc"</literal></expr>, <expr><literal type="string">" convention"</literal></expr>, <expr><literal type="string">"Manually set calling convention for current function"</literal></expr>,

<expr><literal type="string">"afc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show Calling convention for the Current function"</literal></expr>,

<expr><literal type="string">"afc="</literal></expr>, <expr><literal type="string">"([cctype])"</literal></expr>, <expr><literal type="string">"Select or show default calling convention"</literal></expr>,

<expr><literal type="string">"afcr"</literal></expr>, <expr><literal type="string">"[j]"</literal></expr>, <expr><literal type="string">"Show register usage for the current function"</literal></expr>,

<expr><literal type="string">"afca"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Analyse function for finding the current calling convention"</literal></expr>,

<expr><literal type="string">"afcf"</literal></expr>, <expr><literal type="string">"[j] [name]"</literal></expr>, <expr><literal type="string">"Prints return type function(arg1, arg2...), see afij"</literal></expr>,

<expr><literal type="string">"afck"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List SDB details of call loaded calling conventions"</literal></expr>,

<expr><literal type="string">"afcl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all available calling conventions"</literal></expr>,

<expr><literal type="string">"afco"</literal></expr>, <expr><literal type="string">" path"</literal></expr>, <expr><literal type="string">"Open Calling Convention sdb profile from given path"</literal></expr>,

<expr><literal type="string">"afcR"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Register telescoping using the calling conventions order"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afC</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afC"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>,

<expr><literal type="string">"afC"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function cycles cost"</literal></expr>,

<expr><literal type="string">"afCc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"cyclomatic complexity"</literal></expr>,

<expr><literal type="string">"afCl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"loop count (backward jumps)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afi</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afi[jlp*]"</literal></expr>, <expr><literal type="string">" &lt;addr&gt;"</literal></expr>,

<expr><literal type="string">"afi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show information of the function"</literal></expr>,

<expr><literal type="string">"afii"</literal></expr>, <expr><literal type="string">"[-][import]"</literal></expr>, <expr><literal type="string">"show/add/delete imports used in function"</literal></expr>,

<expr><literal type="string">"afi."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show function name in current offset"</literal></expr>,

<expr><literal type="string">"afi*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function, variables and arguments"</literal></expr>,

<expr><literal type="string">"afij"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function info in json format"</literal></expr>,

<expr><literal type="string">"afil"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"verbose function info"</literal></expr>,

<expr><literal type="string">"afip"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show whether the function is pure or not"</literal></expr>,

<expr><literal type="string">"afis"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show function stats (opcode, meta)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afl</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afl"</literal></expr>, <expr><literal type="string">" List all functions"</literal></expr>,

<expr><literal type="string">"afl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions"</literal></expr>,

<expr><literal type="string">"afl."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display function in current offset (see afi.)"</literal></expr>,

<expr><literal type="string">"afl+"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display sum all function sizes"</literal></expr>,

<expr><literal type="string">"afl="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display ascii-art bars with function ranges"</literal></expr>,

<expr><literal type="string">"aflc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"count of functions"</literal></expr>,

<expr><literal type="string">"aflj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions in json"</literal></expr>,

<expr><literal type="string">"aflt"</literal></expr>, <expr><literal type="string">" [query]"</literal></expr>, <expr><literal type="string">"list functions in table format"</literal></expr>,

<expr><literal type="string">"afll"</literal></expr>, <expr><literal type="string">" [column]"</literal></expr>, <expr><literal type="string">"list functions in verbose mode (sorted by column name)"</literal></expr>,

<expr><literal type="string">"afllj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions in verbose mode (alias to aflj)"</literal></expr>,

<expr><literal type="string">"aflm"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions in makefile style (af@@=`aflm~0x`)"</literal></expr>,

<expr><literal type="string">"aflq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions in quiet mode"</literal></expr>,

<expr><literal type="string">"aflqj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list functions in json quiet mode"</literal></expr>,

<expr><literal type="string">"afls"</literal></expr>, <expr><literal type="string">"[?asn]"</literal></expr>, <expr><literal type="string">"sort function list by address, size or name"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afll</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">" List functions in verbose mode"</literal></expr>,

<expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"Table fields:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"address"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"start address"</literal></expr>,

<expr><literal type="string">"size"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function size (realsize)"</literal></expr>,

<expr><literal type="string">"nbbs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of basic blocks"</literal></expr>,

<expr><literal type="string">"edges"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of edges between basic blocks"</literal></expr>,

<expr><literal type="string">"cc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"cyclomatic complexity ( cc = edges - blocks + 2 * exit_blocks)"</literal></expr>,

<expr><literal type="string">"cost"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"cyclomatic cost"</literal></expr>,

<expr><literal type="string">"min bound"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"minimal address"</literal></expr>,

<expr><literal type="string">"range"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function size"</literal></expr>,

<expr><literal type="string">"max bound"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"maximal address"</literal></expr>,

<expr><literal type="string">"calls"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of caller functions"</literal></expr>,

<expr><literal type="string">"locals"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of local variables"</literal></expr>,

<expr><literal type="string">"args"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of function arguments"</literal></expr>,

<expr><literal type="string">"xref"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"number of cross references"</literal></expr>,

<expr><literal type="string">"frame"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function stack size"</literal></expr>,

<expr><literal type="string">"name"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"function name"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afn</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afn[sa]"</literal></expr>, <expr><literal type="string">" Analyze function names"</literal></expr>,

<expr><literal type="string">"afn"</literal></expr>, <expr><literal type="string">" [name]"</literal></expr>, <expr><literal type="string">"rename the function"</literal></expr>,

<expr><literal type="string">"afn"</literal></expr>, <expr><literal type="string">" base64:encodedname"</literal></expr>, <expr><literal type="string">"rename the function"</literal></expr>,

<expr><literal type="string">"afn."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as afn without arguments. show the function name in current offset"</literal></expr>,

<expr><literal type="string">"afna"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"construct a function name for the current offset"</literal></expr>,

<expr><literal type="string">"afns"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all strings associated with the current function"</literal></expr>,

<expr><literal type="string">"afnsj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all strings associated with the current function in JSON format"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afs[r]"</literal></expr>, <expr><literal type="string">" Analyze function signatures"</literal></expr>,

<expr><literal type="string">"afs"</literal></expr>, <expr><literal type="string">"[!] ([fcnsign])"</literal></expr>, <expr><literal type="string">"get/set function signature at current address (afs! uses cfg.editor)"</literal></expr>,

<expr><literal type="string">"afs*"</literal></expr>, <expr><literal type="string">" ([signame])"</literal></expr>, <expr><literal type="string">"get function signature in flags"</literal></expr>,

<expr><literal type="string">"afsj"</literal></expr>, <expr><literal type="string">" ([signame])"</literal></expr>, <expr><literal type="string">"get function signature in JSON"</literal></expr>,

<expr><literal type="string">"afsr"</literal></expr>, <expr><literal type="string">" [function_name] [new_type]"</literal></expr>, <expr><literal type="string">"change type for given function"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aft</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"aft"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"aft"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"type matching analysis for current function"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afv</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afv"</literal></expr>,<expr><literal type="string">"[rbs]"</literal></expr>,

<expr><literal type="string">"afvr"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manipulate register based arguments"</literal></expr>,

<expr><literal type="string">"afvb"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manipulate bp based arguments/locals"</literal></expr>,

<expr><literal type="string">"afvs"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manipulate sp based arguments/locals"</literal></expr>,

<expr><literal type="string">"afv*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"output r2 command to add args/locals to flagspace"</literal></expr>,

<expr><literal type="string">"afvR"</literal></expr>, <expr><literal type="string">" [varname]"</literal></expr>, <expr><literal type="string">"list addresses where vars are accessed (READ)"</literal></expr>,

<expr><literal type="string">"afvW"</literal></expr>, <expr><literal type="string">" [varname]"</literal></expr>, <expr><literal type="string">"list addresses where vars are accessed (WRITE)"</literal></expr>,

<expr><literal type="string">"afva"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"analyze function arguments/locals"</literal></expr>,

<expr><literal type="string">"afvd"</literal></expr>, <expr><literal type="string">" name"</literal></expr>, <expr><literal type="string">"output r2 command for displaying the value of args/locals in the debugger"</literal></expr>,

<expr><literal type="string">"afvn"</literal></expr>, <expr><literal type="string">" [new_name] ([old_name])"</literal></expr>, <expr><literal type="string">"rename argument/local"</literal></expr>,

<expr><literal type="string">"afvt"</literal></expr>, <expr><literal type="string">" [name] [new_type]"</literal></expr>, <expr><literal type="string">"change type for given argument/local"</literal></expr>,

<expr><literal type="string">"afvf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show BP relative stackframe variables"</literal></expr>,

<expr><literal type="string">"afv-"</literal></expr>, <expr><literal type="string">"([name])"</literal></expr>, <expr><literal type="string">"remove all or given var"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afvb</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afvb"</literal></expr>, <expr><literal type="string">" [idx] [name] ([type])"</literal></expr>,

<expr><literal type="string">"afvb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list base pointer based arguments, locals"</literal></expr>,

<expr><literal type="string">"afvb*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as afvb but in r2 commands"</literal></expr>,

<expr><literal type="string">"afvb"</literal></expr>, <expr><literal type="string">" [idx] [name] ([type])"</literal></expr>, <expr><literal type="string">"define base pointer based arguments, locals"</literal></expr>,

<expr><literal type="string">"afvbj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"return list of base pointer based arguments, locals in JSON format"</literal></expr>,

<expr><literal type="string">"afvb-"</literal></expr>, <expr><literal type="string">" [name]"</literal></expr>, <expr><literal type="string">"delete argument/locals at the given name"</literal></expr>,

<expr><literal type="string">"afvbg"</literal></expr>, <expr><literal type="string">" [idx] [addr]"</literal></expr>, <expr><literal type="string">"define var get reference"</literal></expr>,

<expr><literal type="string">"afvbs"</literal></expr>, <expr><literal type="string">" [idx] [addr]"</literal></expr>, <expr><literal type="string">"define var set reference"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afvr</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afvr"</literal></expr>, <expr><literal type="string">" [reg] [type] [name]"</literal></expr>,

<expr><literal type="string">"afvr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list register based arguments"</literal></expr>,

<expr><literal type="string">"afvr*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as afvr but in r2 commands"</literal></expr>,

<expr><literal type="string">"afvr"</literal></expr>, <expr><literal type="string">" [reg] [name] ([type])"</literal></expr>, <expr><literal type="string">"define register arguments"</literal></expr>,

<expr><literal type="string">"afvrj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"return list of register arguments in JSON format"</literal></expr>,

<expr><literal type="string">"afvr-"</literal></expr>, <expr><literal type="string">" [name]"</literal></expr>, <expr><literal type="string">"delete register arguments at the given index"</literal></expr>,

<expr><literal type="string">"afvrg"</literal></expr>, <expr><literal type="string">" [reg] [addr]"</literal></expr>, <expr><literal type="string">"define argument get reference"</literal></expr>,

<expr><literal type="string">"afvrs"</literal></expr>, <expr><literal type="string">" [reg] [addr]"</literal></expr>, <expr><literal type="string">"define argument set reference"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_afvs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"afvs"</literal></expr>, <expr><literal type="string">" [idx] [type] [name]"</literal></expr>,

<expr><literal type="string">"afvs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list stack based arguments and locals"</literal></expr>,

<expr><literal type="string">"afvs*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as afvs but in r2 commands"</literal></expr>,

<expr><literal type="string">"afvs"</literal></expr>, <expr><literal type="string">" [idx] [name] [type]"</literal></expr>, <expr><literal type="string">"define stack based arguments,locals"</literal></expr>,

<expr><literal type="string">"afvsj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"return list of stack based arguments and locals in JSON format"</literal></expr>,

<expr><literal type="string">"afvs-"</literal></expr>, <expr><literal type="string">" [name]"</literal></expr>, <expr><literal type="string">"delete stack based argument or locals with the given name"</literal></expr>,

<expr><literal type="string">"afvsg"</literal></expr>, <expr><literal type="string">" [idx] [addr]"</literal></expr>, <expr><literal type="string">"define var get reference"</literal></expr>,

<expr><literal type="string">"afvss"</literal></expr>, <expr><literal type="string">" [idx] [addr]"</literal></expr>, <expr><literal type="string">"define var set reference"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ag</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ag&lt;graphtype&gt;&lt;format&gt; [addr]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"Graph commands:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"aga"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Data references graph"</literal></expr>,

<expr><literal type="string">"agA"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Global data references graph"</literal></expr>,

<expr><literal type="string">"agc"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Function callgraph"</literal></expr>,

<expr><literal type="string">"agC"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Global callgraph"</literal></expr>,

<expr><literal type="string">"agd"</literal></expr>, <expr><literal type="string">"[format] [fcn addr]"</literal></expr>, <expr><literal type="string">"Diff graph"</literal></expr>,

<expr><literal type="string">"agf"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Basic blocks function graph"</literal></expr>,

<expr><literal type="string">"agi"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Imports graph"</literal></expr>,

<expr><literal type="string">"agr"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"References graph"</literal></expr>,

<expr><literal type="string">"agR"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Global references graph"</literal></expr>,

<expr><literal type="string">"agx"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Cross references graph"</literal></expr>,

<expr><literal type="string">"agg"</literal></expr>, <expr><literal type="string">"[format]"</literal></expr>, <expr><literal type="string">"Custom graph"</literal></expr>,

<expr><literal type="string">"ag-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Clear the custom graph"</literal></expr>,

<expr><literal type="string">"agn"</literal></expr>, <expr><literal type="string">"[?] title body"</literal></expr>, <expr><literal type="string">"Add a node to the custom graph"</literal></expr>,

<expr><literal type="string">"age"</literal></expr>, <expr><literal type="string">"[?] title1 title2"</literal></expr>, <expr><literal type="string">"Add an edge to the custom graph"</literal></expr>,

<expr><literal type="string">""</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"Output formats:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"&lt;blank&gt;"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Ascii art"</literal></expr>,

<expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"r2 commands"</literal></expr>,

<expr><literal type="string">"d"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Graphviz dot"</literal></expr>,

<expr><literal type="string">"g"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Graph Modelling Language (gml)"</literal></expr>,

<expr><literal type="string">"j"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"json ('J' for formatted disassembly)"</literal></expr>,

<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"SDB key-value"</literal></expr>,

<expr><literal type="string">"t"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Tiny ascii art"</literal></expr>,

<expr><literal type="string">"v"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Interactive ascii art"</literal></expr>,

<expr><literal type="string">"w"</literal></expr>, <expr><literal type="string">" [path]"</literal></expr>, <expr><literal type="string">"Write to path or display graph image (see graph.gv.format and graph.web)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_age</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"age [title1] [title2]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"age"</literal></expr>, <expr><literal type="string">" title1 title2"</literal></expr>, <expr><literal type="string">"Add an edge from the node with \"title1\" as title to the one with title \"title2\""</literal></expr>,

<expr><literal type="string">"age"</literal></expr>, <expr><literal type="string">" \"title1 with spaces\" title2"</literal></expr>, <expr><literal type="string">"Add an edge from node \"title1 with spaces\" to node \"title2\""</literal></expr>,

<expr><literal type="string">"age-"</literal></expr>, <expr><literal type="string">" title1 title2"</literal></expr>, <expr><literal type="string">"Remove an edge from the node with \"title1\" as title to the one with title \"title2\""</literal></expr>,

<expr><literal type="string">"age?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_agn</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"agn [title] [body]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"Examples:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"agn"</literal></expr>, <expr><literal type="string">" title1 body1"</literal></expr>, <expr><literal type="string">"Add a node with title \"title1\" and body \"body1\""</literal></expr>,

<expr><literal type="string">"agn"</literal></expr>, <expr><literal type="string">" \"title with space\" \"body with space\""</literal></expr>, <expr><literal type="string">"Add a node with spaces in the title and in the body"</literal></expr>,

<expr><literal type="string">"agn"</literal></expr>, <expr><literal type="string">" title1 base64:Ym9keTE="</literal></expr>, <expr><literal type="string">"Add a node with the body specified as base64"</literal></expr>,

<expr><literal type="string">"agn-"</literal></expr>, <expr><literal type="string">" title1"</literal></expr>, <expr><literal type="string">"Remove a node with title \"title1\""</literal></expr>,

<expr><literal type="string">"agn?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ah</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ah[lba-]"</literal></expr>, <expr><literal type="string">"Analysis Hints"</literal></expr>,

<expr><literal type="string">"ah?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><literal type="string">"ah?"</literal></expr>, <expr><literal type="string">" offset"</literal></expr>, <expr><literal type="string">"show hint of given offset"</literal></expr>,

<expr><literal type="string">"ah"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list hints in human-readable format"</literal></expr>,

<expr><literal type="string">"ah."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list hints in human-readable format from current offset"</literal></expr>,

<expr><literal type="string">"ah-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"remove all hints"</literal></expr>,

<expr><literal type="string">"ah-"</literal></expr>, <expr><literal type="string">" offset [size]"</literal></expr>, <expr><literal type="string">"remove hints at given offset"</literal></expr>,

<expr><literal type="string">"ah*"</literal></expr>, <expr><literal type="string">" offset"</literal></expr>, <expr><literal type="string">"list hints in radare commands format"</literal></expr>,

<expr><literal type="string">"aha"</literal></expr>, <expr><literal type="string">" ppc @ 0x42"</literal></expr>, <expr><literal type="string">"force arch ppc for all addrs &gt;= 0x42 or until the next hint"</literal></expr>,

<expr><literal type="string">"aha"</literal></expr>, <expr><literal type="string">" 0 @ 0x84"</literal></expr>, <expr><literal type="string">"disable the effect of arch hints for all addrs &gt;= 0x84 or until the next hint"</literal></expr>,

<expr><literal type="string">"ahb"</literal></expr>, <expr><literal type="string">" 16 @ 0x42"</literal></expr>, <expr><literal type="string">"force 16bit for all addrs &gt;= 0x42 or until the next hint"</literal></expr>,

<expr><literal type="string">"ahb"</literal></expr>, <expr><literal type="string">" 0 @ 0x84"</literal></expr>, <expr><literal type="string">"disable the effect of bits hints for all addrs &gt;= 0x84 or until the next hint"</literal></expr>,

<expr><literal type="string">"ahc"</literal></expr>, <expr><literal type="string">" 0x804804"</literal></expr>, <expr><literal type="string">"override call/jump address"</literal></expr>,

<expr><literal type="string">"ahd"</literal></expr>, <expr><literal type="string">" foo a0,33"</literal></expr>, <expr><literal type="string">"replace opcode string"</literal></expr>,

<expr><literal type="string">"ahe"</literal></expr>, <expr><literal type="string">" 3,eax,+="</literal></expr>, <expr><literal type="string">"set vm analysis string"</literal></expr>,

<expr><literal type="string">"ahf"</literal></expr>, <expr><literal type="string">" 0x804840"</literal></expr>, <expr><literal type="string">"override fallback address for call"</literal></expr>,

<expr><literal type="string">"ahF"</literal></expr>, <expr><literal type="string">" 0x10"</literal></expr>, <expr><literal type="string">"set stackframe size at current offset"</literal></expr>,

<expr><literal type="string">"ahh"</literal></expr>, <expr><literal type="string">" 0x804840"</literal></expr>, <expr><literal type="string">"highlight this address offset in disasm"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">"[?] 10"</literal></expr>, <expr><literal type="string">"define numeric base for immediates (1, 8, 10, 16, s)"</literal></expr>,

<expr><literal type="string">"ahj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list hints in JSON"</literal></expr>,

<expr><literal type="string">"aho"</literal></expr>, <expr><literal type="string">" call"</literal></expr>, <expr><literal type="string">"change opcode type (see aho?) (deprecated, moved to \"ahd\")"</literal></expr>,

<expr><literal type="string">"ahp"</literal></expr>, <expr><literal type="string">" addr"</literal></expr>, <expr><literal type="string">"set pointer hint"</literal></expr>,

<expr><literal type="string">"ahr"</literal></expr>, <expr><literal type="string">" val"</literal></expr>, <expr><literal type="string">"set hint for return value of a function"</literal></expr>,

<expr><literal type="string">"ahs"</literal></expr>, <expr><literal type="string">" 4"</literal></expr>, <expr><literal type="string">"set opcode size=4"</literal></expr>,

<expr><literal type="string">"ahS"</literal></expr>, <expr><literal type="string">" jz"</literal></expr>, <expr><literal type="string">"set asm.syntax=jz for this opcode"</literal></expr>,

<expr><literal type="string">"aht"</literal></expr>, <expr><literal type="string">" [?] &lt;type&gt;"</literal></expr>, <expr><literal type="string">"Mark immediate as a type offset (deprecated, moved to \"aho\")"</literal></expr>,

<expr><literal type="string">"ahv"</literal></expr>, <expr><literal type="string">" val"</literal></expr>, <expr><literal type="string">"change opcode's val field (useful to set jmptbl sizes in jmp rax)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ahi</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ahi [sbodh] [@ offset]"</literal></expr>, <expr><literal type="string">" Define numeric base"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" [base]"</literal></expr>, <expr><literal type="string">"set numeric base (1, 2, 8, 10, 16)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" b"</literal></expr>, <expr><literal type="string">"set base to binary (2)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" d"</literal></expr>, <expr><literal type="string">"set base to decimal (10)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" h"</literal></expr>, <expr><literal type="string">"set base to hexadecimal (16)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" o"</literal></expr>, <expr><literal type="string">"set base to octal (8)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" p"</literal></expr>, <expr><literal type="string">"set base to htons(port) (3)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" i"</literal></expr>, <expr><literal type="string">"set base to IP address (32)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" S"</literal></expr>, <expr><literal type="string">"set base to syscall (80)"</literal></expr>,

<expr><literal type="string">"ahi"</literal></expr>, <expr><literal type="string">" s"</literal></expr>, <expr><literal type="string">"set base to string (1)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_aht</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: aht[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"ahts"</literal></expr>, <expr><literal type="string">" &lt;offset&gt;"</literal></expr>, <expr><literal type="string">"List all matching structure offsets"</literal></expr>,

<expr><literal type="string">"aht"</literal></expr>, <expr><literal type="string">" &lt;struct.member&gt;"</literal></expr>, <expr><literal type="string">"Change immediate to structure offset"</literal></expr>,

<expr><literal type="string">"aht?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ao</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ao[e?] [len]"</literal></expr>, <expr><literal type="string">"Analyze Opcodes"</literal></expr>,

<expr><literal type="string">"aoj"</literal></expr>, <expr><literal type="string">" N"</literal></expr>, <expr><literal type="string">"display opcode analysis information in JSON for N opcodes"</literal></expr>,

<expr><literal type="string">"aoe"</literal></expr>, <expr><literal type="string">" N"</literal></expr>, <expr><literal type="string">"display esil form for N opcodes"</literal></expr>,

<expr><literal type="string">"aor"</literal></expr>, <expr><literal type="string">" N"</literal></expr>, <expr><literal type="string">"display reil form for N opcodes"</literal></expr>,

<expr><literal type="string">"aos"</literal></expr>, <expr><literal type="string">" N"</literal></expr>, <expr><literal type="string">"display size of N opcodes"</literal></expr>,

<expr><literal type="string">"aom"</literal></expr>, <expr><literal type="string">" [id]"</literal></expr>, <expr><literal type="string">"list current or all mnemonics for current arch"</literal></expr>,

<expr><literal type="string">"aod"</literal></expr>, <expr><literal type="string">" [mnemonic]"</literal></expr>, <expr><literal type="string">"describe opcode for asm.arch"</literal></expr>,

<expr><literal type="string">"aoda"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show all mnemonic descriptions"</literal></expr>,

<expr><literal type="string">"aoc"</literal></expr>, <expr><literal type="string">" [cycles]"</literal></expr>, <expr><literal type="string">"analyze which op could be executed in [cycles]"</literal></expr>,

<expr><literal type="string">"ao"</literal></expr>, <expr><literal type="string">" 5"</literal></expr>, <expr><literal type="string">"display opcode analysis of 5 opcodes"</literal></expr>,

<expr><literal type="string">"ao*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display opcode in r commands"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ar</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: ar"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"#Analysis Registers"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show 'gpr' registers"</literal></expr>,

<expr><literal type="string">"ar."</literal></expr>, <expr><literal type="string">"&gt;$snapshot"</literal></expr>, <expr><literal type="string">"Show r2 commands to set register values to the current state"</literal></expr>,

<expr><literal type="string">"ar,"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show registers in table format (see dr,)"</literal></expr>,

<expr><literal type="string">".ar*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Import register values as flags"</literal></expr>,

<expr><literal type="string">".ar-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Unflag all registers"</literal></expr>,

<expr><literal type="string">"ar0"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Reset register arenas to 0"</literal></expr>,

<expr><literal type="string">"ara"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Manage register arenas"</literal></expr>,

<expr><literal type="string">"arA"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show values of function argument calls (A0, A1, A2, ..)"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">" 16"</literal></expr>, <expr><literal type="string">"Show 16 bit registers"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">" 32"</literal></expr>, <expr><literal type="string">"Show 32 bit registers"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">" all"</literal></expr>, <expr><literal type="string">"Show all bit registers"</literal></expr>,

<expr><literal type="string">"ar"</literal></expr>, <expr><literal type="string">" &lt;type&gt;"</literal></expr>, <expr><literal type="string">"Show all registers of given type"</literal></expr>,

<expr><literal type="string">"arC"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Display register profile comments"</literal></expr>,

<expr><literal type="string">"arr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show register references (telescoping)"</literal></expr>,

<expr><literal type="string">"arrj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show register references (telescoping) in JSON format"</literal></expr>,

<expr><literal type="string">"ar="</literal></expr>, <expr><literal type="string">"([size])(:[regs])"</literal></expr>, <expr><literal type="string">"Show register values in columns"</literal></expr>,

<expr><literal type="string">"ar?"</literal></expr>, <expr><literal type="string">" &lt;reg&gt;"</literal></expr>, <expr><literal type="string">"Show register value"</literal></expr>,

<expr><literal type="string">"arb"</literal></expr>, <expr><literal type="string">" &lt;type&gt;"</literal></expr>, <expr><literal type="string">"Display hexdump of the given arena"</literal></expr>,

<expr><literal type="string">"arc"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Conditional flag registers"</literal></expr>,

<expr><literal type="string">"ard"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show only different registers"</literal></expr>,

<expr><literal type="string">"arn"</literal></expr>, <expr><literal type="string">" &lt;regalias&gt;"</literal></expr>, <expr><literal type="string">"Get regname for pc,sp,bp,a0-3,zf,cf,of,sg"</literal></expr>,

<expr><literal type="string">"aro"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show old (previous) register values"</literal></expr>,

<expr><literal type="string">"arp"</literal></expr>, <expr><literal type="string">"[?] &lt;file&gt;"</literal></expr>, <expr><literal type="string">"Load register profile from file"</literal></expr>,

<expr><literal type="string">"ars"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Stack register state"</literal></expr>,

<expr><literal type="string">"art"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all register types"</literal></expr>,

<expr><literal type="string">"arw"</literal></expr>, <expr><literal type="string">" &lt;hexnum&gt;"</literal></expr>, <expr><literal type="string">"Set contents of the register arena"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ara</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ara[+-s]"</literal></expr>, <expr><literal type="string">"Register Arena Push/Pop/Swap"</literal></expr>,

<expr><literal type="string">"ara"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show all register arenas allocated"</literal></expr>,

<expr><literal type="string">"ara"</literal></expr>, <expr><literal type="string">"+"</literal></expr>, <expr><literal type="string">"push a new register arena for each type"</literal></expr>,

<expr><literal type="string">"ara"</literal></expr>, <expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"pop last register arena"</literal></expr>,

<expr><literal type="string">"aras"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"swap last two register arenas"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_arw</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"arw "</literal></expr>, <expr><literal type="string">"#Set contents of the register arena"</literal></expr>,

<expr><literal type="string">"arw"</literal></expr>, <expr><literal type="string">" &lt;hexnum&gt;"</literal></expr>, <expr><literal type="string">"Set contents of the register arena"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_as</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: as[ljk?]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"syscall name &lt;-&gt; number utility"</literal></expr>,

<expr><literal type="string">"as"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show current syscall and arguments"</literal></expr>,

<expr><literal type="string">"as"</literal></expr>, <expr><literal type="string">" 4"</literal></expr>, <expr><literal type="string">"show syscall 4 based on asm.os and current regs/mem"</literal></expr>,

<expr><literal type="string">"asc[a]"</literal></expr>, <expr><literal type="string">" 4"</literal></expr>, <expr><literal type="string">"dump syscall info in .asm or .h"</literal></expr>,

<expr><literal type="string">"asf"</literal></expr>, <expr><literal type="string">" [k[=[v]]]"</literal></expr>, <expr><literal type="string">"list/set/unset pf function signatures (see fcnsign)"</literal></expr>,

<expr><literal type="string">"asj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list of syscalls in JSON"</literal></expr>,

<expr><literal type="string">"asl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list of syscalls by asm.os and asm.arch"</literal></expr>,

<expr><literal type="string">"asl"</literal></expr>, <expr><literal type="string">" close"</literal></expr>, <expr><literal type="string">"returns the syscall number for close"</literal></expr>,

<expr><literal type="string">"asl"</literal></expr>, <expr><literal type="string">" 4"</literal></expr>, <expr><literal type="string">"returns the name of the syscall number 4"</literal></expr>,

<expr><literal type="string">"ask"</literal></expr>, <expr><literal type="string">" [query]"</literal></expr>, <expr><literal type="string">"perform syscall/ queries"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_av</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"av[?jr*]"</literal></expr>, <expr><literal type="string">" C++ vtables and RTTI"</literal></expr>,

<expr><literal type="string">"av"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search for vtables in data sections and show results"</literal></expr>,

<expr><literal type="string">"avj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"like av, but as json"</literal></expr>,

<expr><literal type="string">"av*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"like av, but as r2 commands"</literal></expr>,

<expr><literal type="string">"avr"</literal></expr>, <expr><literal type="string">"[j@addr]"</literal></expr>, <expr><literal type="string">"try to parse RTTI at vtable addr (see anal.cpp.abi)"</literal></expr>,

<expr><literal type="string">"avra"</literal></expr>, <expr><literal type="string">"[j]"</literal></expr>, <expr><literal type="string">"search for vtables and try to parse RTTI at each of them"</literal></expr>,

<expr><literal type="string">"avrr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"recover class info from all findable RTTI (see ac)"</literal></expr>,

<expr><literal type="string">"avrD"</literal></expr>, <expr><literal type="string">" [classname]"</literal></expr>, <expr><literal type="string">"demangle a class name from RTTI"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ax</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"ax[?d-l*]"</literal></expr>, <expr><literal type="string">" #see also 'afx?'"</literal></expr>,

<expr><literal type="string">"ax"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list refs"</literal></expr>,

<expr><literal type="string">"ax*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"output radare commands"</literal></expr>,

<expr><literal type="string">"ax"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"add code ref pointing to addr (from curseek)"</literal></expr>,

<expr><literal type="string">"ax-"</literal></expr>, <expr><literal type="string">" [at]"</literal></expr>, <expr><literal type="string">"clean all refs/refs from addr"</literal></expr>,

<expr><literal type="string">"ax-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"clean all refs/refs"</literal></expr>,

<expr><literal type="string">"axc"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"add generic code ref"</literal></expr>,

<expr><literal type="string">"axC"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"add code call ref"</literal></expr>,

<expr><literal type="string">"axg"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show xrefs graph to reach current function"</literal></expr>,

<expr><literal type="string">"axg*"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show xrefs graph to given address, use .axg*;aggv"</literal></expr>,

<expr><literal type="string">"axgj"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"show xrefs graph to reach current function in json format"</literal></expr>,

<expr><literal type="string">"axd"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"add data ref"</literal></expr>,

<expr><literal type="string">"axq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list refs in quiet/human-readable format"</literal></expr>,

<expr><literal type="string">"axj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list refs in json format"</literal></expr>,

<expr><literal type="string">"axF"</literal></expr>, <expr><literal type="string">" [flg-glob]"</literal></expr>, <expr><literal type="string">"find data/code references of flags"</literal></expr>,

<expr><literal type="string">"axm"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"copy data/code references pointing to addr to also point to curseek (or at)"</literal></expr>,

<expr><literal type="string">"axt"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"find data/code references to this address"</literal></expr>,

<expr><literal type="string">"axf"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"find data/code references from this address"</literal></expr>,

<expr><literal type="string">"ax."</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"find data/code references from and to this address"</literal></expr>,

<expr><literal type="string">"axff[j]"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"find data/code references from this function"</literal></expr>,

<expr><literal type="string">"axs"</literal></expr>, <expr><literal type="string">" addr [at]"</literal></expr>, <expr><literal type="string">"add string ref"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ae</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>aft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afvb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>afvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>agn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ahi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ara</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpname</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpsize</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>sa</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>sb</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>sa</name> <operator>&gt;</operator> <name>sb</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>sa</name> <operator>&lt;</operator> <name>sb</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpbbs</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>la</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lb</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>&gt;</operator> <name>lb</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>&lt;</operator> <name>lb</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpaddr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator><name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>listOpDescriptions</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s=%s\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JAYRO_03</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JAYRO_03</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_is_bad_call</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufi</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>align</name> <init>= <expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>addr</name> <operator>%</operator> <name>PE_ALIGN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>call_bytes</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>call_bytes</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>call_bytes</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>-</operator> <name>align</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>-</operator> <name>align</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>-</operator> <name>align</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>-</operator> <name>align</name></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>call_bytes</name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>call_bytes</name> <operator>&lt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>|=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name><operator>)</operator><index>[<expr><name>bufi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>call_bytes</name> <operator>+=</operator> <name>addr</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>call_bytes</name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>call_bytes</name> <operator>&lt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__add_vars_sdb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFcnVarsCache</name></type> <name>cache</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cache</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>all_vars</name> <init>= <expr><name><name>cache</name><operator>.</operator><name>rvars</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>all_vars</name></expr></argument>, <argument><expr><name><name>cache</name><operator>.</operator><name>bvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>all_vars</name></expr></argument>, <argument><expr><name><name>cache</name><operator>.</operator><name>svars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>all_vars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"anal/types/func.%s.arg.%d=%s,%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg_count</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"anal/types/func.%s.args=%d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>cmd_anal_aaft</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>seek</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>io_cache_key</name> <init>= <expr><literal type="string">"io.pcache.write"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>io_cache</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>io_cache_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TOFIX: aaft can't run in debugger mode.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>io_cache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>io_cache_key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>seek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach_prev</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>it</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_type_match</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>__add_vars_sdb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>seek</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>io_cache_key</name></expr></argument>, <argument><expr><name>io_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>type_cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cant find function here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>seek</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><name>seek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_type_match</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>seek</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cc_print</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>find_refs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>glob</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>glob</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>glob</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>glob</name> <operator>=</operator> <literal type="string">"str."</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>glob</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: axF [flag-str-filter]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Finding references of flags matching '%s'...\n"</literal></expr></argument>, <argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">".(findstref) @@= `f~%s[0]`"</literal></expr></argument>, <argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"(findstref;f here=$$;s entry0;/r here;f-here)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"(-findstref)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>curseek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flag_every_function</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_FUNCTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_size_from_entry</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>var_help</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afvb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See afv?, afvb?, afvr? and afvs?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>var_accesses_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_local</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name><literal type="string">".%d.%d.%s"</literal></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xss</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>var_local</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xss</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>xss</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>xss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>list_vars</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f-fcnvar*\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f fcnvar.%s @ %s%s%d\n"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr>?</condition><then> <expr><literal type="string">"+"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <literal type="char">'W'</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <literal type="char">'R'</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name> <init>= <expr><ternary><condition><expr><name>type</name> <operator>==</operator> <literal type="char">'R'</literal></expr>?</condition><then><expr><literal type="string">"reads"</literal></expr></then><else>:<expr><literal type="string">"writes"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>var_accesses_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>var_accesses_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_an</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_json</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>tgt_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name> <operator>+</operator> <name>off</name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tgt_addr</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>?</condition><then> <expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></then><else>: <expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>var</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>bar</name> <init>= <expr><call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bar</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><call><name>r_anal_var_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bar</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>,

<argument><expr><name><name>bar</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>bar</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>

?</condition><then> <expr><literal type="number">0</literal></expr>

</then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>bar</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>bar</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"var"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find variable\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tgt_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><call><name>r_anal_function_rename</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"old_name"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"new_name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>tgt_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>va</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>vb</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>vb</name><operator>-&gt;</operator><name>delta</name></name> <operator>-</operator> <name><name>va</name><operator>-&gt;</operator><name>delta</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>delta_cmp2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>va</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>vb</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>va</name><operator>-&gt;</operator><name>delta</name></name> <operator>-</operator> <name><name>vb</name><operator>-&gt;</operator><name>delta</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__cmd_afvf</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>delta_cmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>isarg</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pad</name> <init>= <expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="number">10</literal> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s:%s%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>-</operator><name><name>p</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>delta_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>isarg</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>delta</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pad</name> <init>= <expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="number">10</literal> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s:%s%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ut64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>delta</name></name><operator>)</operator> <operator>-</operator> <literal type="number">0x6a</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>var_cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><operator>*</operator><name>str</name></expr></init></decl>, <decl><type ref="prev"/><name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal><operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>var_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"sp\":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvsj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">",\"bp\":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvbj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">",\"reg\":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvrj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ostr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvs-%s"</literal></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvb-%s"</literal></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvr-%s"</literal></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><literal type="char">'R'</literal></expr>:</case> 

<case>case <expr><literal type="char">'W'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>list_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afv: Cannot find function in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_SPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_recover_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afv: Cannot find function in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_name</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>var</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>old_name</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find var @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>old_name</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>,

<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cant find var by name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afv: Cannot find function in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>v</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_display</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".afvd %s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>a</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s = %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>isarg</name></name></expr> ?</condition><then> <expr><literal type="string">"arg"</literal></expr></then><else>: <expr><literal type="string">"var"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>__cmd_afvf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cant find get by name %s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_retype</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,

<argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>isarg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> 

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,

<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_delete_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is deprecated, use afvd instead\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is deprecated use afvt instead\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vaddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>var_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vaddr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument> , <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>vaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>r_anal_var_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,

<argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find variable with delta %d\n"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rw</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ptr</name> <init>= <expr><ternary><condition><expr><operator>*</operator><name><name>var</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'s'</literal></expr> ?</condition><then> <expr><name>idx</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr> </then><else>: <expr><name>idx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>rw</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vartype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isarg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>scope</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>str</name><operator>++</operator></expr>;</init> <condition><expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>var_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>i</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>isarg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vartype</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vartype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vartype</name> <operator>=</operator> <literal type="string">"int"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>vartype</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <literal type="char">'b'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isarg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>delta</name> <operator>&gt;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isarg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,<argument><expr><name>scope</name></expr></argument>,

<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,

<argument><expr><name>size</name></expr></argument>, <argument><expr><name>isarg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_trampolines</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>element_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>element_size</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>element_size</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f trampoline.%x @ 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f trampoline.%"</literal> <name>PFMT64x</name> <literal type="string">" @ 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %u @ 0x%"</literal> <name>PFMT64x</name> <literal type="string">":%u\n"</literal></expr></argument>, <argument><expr><name>element_size</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>element_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_trampoline</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>a</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><name>p</name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>bits</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">32</literal></expr>:</case>

<expr_stmt><expr><call><name>print_trampolines</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">64</literal></expr>:</case>

<expr_stmt><expr><call><name>print_trampolines</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>syscallNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr> ?</condition><then> <expr><literal type="string">"0x%x"</literal></expr> </then><else>: <expr><literal type="string">"%d"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>cmd_syscall_dostr</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>st64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>N</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>defVector</name> <init>= <expr><call><name>r_syscall_get_swi</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>defVector</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>defVector</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"oeax"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name> <operator>||</operator> <name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>a0</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RSyscallItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>defVector</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s = unknown ()"</literal></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s = %s ("</literal></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>args</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>regidx</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regidx</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>arg</name> <init>= <expr><call><name>r_debug_arg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_CC_TYPE_FASTCALL</name></expr></argument>, <argument><expr><name>regidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>sargs</name></name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>sargs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PFMT64u</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'Z'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><call><name>r_debug_arg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_CC_TYPE_FASTCALL</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>item</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_syscall_item_free</name> <argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_syscall_do</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>st64</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>cmd_syscall_dostr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>core_anal_bytes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nops</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>be</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>use_color</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>R_PRINT_FLAGS_COLOR</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.relsub"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opexstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>totalsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>color</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>label</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<expr_stmt><expr><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_to_reil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>idx</name> <operator>=</operator> <name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>nops</name> <operator>||</operator> <operator>(</operator><name>nops</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>nops</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>idx</name> <operator>+=</operator> <name>ret</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>idx</name></expr></argument>,

<argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_OPEX</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>esilstr</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>opexstr</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>opex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mnem</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>mnem</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mnem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mnem</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fmt</name> <operator>!=</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" ("</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>idx</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x "</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"...)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mnem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_split</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_asm_describe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>

<macro><name>r_cons_printf</name> <argument_list>(<argument><literal type="string">"%s0x%"</literal> PFMT64x Color_RESET <literal type="string">" %s\n"</literal></argument>, <argument>color</argument>, <argument>core-&gt;offset + idx</argument>, <argument>esilstr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>strsub</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_varsub</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>,

<argument><expr><name><name>asmop</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>strsub</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>killme</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_io_read_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>killme</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>refptr</name></name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub_addr</name></name> <operator>=</operator> <name>killme</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,

<argument><expr><name>strsub</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opcode"</literal></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>strsub</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>strsub</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_parse_varsub</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>asmop</name><operator>.</operator><name>size</name></name></expr></argument>,

<argument><expr><name>strsub</name></expr></argument>, <argument><expr><name>strsub</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"disasm"</literal></expr></argument>, <argument><expr><name>strsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pseudo</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">128</literal> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_parse</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>strsub</name></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pseudo</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pseudo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"pseudo"</literal></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>strsub</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_asm_describe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"mnemonic"</literal></expr></argument>, <argument><expr><name>mnem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>mask</name> <init>= <expr><call><name>r_anal_mask</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maskstr</name> <init>= <expr><call><name>r_hex_bin2strdup</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"mask"</literal></expr></argument>, <argument><expr><name>maskstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maskstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>opcode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ophint"</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>jump</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>fail</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>jesil</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>esil</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>hint</name><operator>-&gt;</operator><name>esil</name></name></expr></then><else>: <expr><name>esilstr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>jesil</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>jesil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"esil"</literal></expr></argument>, <argument><expr><name>jesil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"sign"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opexstr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opexstr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_j</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>opexstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bytes</name> <init>= <expr><call><name>r_hex_bin2strdup</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"bytes"</literal></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"val"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>disp</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>disp</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"disp"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>disp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ptr"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datatype</name> <init>= <expr><call><name>r_anal_datatype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>datatype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>datatype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"datatype"</literal></expr></argument>, <argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>reg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"reg"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ireg"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"scale"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>refptr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refptr"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>refptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cycles"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>cycles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"failcycles"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>failcycles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"delay"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>r_anal_stackop_tostring</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>stackop</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stackptr"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>stackptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_COND</name><operator>)</operator></expr>

?</condition><then> <expr><call><name>r_anal_cond_tostring</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cond"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"family"</literal></expr></argument>, <argument><expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>family</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>

<macro><name>r_cons_printf</name> <argument_list>(<argument><literal type="string">"%s0x%"</literal> PFMT64x Color_RESET <literal type="string">"\n"</literal></argument>, <argument>color</argument>, <argument>core-&gt;offset + idx</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_dumpstack</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>disasm</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_varsub</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>,

<argument><expr><name><name>asmop</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>disasm</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>killme</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_io_read_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>killme</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>refptr</name></name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub_addr</name></name> <operator>=</operator> <name>killme</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,

<argument><expr><name>disasm</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>printline</name><parameter_list>(<parameter><type><name>k</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>{ if (use_color)r_cons_printf ("%s%s: " Color_RESET, color, k);elser_cons_printf ("%s: ", k);if (fmt) r_cons_printf (fmt, arg);}</cpp:value></cpp:define>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"address"</literal></expr></argument>, <argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"opcode"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>disasm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>disasm</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_parse_varsub</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>asmop</name><operator>.</operator><name>size</name></name></expr></argument>,

<argument><expr><name>disasm</name></expr></argument>, <argument><expr><name>disasm</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"disasm"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>disasm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pseudo</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">128</literal> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_parse</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>disasm</name></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pseudo</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pseudo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"pseudo"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"mnemonic"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>mnem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_asm_describe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"description"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>mask</name> <init>= <expr><call><name>r_anal_mask</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maskstr</name> <init>= <expr><call><name>r_hex_bin2strdup</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"mask"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>maskstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maskstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>opcode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"ophint"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PFMT64u</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (opexstr &amp;&amp; *opexstr) {

printline ("opex", "%s\n", opexstr);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"bytes"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minsz</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>minsz</name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name>minsz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>minsz</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>idx</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"val"</literal></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"ptr"</literal></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>disp</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>disp</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"disp"</literal></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>disp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>refptr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"refptr"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>refptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"sign"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>sign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datatype</name> <init>= <expr><call><name>r_anal_datatype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>datatype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>datatype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"datatype"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"cycles"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>cycles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>failcycles</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"failcycles"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>failcycles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type2</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"type2"</literal></expr></argument>, <argument><expr><literal type="string">"0x%x\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>type2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>reg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"reg"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"ireg"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"scale"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"esil"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"esil"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>jump</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>dir</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"read"</literal></expr>

</then><else>: <expr><ternary><condition><expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="string">"write"</literal></expr>

</then><else>: <expr><ternary><condition><expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="string">"exec"</literal></expr>

</then><else>: <expr><ternary><condition><expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="string">"ref"</literal></expr></then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"direction"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>fail</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"fail"</literal></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>delay</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"delay"</literal></expr></argument>, <argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_COND</name><operator>)</operator></expr>?</condition><then> <expr><call><name>r_anal_cond_tostring</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"cond"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"family"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>family</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>stackop</name></name> <operator>!=</operator> <name>R_ANAL_STACK_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"stackop"</literal></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_anal_stackop_tostring</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>stackop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>stackptr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printline</name> <argument_list>(<argument><expr><literal type="string">"stackptr"</literal></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>stackptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mnem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fmt</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bb_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>ba</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>ba</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>casecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalCaseOp</name><modifier>*</modifier></type> <name>a</name> <init>= <expr><name>_a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalCaseOp</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>__opaddr</name><parameter_list>(<parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ninstr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>aa</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <call><name>r_anal_bb_offset_inst</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>ab</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <call><name>r_anal_bb_offset_inst</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>aa</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name>ab</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>aa</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_fcn_list_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>one</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>bbaddr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>bbaddr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>one</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bbaddr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs blocks\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>flist</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>r_listinfo_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flist</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RInterval</name></type> <name>inter</name> <init>= <expr><operator>(</operator><name>RInterval</name><operator>)</operator> <block>{<expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>, <expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>r_listinfo_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>info</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>flist</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_visual_list</name> <argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,

<argument><expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>r_table_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_set_columnsf</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"xdxx"</literal></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>one</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bbaddr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bbaddr</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>||</operator> <name>bbaddr</name> <operator>&gt;=</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_table_add_rowf</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"xdxx"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>retaddr</name> <init>= <expr><call><name>r_anal_bb_opaddr_i</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ninstr</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>retaddr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"db 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>retaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"-*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"db-0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>retaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>retaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f bb.%05"</literal> <name>PFMT64x</name> <literal type="string">" = 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;</operator> <literal type="number">0xFFFFF</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inputs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>outputs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter2</argument>, <argument>b2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inputs</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>fail</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inputs</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outputs</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outputs</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"switch_op"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"min_val"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>min_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"def_val"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>def_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"max_val"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>max_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>case_op_iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>case_op</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>b-&gt;switch_op-&gt;cases</argument>, <argument>case_op_iter</argument>, <argument>case_op</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>opaddr</name> <init>= <expr><call><name>__opaddr</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opaddr"</literal></expr></argument>, <argument><expr><name>opaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"inputs"</literal></expr></argument>, <argument><expr><name>inputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"outputs"</literal></expr></argument>, <argument><expr><name>outputs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ninstr"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ninstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"traced"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>traced</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inputs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>outputs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter2</argument>, <argument>b2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inputs</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b2</name><operator>-&gt;</operator><name>fail</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inputs</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outputs</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outputs</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>unique_cases</name> <init>= <expr><call><name>r_list_uniq</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>cases</name></name></expr></argument>, <argument><expr><name>casecmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>outputs</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>unique_cases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>unique_cases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"jump: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fail: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>opaddr</name> <init>= <expr><call><name>__opaddr</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"opaddr: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>opaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"addr: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\nsize: %d\ninputs: %d\noutputs: %d\nninstr: %d\ntraced: %s\n"</literal></expr></argument>,

<argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>inputs</name></expr></argument>, <argument><expr><name>outputs</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>ninstr</name></name></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>traced</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>r_debug_trace_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" %02X:%04X %d"</literal></expr></argument>,

<argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>tp</name></expr>?</condition><then> <expr><name><name>tp</name><operator>-&gt;</operator><name>times</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>tp</name></expr>?</condition><then> <expr><name><name>tp</name><operator>-&gt;</operator><name>count</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" j 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" f 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>unique_cases</name> <init>= <expr><call><name>r_list_uniq</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>cases</name></name></expr></argument>, <argument><expr><name>casecmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>unique_cases</argument>, <argument>iter</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" s 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>unique_cases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>r_table_tofancystring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_bb_edge</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>switch_addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>case_addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>blocks</name> <init>= <expr><call><name>r_anal_get_blocks_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>switch_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>blocks</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_block_add_switch_case</name> <argument_list>(<argument><expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>switch_addr</name></expr></argument>, <argument><expr><name>case_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_fcn_del_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find basic block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>anal_fcn_add_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>fcnaddr</name> <init>= <expr><operator>-</operator><literal type="number">1LL</literal></expr></init></decl>, <decl><type ref="prev"/><name>addr</name> <init>= <expr><operator>-</operator><literal type="number">1LL</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>jump</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>fail</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalDiff</name> <modifier>*</modifier></type><name>diff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>diff</name> <operator>=</operator> <call><name>r_anal_diff_new</name> <argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: Cannot init RAnalDiff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="number">5</literal></expr>:</case> 

<expr_stmt><expr><name>fail</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case> 

<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">3</literal></expr>:</case> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>fcnaddr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcnaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_fcn_add_bb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>, <argument><expr><name>fail</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afb+: Cannot add basic block at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afb+ Cannot find function at 0x%"</literal> <name>PFMT64x</name> <literal type="string">" from 0x%08"</literal><name>PFMT64x</name><literal type="string">" -&gt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>fcnaddr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_diff_free</name> <argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_anal_nofunclist</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>minlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>code_size</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="string">"$SS"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>base_addr</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="string">"$S"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>chunk_size</name></decl>, <decl><type ref="prev"/><name>chunk_offset</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>bitmap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>counter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>minlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>minlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>code_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>code_size</name><operator>+</operator><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter2</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>base_addr</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name>base_addr</name><operator>+</operator><name>code_size</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>counter</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>counter</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>bitmap</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>+</operator><name>counter</name><operator>-</operator><name>base_addr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>bitmap</name><index>[<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base_addr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'F'</literal></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>chunk_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>code_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>chunk_size</name> <operator>&gt;=</operator> <name>minlen</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_FCN</name> <operator>|</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %6d %s\n"</literal></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %6d\n"</literal></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>chunk_offset</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>chunk_size</name><operator>+=</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>chunk_size</name> <operator>&gt;=</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_FCN</name> <operator>|</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %6d %s\n"</literal></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %6d\n"</literal></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>chunk_offset</name></expr></argument>, <argument><expr><name>chunk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_anal_fmap</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>show_color</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cols</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"hex.cols"</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>code_size</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="string">"$SS"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>base_addr</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="string">"$S"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>bitmap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>assigned</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>code_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>code_size</name><operator>+</operator><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter2</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>base_addr</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name>base_addr</name><operator>+</operator><name>code_size</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>counter</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>counter</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>bitmap</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>+</operator><name>counter</name><operator>-</operator><name>base_addr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>bitmap</name><index>[<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base_addr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'F'</literal></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><name>assigned</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cols</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>code_size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i</name> <operator>%</operator> <name>cols</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name>base_addr</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>assigned</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>show_color</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%c\x1b[0m"</literal></expr></argument>, <argument><expr><name>Color_GREEN</name></expr></argument>, <argument><expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n%d / %d (%.2lf%%) bytes assigned to a function\n"</literal></expr></argument>, <argument><expr><name>assigned</name></expr></argument>, <argument><expr><name>code_size</name></expr></argument>, <argument><expr><literal type="number">100.0</literal><operator>*</operator><operator>(</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>assigned</name><operator>)</operator> <operator>/</operator> <name>code_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>fcnNeedsPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"entry"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><operator>!</operator><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>getFunctionName</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnpfx</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>fcnNeedsPrefix</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>fcnpfx</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>fcnpfx</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcnpfx</name> <operator>=</operator> <literal type="string">"fcn"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fcnpfx</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.fcnprefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><literal type="string">"fcn"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__setFunctionName</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name>_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>_name</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>getFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>space</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_FUNCTIONS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_FUNCTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_size_from_entry</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_function_rename</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>on_fcn_rename</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>on_fcn_rename</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>afCc</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>totalCycles</name> <init>= <expr><call><name>r_anal_function_cost</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>totalCycles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afCc: Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_fcn_sig</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>json</name> <init>= <expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcn_name</name> <init>= <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFuncArg</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>j</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>resolve_fcn_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_type</name> <init>= <expr><call><name>r_type_func_ret</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>r_type_func_args_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"return"</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>fcn_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_func_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>arg</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>orig_c_type</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFcnVarsCache</name></type> <name>cache</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cache</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache.rvars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache.bvars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache.svars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><call><name>r_anal_fcn_format_sig</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__updateStats</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>statsMode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>statsMode</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>family</name> <init>= <expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>family</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_num_inc</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>family</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>statsMode</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_num_inc</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mnem</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>mnem</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_inc</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>mnem</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>__core_cmd_anal_fcn_stats</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>silentMode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>statsMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>silentMode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: afis[ft]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" afis enumerate unique opcodes in function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" afisa[fo] enumerate all the meta of all the functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" afisf enumerate unique opcode families in function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" afiso enumerate unique opcode types in function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" afist [query] list in table format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>

<expr_stmt><expr><name>statsMode</name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>__updateStats</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>statsMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>op_pos_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut16</name></type> <name>op_pos</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>op_pos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>__updateStats</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>op_pos</name></expr></argument>, <argument><expr><name>statsMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>silentMode</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_table_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeString</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeNumber</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nv</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_table_add_row_list</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdbkv_key</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>sdbkv_value</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%4d %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>db</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__core_cmd_anal_fcn_allstats</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>dbs</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>sdb_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>oseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isJson</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"*%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>__core_cmd_anal_fcn_stats</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">".addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>dbs</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>dbs</argument>, <argument>iter</argument>, <argument>db</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>sdbkv_key</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_add</name> <argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_table_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeString</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeNumber</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>key</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>dbs</argument>, <argument>iter</argument>, <argument>db</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>names</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><literal type="number">100</literal></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></for>

<macro><name>ls_foreach</name> <argument_list>(<argument>ls</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdbkv_key</name><argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>key</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>r_table_column_nth</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>nv</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>names</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid column name (%s) %c"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>fcnAddr</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">".addr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcnAddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then><expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></then><else>:<expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then><expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>fcnAddr</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cols</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_table_add_row_list</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>input</name><operator>)</operator></expr>?</condition><then><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><ternary><condition><expr><name>isJson</name></expr>?</condition><then> <expr><call><name>r_table_tojson</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oseek</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_afsj</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>a</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name>a</name></expr>?</condition><then> <expr><name>a</name></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_anal_function_get_json</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_anal_fcn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_timeout</name> <argument_list>(<argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.timeout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"f-$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_undefine</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_del_jmprefs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>

?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_anal_undefine</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_del_locs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>blocks</name> <init>= <expr><call><name>r_anal_get_blocks_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>table</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>elements</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_jmptbl</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>elements</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No function defined here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>show_args</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.funcarg"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>show_args</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_print_func_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_print_func_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afd [offset]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s + %d\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afd: Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr_end</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_end</name> <operator>&lt;</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid address ranges\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.to"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.limits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.from"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.to"</literal></expr></argument>, <argument><expr><name>addr_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.limits"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_function_resize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr_end</name> <operator>-</operator> <name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>,

<argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_function_resize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr_end</name> <operator>-</operator> <name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.from"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.to"</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.limits"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>c</name></expr>?</condition><then> <expr><name>c</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalDiff</name> <modifier>*</modifier></type><name>diff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name>R_ANAL_FCN_TYPE_FCN</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>diff</name> <operator>=</operator> <call><name>r_anal_diff_new</name> <argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: Cannot init RAnalDiff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_LOC</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_IMP</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_FCN</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_create_function</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot add function (duplicated)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_diff_free</name> <argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: afo[?sj] ([name|offset])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"address"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_get_functions_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"= 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>help_msg_afll</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"afil"</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No function found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>imports</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>imp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;imports</argument>, <argument>iter</argument>, <argument>imp</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>imp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>__core_cmd_anal_fcn_allstats</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><call><name>__core_cmd_anal_fcn_stats</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_fcn_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"is-pure: %s\n"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><call><name>r_anal_function_purity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpbbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>help_msg_afll</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"afll"</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_fcn_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><call><name>r_core_anal_fcn_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"o"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'!'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&amp;&amp;</operator> <name>data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"\"afs %s\""</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"type.%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sdb_exists</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"anal/types/func.%s.ret=%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"There's no function defined in here.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_afsj</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnstr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fcnstr_copy</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnname_aux</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>fcnstr_copy</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim_tail</name> <argument_list>(<argument><expr><name>fcnname_aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><call><name>r_str_lchr</name> <argument_list>(<argument><expr><name>fcnname_aux</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fcnname</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name>ls</name></expr>?</condition><then> <expr><name>ls</name></expr></then><else>: <expr><name>fcnname_aux</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcnname</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fcnname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>__setFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>fcnname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_str_to_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnstr_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_anal_function_get_signature</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No function defined at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_fcn_merge</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'M'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_fmap</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><call><name>var_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>type_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%i\n"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Cannot find function at 0x08%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_loops</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Cannot find function at 0x08%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>afCc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case><block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afc: Cannot find function here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argument</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name>argument</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_cc_exist</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>asmOs</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.os"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afc: Unknown calling convention '%s' for '%s'\n"</literal>

<literal type="string">"See afcl for available types\n"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>asmOs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <call><name>r_str_constpool_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>constpool</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argument</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name>argument</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/cc/default.cc=%s"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_set_reg_profile</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/cc/default.cc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Todo\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_fcn_sig</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/cc/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>cc_print</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dbpath</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_file_exists</name> <argument_list>(<argument><expr><name>dbpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sdb_new</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dbpath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_merge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_close</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dbpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>json_buf</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>json</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"cc.%s.ret"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">"\"ret\":\"%s\""</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isFirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_ANAL_CC_MAXARG</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"cc.%s.arg%d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>isFirst</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">",\"args\":[\"%s\""</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isFirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">",\"%s\""</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFirst</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"cc.%s.self"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">",\"self\":\"%s\""</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"cc.%s.error"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_cc</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">",\"error\":\"%s\""</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>json_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/cc/default.cc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/cc/cc.%s.arg%d"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim_nc</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>res</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"drr~%s 0x"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"arg[%d] %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'B'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afB: Cannot find function to set bits at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: afB [bits]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_fcn_del_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_bb_edge</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_fcn_bbget_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>folded</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>folded</name></name> <operator>=</operator> <operator>!</operator><name><name>bb</name><operator>-&gt;</operator><name>folded</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_fcn_list_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_fcn_list_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_fcn_list_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>?</condition><then> <expr><literal type="string">" $$"</literal></expr></then><else>: <expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<expr_stmt><expr><call><name>anal_fcn_add_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>color</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>color</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_op_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_colorize_bb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot analyze opcode at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><call><name>r_core_anal_fcn_autoname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><call><name>r_core_anal_fcn_autoname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_autoname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afn %s 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: afn newname [off] #set new name to given function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_base64_decode_dyn</name> <argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name> <operator>||</operator> <operator>!</operator><call><name>__setFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_afn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

case 'e': 

{

RAnalFunction *fcn;

ut64 off = core-&gt;offset;

char *p, *name = strdup ((input[2]&amp;&amp;input[3])? input + 3: "");

if ((p = strchr (name, ' '))) {

*p = 0;

off = r_num_math (core-&gt;num, p + 1);

}

fcn = r_anal_get_fcn_in (core-&gt;anal, off, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);

if (fcn) {

RAnalBlock *b;

RListIter *iter;

RAnalRef *r;

r_list_foreach (fcn-&gt;refs, iter, r) {

r_cons_printf ("0x%08" PFMT64x " -%c 0x%08" PFMT64x "\n", r-&gt;at, r-&gt;type, r-&gt;addr);

}

r_list_foreach (fcn-&gt;bbs, iter, b) {

int ok = 0;

if (b-&gt;type == R_ANAL_BB_TYPE_LAST) ok = 1;

if (b-&gt;type == R_ANAL_BB_TYPE_FOOT) ok = 1;

if (b-&gt;jump == UT64_MAX &amp;&amp; b-&gt;fail == UT64_MAX) ok = 1;

if (ok) {

r_cons_printf ("0x%08" PFMT64x " -r\n", b-&gt;addr);

}

}

} else eprintf ("Cannot find function at 0x%08" PFMT64x "\n", core-&gt;offset);

free (name);

}

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_ref_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"to"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%c 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" -&gt; 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"afx: Cannot find function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Wrong command. Look at af?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>folded</name></name> <operator>=</operator> <ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>?</condition><then> <expr><name>val</name></expr></then><else>: <expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>folded</name></name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>uaddr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>analyze_recursively</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.calls"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>analyze_recursively</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uaddr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>uaddr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>uaddr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>uaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__setFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>vars</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_recover_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>__add_vars_sdb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Unable to analyze function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>analyze_recursively</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>&amp;&amp;</operator> <name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>noncode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs1</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs1</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>noncode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <literal type="char">'C'</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_function_resize</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>addr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,

<argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"af: Cannot find function at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>vars</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_recover_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>__setFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"af: Cannot find function at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_propagate_noreturn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (core-&gt;anal-&gt;opt.vars) {

RListIter *iter;

RAnalFunction *fcni = NULL;

r_list_foreach (core-&gt;anal-&gt;fcns, iter, fcni) {

if (r_cons_is_breaked ()) {

break;

}

r_core_recover_vars (core, fcni, true);

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>flag_every_function</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<return>return <expr><name>false</name></expr>;</return>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__anal_reg_list</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_debug_ri</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>hack</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>use_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>use_colors</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ConsP</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConsP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(core-&gt;cons &amp;&amp; core-&gt;cons-&gt;context-&gt;pal.x)? core-&gt;cons-&gt;context-&gt;pal.x</cpp:value></cpp:define>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <call><name>ConsP</name> <argument_list>(<argument><expr><name>creg</name></expr></argument>)</argument_list></call> <operator>:</operator> <name>Color_BWHITE</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>bits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode2</name> <init>= <expr><name>mode</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bits</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"6502"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bits</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode2</name> <operator>=</operator> <ternary><condition><expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr> ?</condition><then> <expr><literal type="char">'J'</literal></expr> </then><else>: <expr><name>mode</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>mode2</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"avr"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bits</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode2</name> <operator>=</operator> <ternary><condition><expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr> ?</condition><then> <expr><literal type="char">'J'</literal></expr> </then><else>: <expr><name>mode</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>mode2</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pcbits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pcname</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pcname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>!=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pcbits</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pcbits</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>pcbits</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>mode2</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode2</name> <operator>==</operator> <literal type="char">'J'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>hack</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>cmd_anal_reg</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_debug_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>R_REG_TYPE_GPR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_64</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">64</literal></expr></then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>use_colors</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>use_color</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>use_colors</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConsP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(core-&gt;cons &amp;&amp; core-&gt;cons-&gt;context-&gt;pal.x)? core-&gt;cons-&gt;context-&gt;pal.x</cpp:value></cpp:define>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <call><name>ConsP</name> <argument_list>(<argument><expr><name>creg</name></expr></argument>)</argument_list></call>

<operator>:</operator> <name>Color_BWHITE</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>use_color</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>use_json</name> <init>= <expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;regs</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>use_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">','</literal></expr>:</case> 

<expr_stmt><expr><call><name>__tableRegList</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_zero</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"A%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pxr 32 @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_cmt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>reg_profile_cmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_arw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>r_reg_arena_set_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_arw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ara</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegArena</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_TYPE_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>regset</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;pool</argument>, <argument>iter</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %p %d %d %s %d\n"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>==</operator> <name><name>rs</name><operator>-&gt;</operator><name>arena</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"*"</literal></expr></then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>, <argument><expr><name>a</name></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_debug_rr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_debug_rr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_reg_get_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><name>R_REG_TYPE_GPR</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>string</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_reg_type_by_name</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>R_REG_TYPE_GPR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_reg_get_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="number">0LL</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_cond_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>r_reg_cond_from_string</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegFlags</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>o</name> <init>= <expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"unknown conditional or flag register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RRegFlags</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><call><name>r_reg_cond_retrieve</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"| s:%d z:%d c:%d o:%d p:%d\n"</literal></expr></argument>,

<argument><expr><name><name>rf</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>o</name></name></expr></argument>, <argument><expr><name><name>rf</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_COND_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s:%d "</literal></expr></argument>,

<argument><expr><call><name>r_reg_cond_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_COND_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s\n"</literal></expr></argument>,

<argument><expr><call><name>r_reg_cond_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_reg_cond_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">" #Register states commands"</literal></expr>,

<expr><literal type="string">"drs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List register stack"</literal></expr>,

<expr><literal type="string">"drs+"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Push register state"</literal></expr>,

<expr><literal type="string">"drs-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Pop register state"</literal></expr>,

<expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_reg_profile</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>r_reg_get_type</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops. try arn [PC|SP|BP|A0|A1|A2|A3|A4|R0|R1|ZF|SF|NF|OF]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_reg_arena_swap</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_isnumber</name> <argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st64</name></type> <name>sz</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>bits</name></expr> ?</condition><then> <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><ternary><condition><expr><name>bits</name></expr> ?</condition><then> <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strtok</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>q_regs</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>q_regs</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>q_regs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>q_regs</name></name> <operator>=</operator> <name>q_regs</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>__anal_reg_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>q_regs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>q_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>q_regs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'R'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>__anal_reg_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ostr</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>r_str_trim_nc</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>role</name> <init>= <expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>role</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*%d"</literal></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ar: Unknown register '%s'\n"</literal></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="char">','</literal></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <sizeof>sizeof <name>name</name></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>__anal_reg_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>showreg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_reg_type_by_name</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__anal_reg_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>initializeEsil</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exectrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.exectrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>noNULL</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.noNULL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.verbose"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>r_core_esil_cmd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>noNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_esil_step</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.step"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd_esil_step</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd_esil_step</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cmd_esil_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_esil_step_out</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.stepout"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd_esil_step_out</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd_esil_step_out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cmd_esil_step_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>my</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>my</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>exectrap</name></name> <operator>=</operator> <name>exectrap</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><call><name>r_bin_get_entries</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinAddr</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entries</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>RBinAddr</name> <operator>*</operator><operator>)</operator><call><name>r_list_pop</name> <argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>r_bin_get_info</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <ternary><condition><expr><name><name>info</name><operator>-&gt;</operator><name>has_va</name></name></expr>?</condition><then> <expr><name><name>entry</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>entry</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>addr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_esil_step</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>until_addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>until_expr</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>prev_addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>stepOver</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>return_tail</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ tail_return_value = x; goto tail_return; }</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>tail_return_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>code</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>breakoninvalid</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.breakoninvalid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>esiltimeout</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.timeout"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>startTime</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>esiltimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>startTime</name> <operator>=</operator> <call><name>r_sys_now</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>repeat</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] ESIL emulation interrupted at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>esiltimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>elapsedTime</name> <init>= <expr><call><name>r_sys_now</name> <argument_list>()</argument_list></call> <operator>-</operator> <name>startTime</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>elapsedTime</name> <operator>&gt;&gt;=</operator> <literal type="number">20</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>elapsedTime</name> <operator>&gt;=</operator> <name>esiltimeout</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] Timeout exceeded.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>initializeEsil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>esil</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>prev_addr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>exectrap</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_EXEC_ERR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] Trap, trying to execute on non-executable memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pincmd</name> <init>= <expr><call><name>r_anal_pin_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pincmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pincmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>pc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dataAlign</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_DATA_ALIGN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dataAlign</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>%</operator> <name>dataAlign</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_TRAP_UNALIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>breakoninvalid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] Stopped execution in an unaligned instruction (see e??esil.breakoninvalid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_io_read_at_mapped</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>esil</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_TRAP_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>breakoninvalid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] Stopped execution in an invalid instruction (see e??esil.breakoninvalid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stepOver</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_SWI</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CRET</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>until_addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.r2wars"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>vECX</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"ecx"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>prefix</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_PREFIX_REP</name> <operator>&amp;&amp;</operator> <name>vECX</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>esil</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="string">",ecx,?{,5,GOTO,}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>esil</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_trace_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>R_STR_ISNOTEMPTY</name> <argument_list>(<argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_post_loop</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_post_loop</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isNextFall</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CJMP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isNextFall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>delay</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNextFall</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>code2</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>naddr</name> <init>= <expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op2</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>naddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>naddr</name></expr></argument>, <argument><expr><name>code2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>code2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op2</name></expr></argument>, <argument><expr><name>naddr</name></expr></argument>, <argument><expr><name>code2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>code2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>op2</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CRET</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_EXEC_ERR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] Trap, trying to execute a branch in a delay slot\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op2</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid instruction at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>naddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tail_return_value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>follow</name> <init>= <expr><operator>(</operator><name>st64</name><operator>)</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>follow</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pc</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pc</name> <operator>&gt;</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>follow</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"sr PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_bp_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[ESIL] hit breakpoint at 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>until_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>until_addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>repeat</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>trap</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TRAP\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>until_expr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_condition</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ESIL BREAK!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>return_tail</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>repeat</name>;</goto>

</block_content>}</block></if></if_stmt>

<label><name>tail_return</name>:</label>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tail_return_value</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_esil_step_back</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>tail</name> <operator>=</operator> <call><name>r_list_tail</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>sessions</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalEsilSession</name> <modifier>*</modifier></type><name>before</name> <init>= <expr><operator>(</operator><name>RAnalEsilSession</name> <operator>*</operator><operator>)</operator> <name><name>tail</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>before</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any previous state here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Execute until 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_session_set</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Before 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_session_set</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_address_info</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addrstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addrstr</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>addrstr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_core_anal_address</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_PROGRAM</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_LIBRARY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"library"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_EXEC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"exec"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_READ</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_WRITE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"write"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_FLAG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_FUNC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_STACK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_HEAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_REG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"reg"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_ASCII</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ascii"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"sequence"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_PROGRAM</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"program\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_LIBRARY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"library\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_EXEC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"exec\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_READ</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"read\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_WRITE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"write\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_FLAG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_FUNC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"func\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_STACK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"stack\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_HEAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"heap\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_REG</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"reg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_ASCII</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ascii\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>R_ANAL_ADDR_TYPE_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"sequence\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_info</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_address_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usagae: aii [namespace] #see afii - imports\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>imports</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>imp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;imports</argument>, <argument>iter</argument>, <argument>imp</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>imp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_address_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>cmd_address_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initialize_stack</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.fillstack"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>mode</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>mode</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>bs</name> <init>= <expr><literal type="number">4096</literal> <operator>*</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>bs</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>left</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>bs</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wopD %"</literal><name>PFMT64u</name><literal type="string">" @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"woe 1 0xff 1 4 @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"woR %"</literal><name>PFMT64u</name><literal type="string">" @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case> 

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wow 00 @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_esil_mem</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>stack_map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curoff</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><literal type="number">0x100000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>size</name> <init>= <expr><literal type="number">0xf0000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>uri</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>nomalloc</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>noNULL</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.noNULL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>verbose</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.verbose"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>noNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <name>esil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>verbose</name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>my</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>my</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aeim [addr] [size] [name] - initialize ESIL VM stack\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Default: 0x100000 0xf0000\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See ae? for more help\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fi</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"aeim.stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>fi</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_esil_mem</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>initialize_stack</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name>sdb_get</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"aeim.fd"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>fd</name> <init>= <expr><call><name>sdb_atoi</name> <argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_fd_close</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.addr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>align</name> <init>= <expr><literal type="number">0x10000000</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_io_map_next_available</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>patt</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strncpy</name> <argument_list>(<argument><expr><name>nomalloc</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0xf0000</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mem.%s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mem.0x%"</literal> <name>PFMT64x</name> <literal type="string">"_0x%x"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mem.0x%"</literal> <name>PFMT64x</name> <literal type="string">"_0x%x"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"mem.0x%"</literal> <name>PFMT64x</name> <literal type="string">"_0x%x"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_io_fd_close</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot deinitialize %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_flag_unset_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_unset_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"aeim.stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"aeim.fd"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"malloc://%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name> <operator>=</operator> <call><name>r_io_fd_open</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>R_PERM_RW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>stack_map</name> <operator>=</operator> <call><name>r_io_map_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name></expr></argument>, <argument><expr><name>R_PERM_RW</name></expr></argument>, <argument><expr><literal type="number">0LL</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_fd_close</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create map for tha stack, fd %d got closed again\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_map_set_name</name> <argument_list>(<argument><expr><name>stack_map</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>val</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sdb_itoa</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_fd</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"aeim.fd"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>patt</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>patt</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>patt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wopD %d @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"woe 0 255 1 @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!%d"</literal></expr></argument>,<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"woe 0 0xffff 1 4 @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!%d"</literal></expr></argument>,<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <operator>(</operator><name>size</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <operator>(</operator><name>size</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_reg_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>curoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>initialize_stack</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>curoff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static ut64 opc = UT64_MAX;

static ut8 *regstate = NULL;

static void esil_init (RCore *core) {

const char *pc = r_reg_get_name (core-&gt;anal-&gt;reg, R_REG_NAME_PC);

int noNULL = r_config_get_i (core-&gt;config, "esil.noNULL");

opc = r_reg_getv (core-&gt;anal-&gt;reg, pc);

if (!opc || opc==UT64_MAX) {

opc = core-&gt;offset;

}

if (!core-&gt;anal-&gt;esil) {

int iotrap = r_config_get_i (core-&gt;config, "esil.iotrap");

ut64 stackSize = r_config_get_i (core-&gt;config, "esil.stack.size");

unsigned int addrsize = r_config_get_i (core-&gt;config, "esil.addr.size");

if (!(core-&gt;anal-&gt;esil = r_anal_esil_new (stackSize, iotrap, addrsize))) {

R_FREE (regstate);

return;

}

r_anal_esil_setup (core-&gt;anal-&gt;esil, core-&gt;anal, 0, 0, noNULL);

}

free (regstate);

regstate = r_reg_arena_peek (core-&gt;anal-&gt;reg);

}

static void esil_fini(RCore *core) {

const char *pc = r_reg_get_name (core-&gt;anal-&gt;reg, R_REG_NAME_PC);

r_reg_arena_poke (core-&gt;anal-&gt;reg, regstate);

r_reg_setv (core-&gt;anal-&gt;reg, pc, opc);

R_FREE (regstate);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>regread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>regwrite</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>regvalues</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>inputregs</name></decl>;</decl_stmt>

}</block></struct></type> <name>AeaStats</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>aea_stats_init</name> <parameter_list>(<parameter><decl><type><name>AeaStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>regread</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>regwrite</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>regvalues</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>inputregs</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>aea_stats_fini</name> <parameter_list>(<parameter><decl><type><name>AeaStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regwrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>inputregs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>contains</name><parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>oldregread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>mymemxsr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>mymemxsw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_NEW_DUP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy((void*)malloc(sizeof(x)), &amp;(x), sizeof(x))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

}</block></struct></type> <name>AeaMemItem</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mymemwrite</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AeaMemItem</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>mymemxsw</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr><name>AeaMemItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mymemread</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AeaMemItem</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>mymemxsr</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr><name>AeaMemItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>myregwrite</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>AeaStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oldregread</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>oldregread</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>R_FREE</name> <argument_list>(<argument>oldregread</argument>)</argument_list></macro>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regwrite</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regwrite</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64d</name></expr></argument>, <argument><expr><operator>*</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regvalues</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regvalues</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>myregread</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>AeaStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>inputregs</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regwrite</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>inputregs</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regread</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>regread</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showregs</name> <parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>reg</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showmem</name> <parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>AeaMemItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>item</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showregs_json</name> <parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>reg</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showmem_json</name> <parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AeaMemItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>item</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>cmd_aea</name><parameter_list>(<parameter><decl><type><name>RCore</name><modifier>*</modifier></type> <name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ptr</name></decl>, <decl><type ref="prev"/><name>ops</name></decl>, <decl><type ref="prev"/><name>ops_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>buf_sz</name></decl>, <decl><type ref="prev"/><name>maxopsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AeaStats</name></type> <name>stats</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name><modifier>*</modifier></type> <name>regnow</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maxopsize</name> <operator>=</operator> <call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MAX_OP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>maxopsize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>maxopsize</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf_sz</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ops_end</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ops_end</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ops_end</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf_sz</name> <operator>=</operator> <name>ops_end</name> <operator>*</operator> <name>maxopsize</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buf_sz</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf_sz</name> <operator>=</operator> <name>maxopsize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr_end</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>buf_sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>buf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>buf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>aea_stats_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stats1</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>noNULL</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.noNULL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats1</name></expr></argument>, <argument><expr><name>noNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasNext</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x&amp;1) ? (addr&lt;addr_end) : (ops&lt;ops_end)</cpp:value></cpp:define>

<expr_stmt><expr><name>mymemxsr</name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mymemxsw</name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <operator>&amp;</operator><name>stats</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_write</name></name> <operator>=</operator> <name>myregwrite</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name> <operator>=</operator> <name>myregread</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_write</name></name> <operator>=</operator> <name>mymemwrite</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name> <operator>=</operator> <name>mymemread</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>nowrite</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ops</name> <operator>=</operator> <name>ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ptr</name> <operator>&lt;</operator> <name>buf_sz</name> <operator>&amp;&amp;</operator> <call><name>hasNext</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ops</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>ptr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>ptr</name></expr></argument>, <argument><expr><name>buf_sz</name> <operator>-</operator> <name>ptr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>esilstr</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>aop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid 0x%08"</literal><name>PFMT64x</name><literal type="string">" instruction %02x %02x\n"</literal></expr></argument>,

<argument><expr><name>addr</name> <operator>+</operator> <name>ptr</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>ptr</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.r2wars"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>prefix</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_PREFIX_REP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>tmp</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>esilstr</name></expr></argument>, <argument><expr><literal type="string">",ecx,?{,5,GOTO,}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>nowrite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_write</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regnow</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>stats.regs</argument>, <argument>iter</argument>, <argument>reg</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regwrite</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AeaMemItem</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f-mem.*\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>mymemxsr</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f mem.read.%d 0x%08x @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>mymemxsw</argument>, <argument>iter</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f mem.write.%d 0x%08x @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regwrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"A"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regs</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>inputregs</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"R"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regread</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"W"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regwrite</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regvalues</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"V"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regvalues</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"N"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs_json</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"@R"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showmem_json</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"@W"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showmem_json</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>inputregs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" I: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>inputregs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" A: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regread</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" R: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regwrite</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" W: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regwrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regvalues</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" V: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>regvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" N: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showregs</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"@R:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showmem</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"@W:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showmem</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>mymemxsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>mymemxsw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mymemxsr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mymemxsw</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>aea_stats_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>regnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_aespc</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>until_addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl> , <decl><type ref="prev"/><name>bsize</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: cmd_espc: creating new esil instance\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <name>esil</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d byte(s)\n"</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>ut64</name></type> <name>cursp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>oldoff</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>flags</name> <init>= <expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name> <operator>|</operator> <name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>off</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>bsize</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Chomp\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>until_addr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsize</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed analysis at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>aop</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>aop</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>aop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>-</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inc</name> <operator>=</operator> <name>minopcode</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>, <argument><expr><name>cursp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_handler_no_name</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;no name&gt;"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_aeli_iter</name><parameter_list>(<parameter><decl><type><name>dictkv</name><modifier>*</modifier></type> <name>kv</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsilInterrupt</name><modifier>*</modifier></type> <name>interrupt</name> <init>= <expr><name><name>kv</name><operator>-&gt;</operator><name>u</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%3x: %s\n"</literal></expr></argument>, <argument><expr><name><name>kv</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>interrupt</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>interrupt</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>_handler_no_name</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_anal_aefa</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>, <decl><type ref="prev"/><name>from</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name> <operator>||</operator> <name>from</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aefa [from] #if no from address is given, uses fcn.addr\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Emulate from 0x%08"</literal><name>PFMT64x</name><literal type="string">" to 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Resolve call args for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr> ;</condition> <incr><expr><name>at</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aepc 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeso"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="string">"$l"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>delta</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"arA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

const char *fcn_type = r_type_func_ret (core-&gt;anal-&gt;sdb_types, fcn-&gt;name);

const char *key = resolve_fcn_name (core-&gt;anal, fcn-&gt;name);

RList *list = r_core_get_func_args (core, key);

if (!r_list_empty (list)) {

eprintf ("HAS signature\n");

}

int i, nargs = 3; 

if (nargs &gt; 0) {

int i;

eprintf ("NARGS %d (%s)\n", nargs, key);

for (i = 0; i &lt; nargs; i++) {

ut64 v = r_debug_arg_get (core-&gt;dbg, R_ANAL_CC_TYPE_STDCALL, i);

eprintf ("arg: 0x%08"PFMT64x"\n", v);

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__core_anal_appcall</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>args</argument>, <argument>iter</argument>, <argument>arg</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"A%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>ut64</name></type> <name>sp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aesu 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"SP"</literal></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__anal_esil_function</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>,

<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_FCN</name> <operator>|</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>bbs</name> <init>= <expr><name>end</name> <operator>-</operator> <name>pc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bbs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>bbs</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xfffff</literal> <operator>||</operator> <name>pc</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid block size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bbs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>opskip</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>pc</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>end</name> <operator>-</operator> <name>pc</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>pc</name> <operator>-</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_HINT</name> <operator>|</operator> <name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>opskip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>

<expr_stmt><expr><name>opskip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>opskip</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_set_value_by_role</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_dumpstack</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pc</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>pc</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_esil</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>adr</name></decl> ;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>off</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>romem</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stats</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stats"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>noNULL</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.noNULL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>until_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>until_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ar PC=%s"</literal></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_pin_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_pin_unset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_pin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"trap: %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"trap-code: %d\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"esil vm not initialized. run `aei`\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>noNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_dumpstack</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ae?~aes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name>pc</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>pc</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_esil_step_back</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannnot step back\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'B'</literal></expr>:</case> 

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>n2</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>nth</name> <init>= <expr><ternary><condition><expr><name>n2</name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cmd_aespc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aesB [until-addr] [nth-opcodes] @ [from-addr]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> 

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_endswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ae?~aesu"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>step_until_optype</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ae?~aesu"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>until_expr</name> <operator>||</operator> <name>until_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>,

<argument><expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aesou [addr] #step over until given address\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n1</name> <operator>=</operator> <ternary><condition><expr><name>n</name></expr> ?</condition><then> <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>n</name> <operator>||</operator> <operator>!</operator><name>n1</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>n1</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"aesp [offset] [num]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>adr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>n1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_aespc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>adr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_aespc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aeC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>__core_anal_appcall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_SWI</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"syscall at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_TRAP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"trap at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>||</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_UCALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"call at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>||</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>until_addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>until_expr</name> <operator>=</operator> <literal type="string">"0"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>until_addr</name></expr></argument>, <argument><expr><name>until_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_esil_mem</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ar PC=$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_esil_mem</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>&amp;&amp;</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ar PC=$$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>esil</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>noNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.verbose"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>my</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>my</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.esil.intr"</literal></expr></argument>, <argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>my</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><name>input</name> <operator>=</operator> <literal type="string">"123*"</literal></expr>;</expr_stmt>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"esil.stats is empty. Run 'aei'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_load_interrupts_from_lib</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to load interrupts from '%s'."</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>interrupts</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dict_foreach</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>interrupts</name></name></expr></argument>, <argument><expr><name>_aeli_iter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>interrupts</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsilInterrupt</name><modifier>*</modifier></type> <name>interrupt</name> <init>= <expr><call><name>dict_getu</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>interrupts</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_esil_interrupt_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>interrupt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oprompt</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>, <argument><expr><literal type="string">"pi 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".aeg*;aggv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>, <argument><expr><name>oprompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>oprompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".aeg*;agg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_esil_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>aop</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>aop</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name> <init>= <expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>aop</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>esilstr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_esil_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aeg[iv*]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aeg analyze current instruction as an esil graph\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aeg* analyze current instruction as an esil graph\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aegv and launch the visual interactive mode (.aeg*;aggv == aegv)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aesp `ab~addr[1]` `ab~ninstr[1]`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_aefa</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>__anal_esil_function</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt> <break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_to_reil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>romem</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_dumpstack</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_esil_session_list</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_esil_session_add</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown command. Use `aetr`.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">3</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">5</literal><operator>)</operator></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pc</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>newPC</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name>newPC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>bool</name></type> <name>json</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><ternary><condition><expr><name>json</name></expr>?</condition><then> <expr><literal type="number">3</literal></expr></then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><name>a</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>a</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>r_anal_get_blocks_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><ternary><condition><expr><name>json</name></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cmd_aea</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="string">"PC"</literal></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>bufsz</name></decl>;</decl_stmt>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hex</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hex</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bufsz</name> <operator>=</operator> <call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>hex</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>hex</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name><operator>&gt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>aop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str2</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_detail_ae</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ae</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_bytes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tbs</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>tbs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>core_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tbs</name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_opcode</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>tbs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<case>case <expr><literal type="char">'r'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>*=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>obs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>core_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>obs</name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aom[ljd] [arg] .. list mnemonics for asm.arch\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">". = current, l = list, d = describe, j=json)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal><operator>)</operator></expr>

?</condition><then><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ops</name> <init>= <expr><call><name>r_asm_mnemonics</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ops</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>ops</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>r_asm_describe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>desc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pad</name> <init>= <expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="number">16</literal> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s%s\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>r_asm_mnemonics_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>

?</condition><then><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ops</name> <init>= <expr><call><name>r_asm_mnemonics</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ops</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ao~mnemonic[1]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hooks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalCycleHook</name> <modifier>*</modifier></type><name>hook</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>instr_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ccl</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fun</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.functions"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>li</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.xrefs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.functions"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.xrefs"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hooks</name> <operator>=</operator> <call><name>r_core_anal_cycles</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ccl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hooks</argument>, <argument>iter</argument>, <argument>hook</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>instr_tmp</name> <operator>=</operator> <call><name>r_core_disassemble_instr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>hook</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"After %4i cycles:\t%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ccl</name> <operator>-</operator> <name><name>hook</name><operator>-&gt;</operator><name>cycles</name></name><operator>)</operator></expr></argument>, <argument><expr><name>instr_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>instr_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.functions"</literal></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.xrefs"</literal></expr></argument>, <argument><expr><name>xr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>pair</name></name></expr></argument>, <argument><expr><name>listOpDescriptions</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cur</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>core_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name> <operator>+</operator> <name>cur</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_asm_describe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown mnemonic\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Use: aod[?a] ([opcode]) describe current, [given] or all mnemonics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_hint_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>tbs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>l</name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>l</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>core_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ao</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_jumps</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af @@= `ax~ref.code.jmp[1]`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_aftertraps</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bufi</name></decl>, <decl><type ref="prev"/><name>minop</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>addr_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0xffffff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Too big\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><call><name>r_bin_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bf</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>bf</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Opps something went wrong aac\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>map</name> <operator>&amp;&amp;</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>!=</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name> <operator>&amp;&amp;</operator> <name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>bf</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops invalid range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr_end</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bufi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>trapcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nopcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>addr</name> <operator>&lt;</operator> <name>addr_end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bufi</name> <operator>&gt;</operator> <literal type="number">4000</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bufi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bufi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>bufi</name></expr></argument>, <argument><expr><literal type="number">4096</literal> <operator>-</operator> <name>bufi</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>minop</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_TRAP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>trapcount</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_NOP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nopcount</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>nopcount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"af @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nopcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>trapcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"af @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>trapcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>minop</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>op</name><operator>.</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>bufi</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>op</name><operator>.</operator><name>size</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_blocks</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl> , <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name><modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>ctrl_c</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>ctrl_c</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot determine search boundaries\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>to</name> <operator>-</operator> <name>from</name> <operator>&gt;</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Skipping huge range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"abb 0x%08"</literal><name>PFMT64x</name><literal type="string">" @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><operator>(</operator><name>to</name> <operator>-</operator> <name>from</name><operator>)</operator></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>st64</name></type> <name>sz</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"abb 0x%08"</literal><name>PFMT64x</name><literal type="string">" @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<label><name>ctrl_c</name>:</label>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_anal_calls</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr_end</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>printCommands</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>importsOnly</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>addrbytes</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>addrbytes</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bsz</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bufi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bufi_max</name> <init>= <expr><name>bsz</name> <operator>-</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_end</name> <operator>-</operator> <name>addr</name> <operator>&gt;</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>block0</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>block1</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <operator>!</operator><name>block0</name> <operator>||</operator> <operator>!</operator><name>block1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: cannot allocate buf or block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>block1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minop</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>minop</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>minop</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>setBits</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>addr</name> <operator>&lt;</operator> <name>addr_end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bufi</name> <operator>&gt;</operator> <name>bufi_max</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bufi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bufi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>block0</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>block1</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>bsz</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>setBits</name> <operator>=</operator> <name><name>hint</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>setBits</name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>, <argument><expr><name>setBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>bufi</name></expr></argument>, <argument><expr><name>bsz</name> <operator>-</operator> <name>bufi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>minop</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>isValidCall</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>importsOnly</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name> <operator>||</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"imp."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isValidCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RBinReloc</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>r_core_getreloc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>import</name></name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>symbol</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isValidCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isValidCall</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isValidCall</name> <operator>=</operator> <call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x00\x00\x00\x00"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isValidCall</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JAYRO_03</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>anal_is_bad_call</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_ROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><name>printCommands</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ax 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"af @ 0x%08"</literal> <name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>minop</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>minop</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>bufi</name> <operator>+=</operator> <name>addrbytes</name> <operator>*</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_calls</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>printCommands</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>importsOnly</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ranges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0xffffff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Too big\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>binfile</name> <init>= <expr><call><name>r_bin_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>binfile</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RIOMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ranges</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ranges</name> <operator>=</operator> <call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>binfile</name> <operator>||</operator> <operator>(</operator><name>ranges</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ranges</name> <operator>=</operator> <call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ranges</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ranges</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>printCommands</name></expr></argument>, <argument><expr><name>importsOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>binfile</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>ranges</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>printCommands</name></expr></argument>, <argument><expr><name>importsOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_sdbk</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>

?</condition><then> <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|ERROR| Usage: ask [query]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_syscall</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSyscallItem</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RNum</name> <modifier>*</modifier></type><name>num</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">".equ SYS_%s %s\n"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall number\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_syscall_get_num</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">".equ SYS_%s %s\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_syscall_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>si</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">".equ SYS_%s %s\n"</literal></expr></argument>,

<argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#define SYS_%s %s\n"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall number\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_syscall_get_num</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#define SYS_%s %s\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_syscall_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>si</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#define SYS_%s %d\n"</literal></expr></argument>,

<argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_sdbk</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_fcnsign</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_sdbk</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall number\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_syscall_get_num</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown syscall name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_syscall_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>si</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s = 0x%02x.%s\n"</literal></expr></argument>,

<argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>swi</name></name></expr></argument>, <argument><expr><call><name>syscallNumber</name> <argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_syscall_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>si</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"swi"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>swi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"num"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_syscall_do</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>num</name> <init>= <expr><call><name>r_syscall_get_num</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>cmd_syscall_do</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>anal_axg</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>PJ</name><modifier>*</modifier></type> <name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>arg</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>pre</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_r2</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_GRAPHBODY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>spaces</name> <init>= <expr><operator>(</operator><name>level</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>spaces</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>pre</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>spaces</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>pre</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>pre</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>pre</name> <operator>+</operator> <name>spaces</name></expr></argument>, <argument><expr><literal type="string">"- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>open_object</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_r2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>taddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>taddr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"fcn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcn_addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name><literal type="string">" fcn 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>,

<argument><expr><name>pre</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_r2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>taddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>taddr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pre</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_r2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>taddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>taddr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"fcn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcn_addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>taddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>taddr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"fcn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcn_addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name><literal type="string">" fcn 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sdb_add</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>anal_axg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_r2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%08"</literal><name>PFMT64x</name><literal type="string">" ???\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>taddr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>taddr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><literal type="string">"???"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name><literal type="string">" ???\n"</literal></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sdb_add</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>anal_axg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>open_object</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>open_object</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>open_object</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_ucall_ref</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type> <name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" ; %s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" ; 0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_buf_asm</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>color</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>has_color</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>R_PRINT_FLAGS_COLOR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_asm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>asm_varsub</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.var.sub"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>pseudo</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.pseudo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.relsub"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>localvar_only</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.var.subonly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name><operator>-&gt;</operator><name>relsub_addr</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ba_len</name> <init>= <expr><call><name>r_strbuf_length</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">128</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ba</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>ba_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>ba</name></expr></argument>, <argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>asm_varsub</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_parse_varsub</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>asmop</name><operator>.</operator><name>size</name></name></expr></argument>,

<argument><expr><name>ba</name></expr></argument>, <argument><expr><name>ba</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>,

<argument><expr><name>ba</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_op_set_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>ba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>color</name> <operator>&amp;&amp;</operator> <name>has_color</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf_asm</name> <operator>=</operator> <call><name>r_print_colorize_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>buf_asm</name> <operator>=</operator> <call><name>r_str_new</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>buf_asm</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var_ref_list</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sdb_fmt ("var.0x%"PFMT64x".%d.%d.%s",a, 1, d, (t == 'R')?"reads":"writes");</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>cmd_anal_refs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp_inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>cp_inp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_xrefs_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>==</operator> <name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_xref_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_xref_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cp_inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>anal_axg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>R_CORE_ANAL_GRAPHBODY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>anal_axg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>R_CORE_ANAL_JSON</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>anal_axg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_xrefs_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tInput</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_replace_ch</name> <argument_list>(<argument><expr><name>tInput</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fInput</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_replace_ch</name> <argument_list>(<argument><expr><name>fInput</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>space</name></expr> ?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>space</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>tmp</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rvar</name> <init>= <expr><call><name>var_ref_list</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wvar</name> <init>= <expr><call><name>var_ref_list</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><literal type="char">'W'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res1</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>wvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>res</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>res</name><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>res1</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>res1</name><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>res1</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>list</name></expr></argument> , <argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>get_buf_asm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s 0x%"</literal><name>PFMT64x</name><literal type="string">" [DATA] %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"(nofunc)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>space</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>space</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>get_buf_asm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opcode"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcn_addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcn_name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></then><else>: <expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>fi</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_ref</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s+%d"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>name_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fi</name><operator>-&gt;</operator><name>realname</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escaped</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>escaped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>refname</name> <init>= <expr><call><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>getNameDelta</name></name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>refname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_replace_ch</name> <argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"refname"</literal></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal></expr>)</condition> <block>{<block_content> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"fd 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim_tail</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%"</literal> <name>PFMT64x</name> <literal type="string">" \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn 0x%"</literal> <name>PFMT64x</name> <literal type="string">" \"%s\"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">"$$"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age 0x%"</literal> <name>PFMT64x</name> <literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"CCa 0x%"</literal> <name>PFMT64x</name> <literal type="string">" \"XREF type %d at 0x%"</literal> <name>PFMT64x</name><literal type="string">"%s\n"</literal></expr></argument>,

<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr>?</condition><then> <expr><literal type="string">","</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_asm</name> <init>= <expr><call><name>get_buf_asm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>r_meta_get_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_fcn</name> <init>= <expr><ternary><condition><expr><name>comment</name></expr>

?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s; %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"(nofunc)"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strtok</name> <argument_list>(<argument><expr><name>comment</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"(nofunc)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s 0x%"</literal> <name>PFMT64x</name> <literal type="string">" [%s] %s\n"</literal></expr></argument>,

<argument><expr><name>buf_fcn</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf_asm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf_asm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf_fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type> <name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>f</name></expr> ?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name><argument_list>(<argument><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"at"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>,

<argument><expr><call><name>r_anal_xrefs_type_tostring</name><argument_list>(<argument><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>list_</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>space</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>space</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type> <name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>list</name> <operator>=</operator> <name>list_</name> <operator>=</operator> <call><name>r_anal_xrefs_get_from</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_anal_refs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"to"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opcode"</literal></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"CCa 0x%"</literal> <name>PFMT64x</name> <literal type="string">" \"XREF from 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr>?</condition><then> <expr><literal type="string">","</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content> 

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_color</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>R_PRINT_FLAGS_COLOR</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>desc_to_free</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_color</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <name>desc_to_free</name> <operator>=</operator> <call><name>r_print_colorize_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%c 0x%"</literal> <name>PFMT64x</name> <literal type="string">" %s"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr> ?</condition><then> <expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_UCALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_ucall_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>desc_to_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"[]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<expr_stmt><expr><call><name>find_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRefType</name></type> <name>reftype</name> <init>= <expr><call><name>r_anal_xrefs_type</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_hint</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_anal_hint_print</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_hint_print</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arch</name> <init>= <expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_arch</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>arch</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>arch</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>arch</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_arch</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>r_anal_optype_from_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aho [type] #can be mov, jmp, call, ...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_bits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing argument\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ahi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_nword</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_hint_set_immbase</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>base</name> <init>=

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">32</literal></expr> </then><else>: 

<expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'S'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">80</literal></expr> </then><else>: 

<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_immbase</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|ERROR| Usage: ahi [base]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_high</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_high</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_high</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_jump</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_jump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_fail</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_fail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_stackframe</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_stackframe</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ahs 16\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_syntax</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_syntax</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ahS att\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ahd popall\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_esil</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_esil</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ahe r0,pc,=\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

case 'e': 

if (input[1] == ' ') {

r_anal_hint_set_opcode (core-&gt;anal, core-&gt;offset, atoi (input + 1));

} else if (input[1] == '-') {

r_anal_hint_unset_opcode (core-&gt;anal, core-&gt;offset);

}

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_pointer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_hint_unset_pointer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_ret</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_hint_unset_ret</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_anal_hint_print</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_hint_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_val</name> <argument_list>(

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_unset_val</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_clear</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>a0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_hint_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_clear</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt> <break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>off</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>toff</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>toff</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>typeoffs</name> <init>= <expr><call><name>r_type_get_by_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>toff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ty</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>typeoffs</argument>, <argument>iter</argument>, <argument>ty</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>ty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>typeoffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>off</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>idx</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offimm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"address is unvalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>code</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_VAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>imm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offimm</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>imm</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>delta</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offimm</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>offimm</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>dst</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>imm</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offimm</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>imm</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>delta</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offimm</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offimm</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>off</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offimm</name> <operator>+=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>otypes</name> <init>= <expr><call><name>r_type_get_by_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>offimm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>otype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>otypes</argument>, <argument>iter</argument>, <argument>otype</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>otype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_type_link_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_set_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>otype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>otype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"wrong type for opcode offset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>otypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_node_gml</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" node [\n"</literal>

<literal type="string">" id %d\n"</literal>

<literal type="string">" label \"%s\"\n"</literal>

<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_edge_gml</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>

<literal type="string">" source %d\n"</literal>

<literal type="string">" target %d\n"</literal>

<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_node_dot</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>label</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>label</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"%s\" [URL=\"%s\", color=\"lightgray\", label=\"%s\"]\n"</literal></expr></argument>,

<argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"%s\" [URL=\"%s\", color=\"lightgray\", label=\"%s\\n%s\"]\n"</literal></expr></argument>,

<argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_node</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>encbody</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>body</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>encbody</name> <operator>=</operator> <call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"agn \"%s\" base64:%s\n"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>encbody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>encbody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getViewerPath</name><parameter_list>()</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>viewers</name><index>[]</index></name> <init>= <expr><block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>

<expr><literal type="string">"explorer"</literal></expr>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr><literal type="string">"open"</literal></expr>,

<expr><literal type="string">"geeqie"</literal></expr>,

<expr><literal type="string">"gqview"</literal></expr>,

<expr><literal type="string">"eog"</literal></expr>,

<expr><literal type="string">"xdg-open"</literal></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>viewers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewerPath</name> <init>= <expr><call><name>r_file_path</name> <argument_list>(<argument><expr><name><name>viewers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>viewerPath</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>viewerPath</name></expr></argument>, <argument><expr><name><name>viewers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>viewerPath</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>viewerPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>graph_cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>r2_cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_path</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dot</name> <init>= <expr><literal type="string">"dot"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.format"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dotPath</name> <init>= <expr><call><name>r_file_path</name> <argument_list>(<argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>dotPath</name></expr></argument>, <argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dotPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dot</name> <operator>=</operator> <literal type="string">"xdot"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dotPath</name> <operator>=</operator> <call><name>r_file_path</name> <argument_list>(<argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>dotPath</name></expr></argument>, <argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dotPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_str_new</name> <argument_list>(<argument><expr><literal type="string">"agf"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>save_path</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>save_path</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &gt; a.dot;!%s -T%s -o%s a.dot;"</literal></expr></argument>,

<argument><expr><name>r2_cmd</name></expr></argument>, <argument><expr><name>dot</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>, <argument><expr><name>save_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewer</name> <init>= <expr><call><name>getViewerPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>viewer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s &gt; a.dot;!%s -T%s -oa.%s a.dot;!%s a.%s"</literal></expr></argument>,

<argument><expr><name>r2_cmd</name></expr></argument>, <argument><expr><name>dot</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>, <argument><expr><name>viewer</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>viewer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find a valid picture viewer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dotPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cmd</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_edge_dot</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"%s\" -&gt; \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_edge</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age \"%s\" \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_agraph_node</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newbody</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_args</name></decl>, <decl><type ref="prev"/><name>B_LEN</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>color</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>r_str_argv</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n_args</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>n_args</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Wrong arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>, <argument><expr><name>B_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newbody</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_base64_decode_dyn</name> <argument_list>(<argument><expr><name>body</name> <operator>+</operator> <name>B_LEN</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newbody</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>body</name> <operator>=</operator> <name>newbody</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>color</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_agraph_add_node_with_color</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_args</name></decl>;</decl_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>r_str_argv</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Wrong arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_agraph_del_node</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_agn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_agraph_edge</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>u</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_args</name></decl>;</decl_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>r_str_argv</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Wrong arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>u</name> <operator>||</operator> <operator>!</operator><name>v</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>u</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Node %s not found!\n"</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Node %s not found!\n"</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_add_edge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_del_edge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_agraph_print</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_utf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_utf</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><name>use_utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>linemode</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.linemode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_set_title</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>,

<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.title"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_print</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case><block>{<block_content> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>r_agraph_get_sdb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>ran</name> <init>= <expr><call><name>r_agraph_get_first_node</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ran</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>oseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_agraph_set_title</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.title"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>ran</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>layout</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ov</name> <init>= <expr><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>update_seek</name> <init>= <expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_show_cursor</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_enable_mouse</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>update_seek</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oseek</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This graph contains no nodes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>font</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.font"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"digraph code {\nrankdir=LR;\noutputorder=edgesfirst\ngraph [bgcolor=azure];\n"</literal>

<literal type="string">"edge [arrowhead=normal, color=\"#3030c0\" style=bold weight=2];\n"</literal>

<literal type="string">"node [fillcolor=white, style=filled shape=box "</literal>

<literal type="string">"fontname=\"%s\" fontsize=\"8\"];\n"</literal></expr></argument>, <argument><expr><name>font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_foreach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_node_dot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_foreach_edge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_edge_dot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_agraph_foreach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_foreach_edge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_edge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'J'</literal></expr>:</case>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_print_json</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"graph\n[\n"</literal> <literal type="string">"hierarchic 1\n"</literal> <literal type="string">"label \"\"\n"</literal> <literal type="string">"directed 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_foreach</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_node_gml</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_foreach_edge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>agraph_print_edge_gml</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case><block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.web"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"=H /graph/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>graph_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aggd"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Saving to file '%s'...\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: see ag?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_graph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>show_node_titles</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.ntitles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_enable_highlight</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case><block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\rRendering graph..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_ROOT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_enable_mouse</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_show_cursor</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_visual_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>R_CORE_ANAL_GRAPHLINES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>R_CORE_ANAL_GRAPHBODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_CORE_ANAL_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'J'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_graph_offset</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.offset"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><name>o_graph_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>R_CORE_ANAL_JSON</name> <operator>|</operator> <name>R_CORE_ANAL_JSON_FORMAT_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'g'</literal></expr>:</case><block>{<block_content> 

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_print_bb_gml</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'k'</literal></expr>:</case><block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agf* @ %"</literal><name>PFMT64u</name><literal type="string">"; aggk"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_print_bb_custom</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.web"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"=H /graph/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdargs</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"agfd @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>graph_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmdargs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Saving to file %s ...\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmdargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: see ag?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_agraph_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_agraph_node</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_agraph_edge</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_agraph_print</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agC*;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'J'</literal></expr>:</case>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_GML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_CMD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: see ag?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_coderefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agr* @ %"</literal><name>PFMT64u</name><literal type="string">";"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.from"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>it</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>==</operator> <name>UT64_MAX</name><operator>)</operator> <operator>||</operator> <call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_coderefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agR*;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_codexrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agx* @ %"</literal><name>PFMT64u</name><literal type="string">";"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_anal_importxrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agi*;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agc* @ %"</literal><name>PFMT64u</name><literal type="string">"; agg%s;"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agc* $$; agg;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_GMLFCN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'J'</literal></expr>:</case>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_callgraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_GRAPH_FORMAT_CMD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: see ag?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"agfj%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'J'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"agfJ%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"agfk%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_CORE_ANAL_GRAPHLINES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_datarefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .aga* @ %"</literal><name>PFMT64u</name><literal type="string">";"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.from"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>it</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>==</operator> <name>UT64_MAX</name><operator>)</operator> <operator>||</operator> <call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_datarefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agA*;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_agraph_print</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>diff_opt</name> <init>= <expr><name>R_CORE_ANAL_GRAPHBODY</name> <operator>|</operator> <name>R_CORE_ANAL_GRAPHDIFF</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_gdiff_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>diff_opt</name> <operator>|</operator> <name>R_CORE_ANAL_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'J'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_gdiff_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>diff_opt</name> <operator>|</operator> <name>R_CORE_ANAL_JSON</name> <operator>|</operator> <name>R_CORE_ANAL_JSON_FORMAT_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_gdiff_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>diff_opt</name> <operator>|</operator> <name>R_CORE_ANAL_STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-; .agd* @ %"</literal><name>PFMT64u</name><literal type="string">"; agg%s;"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_gdiff_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>diff_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdargs</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"agdd 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>graph_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmdargs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name><argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmdargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"agfv%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.web"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"=H /graph/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdargs</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"agfd @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>graph_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmdargs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Saving to file %s ...\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmdargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_refs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cfg_debug</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rad</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'j'</literal> <operator>||</operator> <operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rad</name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>rad</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cfg_debug</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_debug_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name><modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot determine xref search boundaries\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>to</name> <operator>-</operator> <name>from</name> <operator>&gt;</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Skipping huge range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\"mapid\":\"%d\",\"refs\":{"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>nth</name></expr>?</condition><then> <expr><literal type="string">","</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_search_xrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nth</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid number of arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>to</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>to</name> <operator>-</operator> <name>from</name> <operator>&gt;</operator> <call><name>r_io_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>r_core_anal_search_xrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compute_coverage</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cov</name> <operator>+=</operator> <call><name>r_meta_get_size</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter2</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>section_end</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>s</name> <init>= <expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>s</name><operator>)</operator> <operator>&lt;</operator> <name>section_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cov</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<return>return <expr><name>cov</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compute_code</name> <parameter_list>(<parameter><decl><type><name>RCore</name><modifier>*</modifier></type> <name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>+=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>code</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compute_calls</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>xrefs</name> <operator>=</operator> <call><name>r_anal_function_get_xrefs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xrefs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cov</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xrefs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>cov</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_core_anal_info</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fcns</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>strs</name> <init>= <expr><call><name>r_flag_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"str.*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>syms</name> <init>= <expr><call><name>r_flag_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"sym.*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>imps</name> <init>= <expr><call><name>r_flag_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"sym.imp.*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><call><name>compute_code</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>covr</name> <init>= <expr><call><name>compute_coverage</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>call</name> <init>= <expr><call><name>compute_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xrfs</name> <init>= <expr><call><name>r_anal_xrefs_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cvpc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>code</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>covr</name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>code</name><operator>)</operator></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fcns"</literal></expr></argument>, <argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"xrefs"</literal></expr></argument>, <argument><expr><name>xrfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"calls"</literal></expr></argument>, <argument><expr><name>call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"strings"</literal></expr></argument>, <argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"symbols"</literal></expr></argument>, <argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"imports"</literal></expr></argument>, <argument><expr><name>imps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"covrage"</literal></expr></argument>, <argument><expr><name>covr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"codesz"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"percent"</literal></expr></argument>, <argument><expr><name>cvpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fcns %d\n"</literal></expr></argument>, <argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"xrefs %d\n"</literal></expr></argument>, <argument><expr><name>xrfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"calls %d\n"</literal></expr></argument>, <argument><expr><name>call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"strings %d\n"</literal></expr></argument>, <argument><expr><name>strs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"symbols %d\n"</literal></expr></argument>, <argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"imports %d\n"</literal></expr></argument>, <argument><expr><name>imps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"covrage %d\n"</literal></expr></argument>, <argument><expr><name>covr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"codesz %d\n"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"percent %d%%\n"</literal></expr></argument>, <argument><expr><name>cvpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_aad</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_xrefs_from</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="string">"xref"</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>archIsThumbable</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAsm</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><ternary><condition><expr><name>core</name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>as</name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>bits</name></name> <operator>&lt;=</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_CbInRangeAav</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>asterisk</name> <init>= <expr><name>user</name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arch_align</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_ALIGN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>vinfun</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.vinfun"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>searchAlign</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.align"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>align</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>searchAlign</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>searchAlign</name></expr></then><else>: <expr><name>arch_align</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>from</name> <operator>%</operator> <name>align</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>to</name> <operator>%</operator> <name>align</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>itsFine</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archIsThumbable</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>from</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>to</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>itsFine</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>itsFine</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: aav: false positive in 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vinfun</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>asterisk</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ax 0x%"</literal><name>PFMT64x</name> <literal type="string">" 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d @ 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f+ aav.0x%08"</literal><name>PFMT64x</name> <literal type="string">"= 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"Cd %d @ 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"aav.0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_aav</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>seti</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_config_set_i(core-&gt;config, x, y);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>geti</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_config_get_i(core-&gt;config, x);</cpp:value></cpp:define>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'v'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>o_align</name> <init>= <expr><call><name>geti</name> <argument_list>(<argument><expr><literal type="string">"search.align"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>analin</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>analin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>asterisk</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_debug</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>archAlign</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_ALIGN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>seti</name> <argument_list>(<argument><expr><literal type="string">"search.align"</literal></expr></argument>, <argument><expr><name>archAlign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>, <argument><expr><literal type="string">"io.maps.x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Finding xrefs in noncode section with anal.in=io.maps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>vsize</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vsize</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Analyze value pointers (aav)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_debug</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"dbg.map"</literal></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"from 0x%"</literal><name>PFMT64x</name><literal type="string">" to 0x%"</literal><name>PFMT64x</name><literal type="string">" (aav)"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_search_value_in_range</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>,

<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>_CbInRangeAav</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>asterisk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>map2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter2</argument>, <argument>map2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_itv_begin</name> <argument_list>(<argument><expr><name><name>map2</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map2</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"Value from 0x%08"</literal><name>PFMT64x</name> <literal type="string">" to 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" (aav)"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>begin</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>begin</name> <operator>&gt;</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Skipping huge range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"-0x%08"</literal><name>PFMT64x</name><literal type="string">" in 0x%"</literal><name>PFMT64x</name><literal type="string">"-0x%"</literal><name>PFMT64x</name><literal type="string">" (aav)"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_search_value_in_range</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>_CbInRangeAav</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>asterisk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>seti</name> <argument_list>(<argument><expr><literal type="string">"search.align"</literal></expr></argument>, <argument><expr><name>o_align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_abt</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: abte [addr] #emulate from beginning of function to the given address.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>paths</name> <init>= <expr><call><name>r_core_anal_graph_to</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>paths</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>pathi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>bbi</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f orip=`dr?PC`\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>paths</argument>, <argument>pathi</argument>, <argument>path</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>path</argument>, <argument>bbi</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aepc 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aesou 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aepc 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aesou 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aepc orip\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_abt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>r_anal_block_shortest_path</name> <argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>path</argument>, <argument>it</argument>, <argument>block</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>r_anal_block_shortest_path</name> <argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>path</argument>, <argument>it</argument>, <argument>block</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage abt?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_unknown_file</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>o</name><operator>-&gt;</operator><name>sections</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_anal_all</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_blocks</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aef@@f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>cur</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>hasnext</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>, <argument><expr><name>hasnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>cmd_anal_aaft</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>analHasnext</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afr@@c:isq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>, <argument><expr><name>analHasnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aaf[e|r|t] - analyze all functions again\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aafe = aef@@f\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"aafr [len] = analyze all consecutive functions in section\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aaft = recursive type matching in all functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" aaf = afr@@c:isq\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aac, aac* or aaci (imports xrefs only)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><call><name>cmd_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_jumps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_aad</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_aav</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_nofunclist</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af @@= `isq~[0]`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af @@ entry*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af @@ sym.*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af @@ entry*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_inflags</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aaF[a] - analyze functions in flag bounds (aaFa uses af/a2f instead of af+/afb+)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_propagate_noreturn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_autoname_all_golang_fcns</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aan[rg]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"aan : autoname all functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"aang : autoname all golang functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"aanr : auto-noreturn propagation\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><call><name>r_core_anal_autoname_all_fcns</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /aap ; find in memory for function preludes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_search_preludes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: See aa? for more help"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>didAap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dh_orig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"aaaaa"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"An r2 developer is coming to your place to manually analyze this program. Please wait for it\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_any_key</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Analyze all flags starting with sym. and entry0 (aa)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_timeout</name> <argument_list>(<argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.timeout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_all</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dh_orig</name> <operator>=</operator> <ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name></expr>

?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"esil"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>plugin</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>plugin</name><operator>-&gt;</operator><name>isdbg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>dh_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>cfg_debug</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.lang"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"go"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Find function and symbol names from golang binaries (aang)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_autoname_all_golang_fcns</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Analyze all flags starting with sym.go. (aF @@ sym.go.*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aF @@ sym.go.*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cfg_debug</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dh_orig</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>dh_orig</name></expr></argument>, <argument><expr><literal type="string">"esil"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dL esil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.calls"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.calls"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"s $S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Analyze function calls (aac)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmd_anal_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>curseek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_unknown_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"find and analyze function preludes (aap)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_search_preludes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>didAap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Analyze len bytes of instructions for references (aar)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_anal_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Check for objc references"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_anal_objc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Check for vtables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"avrr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.calls"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_str_startswith</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aav"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ioCache</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.pcache"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.pcache"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Emulate code to find computed references (aae)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aae"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ioCache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wc-*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.pcache"</literal></expr></argument>, <argument><expr><name>ioCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>jacuzzi</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.autoname"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Speculatively constructing a function name "</literal>

<literal type="string">"for fcn.* and sym.func.* functions (aan)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_autoname_all_fcns</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>vars</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_recover_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdb_isempty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_zigns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Check for zignature from zigns folder (z/)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"z/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Type matching analysis for all functions (aaft)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aaft"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Propagate noreturn information"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_propagate_noreturn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Use -AA or aaaa to perform additional experimental analysis."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>didAap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Finding function preludes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_search_preludes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Enable constraint types analysis for variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.types.constraint"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"s-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dh_orig</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dL %s"</literal></expr></argument>, <argument><expr><name>dh_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>curseek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>jacuzzi</name>:</label>

<expr_stmt><expr><call><name>flag_every_function</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>dh_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>off</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>off</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_link_stroff</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at %08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Couldn't find any functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>it</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_link_stroff</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'T'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_aftertraps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_objc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aef@@@F"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>len</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>addr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"anal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"$SS"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_anal_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_fcn_data</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_ANY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>gap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>gap_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>fcn_size</name> <init>= <expr><call><name>r_anal_function_size_from_entry</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bitmap</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fcn_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>f</name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>fcn_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>f</name> <operator>&lt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bitmap</name><index>[<expr><name>f</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fcn_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>here</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <name><name>bitmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>gap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>here</name> <operator>-</operator> <name>gap_addr</name></expr></argument>, <argument><expr><name>gap_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>gap_addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>gap_addr</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>fcn_size</name> <operator>-</operator> <name>gap_addr</name></expr></argument>, <argument><expr><name>gap_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_fcn_data_gaps</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>wordsize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">8</literal></expr></then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>range</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>end</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>range</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <name>wordsize</name> <operator>&lt;</operator> <name>range</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator> <name>wordsize</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>range</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <call><name>r_anal_function_size_from_entry</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_rtti</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_rtti_print_at_vtable</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_rtti_print_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_rtti_recover_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>demangled</name> <init>= <expr><call><name>r_anal_rtti_demangle_class_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>demangled</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>demangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>demangled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default :</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_virtual_functions</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_list_vtables</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_rtti</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default :</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_class_method</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalClassErr</name></type> <name>err</name> <init>= <expr><name>R_ANAL_CLASS_ERR_SUCCESS</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<case>case <expr><literal type="char">'n'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No class name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No method name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_str</name> <init>= <expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>name_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No offset given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No new method name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr_str</name> <init>= <expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>addr_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalMethod</name></type> <name>meth</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>meth</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name_str</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>meth</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>addr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>meth</name><operator>.</operator><name>vtable_offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>meth</name><operator>.</operator><name>vtable_offset</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_method_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_name_str</name> <init>= <expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>new_name_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_method_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>name_str</name></expr></argument>, <argument><expr><name>new_name_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_method_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>name_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_CLASS_ERR_NONEXISTENT_CLASS</name></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Class does not exist.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>R_ANAL_CLASS_ERR_NONEXISTENT_ATTR</name></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Method does not exist.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_class_base</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalClassErr</name></type> <name>err</name> <init>= <expr><name>R_ANAL_CLASS_ERR_SUCCESS</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No class name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name> <operator>||</operator> <operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_class_list_bases</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No base id given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_str</name> <init>= <expr><name>end</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>base_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_base_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>base_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalBaseClass</name></type> <name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>base</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>base</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>base</name><operator>.</operator><name>class_name</name></name> <operator>=</operator> <name>base_str</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>base</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_base_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>base</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>R_ANAL_CLASS_ERR_NONEXISTENT_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Class does not exist.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_class_vtable</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalClassErr</name></type> <name>err</name> <init>= <expr><name>R_ANAL_CLASS_ERR_SUCCESS</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No offset given\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset_arg</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>class_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>class_arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>class_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_wp</name> <argument_list>(<argument><expr><name>class_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_class_list_vtable_offset_functions</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>class_arg</name></expr></argument>, <argument><expr><name>offset_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No class name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name> <operator>||</operator> <operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_class_list_vtables</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No vtable id given. See acv [class name].\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg1_str</name> <init>= <expr><name>end</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_vtable_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>arg1_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>arg1_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalVTable</name></type> <name>vtable</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg1_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg3_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg3_str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>end</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg3_str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>vtable</name><operator>.</operator><name>size</name></name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg3_str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>r_anal_class_vtable_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>vtable</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>R_ANAL_CLASS_ERR_NONEXISTENT_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Class does not exist.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_classes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_class_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<case>case <expr><literal type="char">'n'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_class_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No new class name given.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_name</name> <init>= <expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>new_name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalClassErr</name></type> <name>err</name> <init>= <expr><call><name>r_anal_class_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>R_ANAL_CLASS_ERR_NONEXISTENT_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Class does not exist.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>err</name> <operator>==</operator> <name>R_ANAL_CLASS_ERR_CLASH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"A class with this name already exists.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_class_create</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<expr_stmt><expr><call><name>cmd_anal_class_vtable</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_class_base</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_class_method</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_reg_args</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>regname</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>regname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"A%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>v</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sb</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name></expr>?</condition><then><expr><literal type="string">", "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"A%d 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_anal_aC</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>is_aCer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFuncArg</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>nextele</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>iarg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".aCe* $$ @@=`pdr~call`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>iarg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iarg</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iarg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aC[e] [addr-of-call] #analyze call args (aCe does esil emulation with abte)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>pcv</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>iarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>is_aCer</name> <operator>=</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".abte 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>pcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalOp</name><modifier>*</modifier></type> <name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pcv</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_free</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>go_on</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_reg_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>go_on</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>go_on</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>pcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>fcn_name</name><operator>)</operator></expr>?</condition><then> <expr><call><name>resolve_fcn_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_type</name> <init>= <expr><call><name>r_type_func_ret</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>r_type_func_args_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s("</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>fcn_type</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>fcn_type</name> <operator>&amp;&amp;</operator> <name><name>fcn_type</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>fcn_type</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,

<argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nargs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"void)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any function type..lets just use some standards?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_aCer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>show_reg_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>go_on</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>show_reg_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>go_on</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>go_on</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>s_width</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">8</literal></expr></then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>spv</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>spv</name> <operator>+</operator> <name>s_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_func_args</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

bool warning = false;

bool on_stack = false;

r_list_foreach (list, iter, arg) {

if (r_str_startswith (arg-&gt;cc_source, "stack")) {

on_stack = true;

}

if (!arg-&gt;size) {

r_cons_printf ("%s: unk_size", arg-&gt;c_type);

warning = true;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>arg</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>nextele</name> <operator>=</operator> <call><name>r_list_iter_get_next</name> <argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>arg</name><operator>-&gt;</operator><name>fmt</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"?%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>nextele</name></expr>?</condition><then> <expr><literal type="string">", "</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pfq %s @ 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fmt</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nargs</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>

<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>

<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fcn_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"; %s("</literal></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"; 0x%"</literal><name>PFMT64x</name><literal type="string">"("</literal></expr></argument>, <argument><expr><name>pcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>v</name> <init>= <expr><call><name>r_debug_arg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_ANAL_CC_TYPE_FASTCALL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name></expr>?</condition><then><expr><literal type="string">", "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>spv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_aCer</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>u</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"CCu base64:%s\n"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_anal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>tbs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>prelude</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><literal type="string">"\xe9\x2d"</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prelude_sz</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bufsz</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>off</name> <operator>-</operator> <name>bufsz</name> <operator>+</operator> <name>prelude_sz</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>off</name> <operator>-</operator> <name>bufsz</name> <operator>+</operator> <name>prelude_sz</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_mem_reverse</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>pos</name> <init>= <expr><call><name>r_mem_mem</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><name>prelude</name></expr></argument>, <argument><expr><name>prelude_sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"POS = %d\n"</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"HIT = 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name> <operator>-</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name> <operator>-</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find prelude\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>core_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeab%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>core_anal_bbs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>core_anal_bbs_range</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_anal_abt</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>anal_fcn_list_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afbi @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_classes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_aC</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> <expr_stmt><expr><call><name>cmd_anal_info</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> 

<case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><call><name>cmd_anal_reg</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> 

<case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><call><name>cmd_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> 

<case>case <expr><literal type="char">'L'</literal></expr>:</case> <return>return <expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e asm.arch=??"</literal></expr></argument>)</argument_list></call></expr>;</return> <break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> <expr_stmt><expr><call><name>cmd_anal_opcode</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> 

<case>case <expr><literal type="char">'O'</literal></expr>:</case> <expr_stmt><expr><call><name>cmd_anal_bytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> 

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>cmd_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>use_json</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>use_json</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>cmd_an</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>use_json</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_syscall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_virtual_functions</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cmd_anal_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afl*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ah*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ax*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cmd_anal_all</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>anal_fcn_data_gaps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>anal_fcn_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_trampoline</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>default_depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <ternary><condition><expr><name>p</name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>default_depth</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_anal_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_anal_data_kind</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'4'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'8'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_anal_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_anal_hint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'!'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>cmd_ext</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>cmd_ext</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"No plugins for this analysis plugin\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aflj"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aai"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

r_cons_printf ("Examples:\n"

" f ts @ `S*~text:0[3]`; f t @ section..text\n"

" f ds @ `S*~data:0[3]`; f d @ section..data\n"

" .ad t t+ts @ d:ds\n",

NULL);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>tbs</name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
