<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\shlr\qnx\src\sigutil.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gdb_signals.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sigutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGHUP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGINT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGQUIT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGILL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGTRAP</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGIOT</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGABRT</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGEMT</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGDEADLK</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGFPE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGKILL</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGBUS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGSEGV</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGSYS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGPIPE</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGALRM</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGTERM</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGUSR1</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGUSR2</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGCHLD</name></cpp:macro> <cpp:value>18</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGPWR</name></cpp:macro> <cpp:value>19</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGWINCH</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGURG</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGPOLL</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGIO</name></cpp:macro> <cpp:value>NTO_SIGPOLL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGSTOP</name></cpp:macro> <cpp:value>23</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGTSTP</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGCONT</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGTTIN</name></cpp:macro> <cpp:value>26</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGTTOU</name></cpp:macro> <cpp:value>27</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGVTALRM</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGPROF</name></cpp:macro> <cpp:value>29</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGXCPU</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGXFSZ</name></cpp:macro> <cpp:value>31</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGRTMIN</name></cpp:macro> <cpp:value>41</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGRTMAX</name></cpp:macro> <cpp:value>56</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGSELECT</name></cpp:macro> <cpp:value>(NTO_SIGRTMAX + 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTO_SIGPHOTON</name></cpp:macro> <cpp:value>(NTO_SIGRTMAX + 2)</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>nto_sig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>target_signal</name></name></type> <name>gdb_sig</name></decl>;</decl_stmt>

}</block> <decl><name><name>sig_map</name><index>[]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><name>NTO_SIGHUP</name></expr>, <expr><name>TARGET_SIGNAL_HUP</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGINT</name></expr>, <expr><name>TARGET_SIGNAL_INT</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGQUIT</name></expr>, <expr><name>TARGET_SIGNAL_QUIT</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGILL</name></expr>, <expr><name>TARGET_SIGNAL_ILL</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGTRAP</name></expr>, <expr><name>TARGET_SIGNAL_TRAP</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGABRT</name></expr>, <expr><name>TARGET_SIGNAL_ABRT</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGEMT</name></expr>, <expr><name>TARGET_SIGNAL_EMT</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGFPE</name></expr>, <expr><name>TARGET_SIGNAL_FPE</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGKILL</name></expr>, <expr><name>TARGET_SIGNAL_KILL</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGBUS</name></expr>, <expr><name>TARGET_SIGNAL_BUS</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGSEGV</name></expr>, <expr><name>TARGET_SIGNAL_SEGV</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGSYS</name></expr>, <expr><name>TARGET_SIGNAL_SYS</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGPIPE</name></expr>, <expr><name>TARGET_SIGNAL_PIPE</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGALRM</name></expr>, <expr><name>TARGET_SIGNAL_ALRM</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGTERM</name></expr>, <expr><name>TARGET_SIGNAL_TERM</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGUSR1</name></expr>, <expr><name>TARGET_SIGNAL_USR1</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGUSR2</name></expr>, <expr><name>TARGET_SIGNAL_USR2</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGCHLD</name></expr>, <expr><name>TARGET_SIGNAL_CHLD</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGPWR</name></expr>, <expr><name>TARGET_SIGNAL_PWR</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGWINCH</name></expr>, <expr><name>TARGET_SIGNAL_WINCH</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGURG</name></expr>, <expr><name>TARGET_SIGNAL_URG</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGPOLL</name></expr>, <expr><name>TARGET_SIGNAL_POLL</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGSTOP</name></expr>, <expr><name>TARGET_SIGNAL_STOP</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGTSTP</name></expr>, <expr><name>TARGET_SIGNAL_TSTP</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGCONT</name></expr>, <expr><name>TARGET_SIGNAL_CONT</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGTTIN</name></expr>, <expr><name>TARGET_SIGNAL_TTIN</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGTTOU</name></expr>, <expr><name>TARGET_SIGNAL_TTOU</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGVTALRM</name></expr>, <expr><name>TARGET_SIGNAL_VTALRM</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGPROF</name></expr>, <expr><name>TARGET_SIGNAL_PROF</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGXCPU</name></expr>, <expr><name>TARGET_SIGNAL_XCPU</name></expr>}</block></expr>,

<expr><block>{<expr><name>NTO_SIGXFSZ</name></expr>, <expr><name>TARGET_SIGNAL_XFSZ</name></expr>}</block></expr>}</block></expr></init></decl>;</struct>

<function><type><name><name>enum</name> <name>target_signal</name></name></type>

<name>target_signal_from_host</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>hostsig</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_0</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGHUP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_HUP</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGINT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_INT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGQUIT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_QUIT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGILL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_ILL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGTRAP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_TRAP</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGABRT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_ABRT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGEMT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGEMT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_EMT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGFPE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_FPE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGKILL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_KILL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGBUS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_BUS</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGSEGV</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_SEGV</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGSYS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_SYS</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPIPE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_PIPE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGALRM</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_ALRM</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_TERM</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGUSR1</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_USR1</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGUSR2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_USR2</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGCLD</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_CHLD</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGCHLD</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_CHLD</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPWR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPWR</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_PWR</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGWINCH</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_WINCH</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGURG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGURG</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_URG</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGIO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGIO</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_IO</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPOLL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_POLL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGSTOP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_STOP</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTSTP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGTSTP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_TSTP</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGCONT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_CONT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGTTIN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_TTIN</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGTTOU</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_TTOU</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGVTALRM</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_VTALRM</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPROF</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPROF</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_PROF</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXCPU</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGXCPU</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_XCPU</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGXFSZ</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_XFSZ</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWIND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGWIND</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_WIND</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPHONE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPHONE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_PHONE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGLOST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGLOST</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_LOST</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWAITING</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGWAITING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_WAITING</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCANCEL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGCANCEL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_CANCEL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGLWP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGLWP</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_LWP</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGDANGER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGDANGER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_DANGER</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGGRANT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGGRANT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_GRANT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGRETRACT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGRETRACT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_RETRACT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGMSG</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_MSG</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGSOUND</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_SOUND</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSAK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGSAK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_SAK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPRIO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGPRIO</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_PRIO</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BAD_ACCESS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_BAD_ACCESS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_BAD_ACCESS</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BAD_INSTRUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_BAD_INSTRUCTION</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_BAD_INSTRUCTION</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_ARITHMETIC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_ARITHMETIC</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_ARITHMETIC</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_EMULATION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_EMULATION</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_EMULATION</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_SOFTWARE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_SOFTWARE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_SOFTWARE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BREAKPOINT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>_NSIG</name> <operator>+</operator> <name>EXC_BREAKPOINT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_EXC_BREAKPOINT</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>==</operator> <name>SIGINFO</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_INFO</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REALTIME_LO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>hostsig</name> <operator>&gt;=</operator> <name>REALTIME_LO</name> <operator>&amp;&amp;</operator> <name>hostsig</name> <operator>&lt;</operator> <name>REALTIME_HI</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">33</literal> <operator>&lt;=</operator> <name>hostsig</name> <operator>&amp;&amp;</operator> <name>hostsig</name> <operator>&lt;=</operator> <literal type="number">63</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator>enum <name>target_signal</name><operator>)</operator><operator>(</operator><name>hostsig</name> <operator>-</operator> <literal type="number">33</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>TARGET_SIGNAL_REALTIME_33</name><operator>)</operator></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>hostsig</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_REALTIME_32</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><literal type="number">64</literal> <operator>&lt;=</operator> <name>hostsig</name> <operator>&amp;&amp;</operator> <name>hostsig</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator>enum <name>target_signal</name><operator>)</operator><operator>(</operator><name>hostsig</name> <operator>-</operator> <literal type="number">64</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>TARGET_SIGNAL_REALTIME_64</name><operator>)</operator></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>error</name> <argument_list>(<argument><expr><literal type="string">"GDB bug: target.c (target_signal_from_host): unrecognized real-time signal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>TARGET_SIGNAL_UNKNOWN</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>do_target_signal_to_host</name> <parameter_list>(<parameter><decl><type><name><name>enum</name> <name>target_signal</name></name></type> <name>oursig</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>oursig_ok</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>retsig</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>retsig</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>oursig_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>oursig</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TARGET_SIGNAL_0</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_HUP</name></expr>:</case>

<return>return <expr><name>SIGHUP</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_INT</name></expr>:</case>

<return>return <expr><name>SIGINT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_QUIT</name></expr>:</case>

<return>return <expr><name>SIGQUIT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_ILL</name></expr>:</case>

<return>return <expr><name>SIGILL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_TRAP</name></expr>:</case>

<return>return <expr><name>SIGTRAP</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_ABRT</name></expr>:</case>

<return>return <expr><name>SIGABRT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGEMT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_EMT</name></expr>:</case>

<return>return <expr><name>SIGEMT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_FPE</name></expr>:</case>

<return>return <expr><name>SIGFPE</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_KILL</name></expr>:</case>

<return>return <expr><name>SIGKILL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_BUS</name></expr>:</case>

<return>return <expr><name>SIGBUS</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_SEGV</name></expr>:</case>

<return>return <expr><name>SIGSEGV</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_SYS</name></expr>:</case>

<return>return <expr><name>SIGSYS</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_PIPE</name></expr>:</case>

<return>return <expr><name>SIGPIPE</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_ALRM</name></expr>:</case>

<return>return <expr><name>SIGALRM</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_TERM</name></expr>:</case>

<return>return <expr><name>SIGTERM</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_USR1</name></expr>:</case>

<return>return <expr><name>SIGUSR1</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_USR2</name></expr>:</case>

<return>return <expr><name>SIGUSR2</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIGCLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_CHLD</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><name>SIGCHLD</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>SIGCLD</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPWR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_PWR</name></expr>:</case>

<return>return <expr><name>SIGPWR</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_WINCH</name></expr>:</case>

<return>return <expr><name>SIGWINCH</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGURG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_URG</name></expr>:</case>

<return>return <expr><name>SIGURG</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGIO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_IO</name></expr>:</case>

<return>return <expr><name>SIGIO</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_POLL</name></expr>:</case>

<return>return <expr><name>SIGPOLL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_STOP</name></expr>:</case>

<return>return <expr><name>SIGSTOP</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTSTP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_TSTP</name></expr>:</case>

<return>return <expr><name>SIGTSTP</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_CONT</name></expr>:</case>

<return>return <expr><name>SIGCONT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_TTIN</name></expr>:</case>

<return>return <expr><name>SIGTTIN</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_TTOU</name></expr>:</case>

<return>return <expr><name>SIGTTOU</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_VTALRM</name></expr>:</case>

<return>return <expr><name>SIGVTALRM</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPROF</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_PROF</name></expr>:</case>

<return>return <expr><name>SIGPROF</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXCPU</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_XCPU</name></expr>:</case>

<return>return <expr><name>SIGXCPU</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_XFSZ</name></expr>:</case>

<return>return <expr><name>SIGXFSZ</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWIND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_WIND</name></expr>:</case>

<return>return <expr><name>SIGWIND</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPHONE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_PHONE</name></expr>:</case>

<return>return <expr><name>SIGPHONE</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGLOST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_LOST</name></expr>:</case>

<return>return <expr><name>SIGLOST</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWAITING</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_WAITING</name></expr>:</case>

<return>return <expr><name>SIGWAITING</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCANCEL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_CANCEL</name></expr>:</case>

<return>return <expr><name>SIGCANCEL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGLWP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_LWP</name></expr>:</case>

<return>return <expr><name>SIGLWP</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGDANGER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_DANGER</name></expr>:</case>

<return>return <expr><name>SIGDANGER</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGGRANT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_GRANT</name></expr>:</case>

<return>return <expr><name>SIGGRANT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGRETRACT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_RETRACT</name></expr>:</case>

<return>return <expr><name>SIGRETRACT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_MSG</name></expr>:</case>

<return>return <expr><name>SIGMSG</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_SOUND</name></expr>:</case>

<return>return <expr><name>SIGSOUND</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSAK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_SAK</name></expr>:</case>

<return>return <expr><name>SIGSAK</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPRIO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_PRIO</name></expr>:</case>

<return>return <expr><name>SIGPRIO</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BAD_ACCESS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_BAD_ACCESS</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_BAD_ACCESS</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BAD_INSTRUCTION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_BAD_INSTRUCTION</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_BAD_INSTRUCTION</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_ARITHMETIC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_ARITHMETIC</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_ARITHMETIC</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_EMULATION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_EMULATION</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_EMULATION</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_SOFTWARE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_SOFTWARE</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_SOFTWARE</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXC_BREAKPOINT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_EXC_BREAKPOINT</name></expr>:</case>

<return>return <expr><name>_NSIG</name> <operator>+</operator> <name>EXC_BREAKPOINT</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>TARGET_SIGNAL_INFO</name></expr>:</case>

<return>return <expr><name>SIGINFO</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REALTIME_LO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>retsig</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oursig</name> <operator>&gt;=</operator> <name>TARGET_SIGNAL_REALTIME_33</name> <operator>&amp;&amp;</operator> <name>oursig</name> <operator>&lt;=</operator> <name>TARGET_SIGNAL_REALTIME_63</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retsig</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>oursig</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>TARGET_SIGNAL_REALTIME_33</name> <operator>+</operator> <literal type="number">33</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oursig</name> <operator>==</operator> <name>TARGET_SIGNAL_REALTIME_32</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retsig</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oursig</name> <operator>&gt;=</operator> <name>TARGET_SIGNAL_REALTIME_64</name> <operator>&amp;&amp;</operator> <name>oursig</name> <operator>&lt;=</operator> <name>TARGET_SIGNAL_REALTIME_127</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retsig</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>oursig</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>TARGET_SIGNAL_REALTIME_64</name> <operator>+</operator> <literal type="number">64</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retsig</name> <operator>&gt;=</operator> <name>REALTIME_LO</name> <operator>&amp;&amp;</operator> <name>retsig</name> <operator>&lt;</operator> <name>REALTIME_HI</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>retsig</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>oursig_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>target_signal_to_host</name> <parameter_list>(<parameter><decl><type><name><name>enum</name> <name>target_signal</name></name></type> <name>oursig</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>oursig_ok</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>targ_signo</name> <init>= <expr><call><name>do_target_signal_to_host</name> <argument_list>(<argument><expr><name>oursig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oursig_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oursig_ok</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>targ_signo</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name><name>enum</name> <name>target_signal</name></name></type>

<name>target_signal_from_nto</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name>ARRAY_SIZE</name> <argument_list>(<argument><expr><name>sig_map</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sig_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nto_sig</name> <operator>==</operator> <name>sig</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>sig_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gdb_sig</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&gt;=</operator> <name>NTO_SIGRTMIN</name> <operator>&amp;&amp;</operator> <name>sig</name> <operator>&lt;=</operator> <name>NTO_SIGRTMAX</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TARGET_SIGNAL_REALTIME_41</name> <operator>+</operator> <name>sig</name> <operator>-</operator> <name>NTO_SIGRTMIN</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>target_signal_from_host</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>host_signal_from_nto</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>target_signal_to_host</name> <argument_list>(<argument><expr><call><name>target_signal_to_host</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

</unit>
