<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\shlr\zip\zlib\deflate.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"deflate.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>deflate_copyright</name><index>[]</index></name> <init>=

<expr><literal type="string">" deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler "</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <block>{

<decl><name>need_more</name></decl>, 

<decl><name>block_done</name></decl>, 

<decl><name>finish_started</name></decl>, 

<decl><name>finish_done</name></decl> 

}</block></enum></type> <name>block_state</name>;</typedef>

<typedef>typedef <macro><name>block_state</name> <argument_list>(<argument>*compress_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>local</name> <name>int</name> <name>deflateStateCheck</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>slide_hash</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>fill_window</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_stored</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_fast</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_slow</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_rle</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>block_state</name> <name>deflate_huff</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>lm_init</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>putShortMSB</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>uInt</name> <name>b</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>void</name> <name>flush_pending</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>local</name> <name>unsigned</name> <name>read_buf</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>unsigned</name> <name>size</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>message</name><name>(</name><cpp:literal>"Assembler code may have bugs -- use at your own risk"</cpp:literal><name>)</name></cpp:pragma>

<decl_stmt><decl><type><name>void</name> <name>match_init</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name> <name>longest_match</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>cur_match</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>local</name> <name>uInt</name> <name>longest_match</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>cur_match</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZLIB_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>check_match</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>deflate_state</name> <operator>*</operator><name>s</name><operator>,</operator> <name>IPos</name> <name>start</name><operator>,</operator> <name>IPos</name> <name>match</name><operator>,</operator>

<name>int</name> <name>length</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TOO_FAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOO_FAR</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>config_s</name> <block>{

<decl_stmt><decl><type><name>ush</name></type> <name>good_length</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ush</name></type> <name>max_lazy</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ush</name></type> <name>nice_length</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ush</name></type> <name>max_chain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>

}</block></struct></type> <name>config</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>deflate_stored</name></expr>}</block></expr>, 

<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>local</name> <specifier>const</specifier> <name>config</name></type> <name><name>configuration_table</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>deflate_stored</name></expr>}</block></expr>, 

<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>, 

<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><name>deflate_fast</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>, 

<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">256</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">258</literal></expr>, <expr><literal type="number">4096</literal></expr>, <expr><name>deflate_slow</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANK</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((f) * 2) - ((f) &gt; 4 ? 9 : 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_HASH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>match_head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), match_head = s-&gt;head[s-&gt;ins_h], s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_STRING</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>match_head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], s-&gt;head[s-&gt;ins_h] = (Pos)(str))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_HASH</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s-&gt;head[s-&gt;hash_size-1] = NIL; zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</cpp:value></cpp:define>

<function><type><name>local</name> <name>void</name></type> <name>slide_hash</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Posf</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>wsize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>*</operator><operator>--</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>m</name> <operator>&gt;=</operator> <name>wsize</name></expr> ?</condition><then> <expr><name>m</name> <operator>-</operator> <name>wsize</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>wsize</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>*</operator><operator>--</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>m</name> <operator>&gt;=</operator> <name>wsize</name></expr> ?</condition><then> <expr><name>m</name> <operator>-</operator> <name>wsize</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>

<block>{<block_content>

<return>return <expr><call><name>deflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><name>MAX_WBITS</name></expr></argument>, <argument><expr><name>DEF_MEM_LEVEL</name></expr></argument>,

<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateInit2_</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>method</name></type></decl></parameter>, <parameter><decl><type><name>windowBits</name></type></decl></parameter>, <parameter><decl><type><name>memLevel</name></type></decl></parameter>, <parameter><decl><type><name>strategy</name></type></decl></parameter>,

<parameter><decl><type><name>version</name></type></decl></parameter>, <parameter><decl><type><name>stream_size</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>memLevel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wrap</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>my_version</name><index>[]</index></name> <init>= <expr><name>ZLIB_VERSION</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ushf</name> <modifier>*</modifier></type><name>overlay</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>my_version</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>

<name>stream_size</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_VERSION_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_SOLO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <name>zcalloc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <operator>(</operator><name>voidpf</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_SOLO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <name>zcfree</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>wrap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>windowBits</name> <operator>=</operator> <operator>-</operator><name>windowBits</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>windowBits</name> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wrap</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>windowBits</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>memLevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>memLevel</name></expr></argument> &gt;</argument_list></name> <name>MAX_MEM_LEVEL</name> <operator>||</operator> <name>method</name> <operator>!=</operator> <name>Z_DEFLATED</name> <operator>||</operator>

<name><name>windowBits</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>windowBits</name></expr></argument> &gt;</argument_list></name> <literal type="number">15</literal> <operator>||</operator> <name><name>level</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>level</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal> <operator>||</operator>

<name><name>strategy</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>strategy</name></expr></argument> &gt;</argument_list></name> <name>Z_FIXED</name> <operator>||</operator> <operator>(</operator><name>windowBits</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>wrap</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>windowBits</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>windowBits</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name> <operator>=</operator> <name>strm</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>INIT_STATE</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <name>wrap</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>windowBits</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>memLevel</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_mask</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>hash_shift</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name><operator>+</operator><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>MIN_MATCH</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>memLevel</name> <operator>+</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt> 

<expr_stmt><expr><name>overlay</name> <operator>=</operator> <operator>(</operator><name>ushf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>=</operator> <operator>(</operator><name>uchf</name> <operator>*</operator><operator>)</operator> <name>overlay</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2L</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>

<name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>FINISH_STATE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <call><name>ERR_MSG</name><argument_list>(<argument><expr><name>Z_MEM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name>overlay</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>l_buf</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>method</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>)</operator><name>method</name></expr>;</expr_stmt>

<return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>local</name> <name>int</name></type> <name>deflateStateCheck</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>

<name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>==</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator><literal type="number">0</literal> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name> <operator>==</operator> <operator>(</operator><name>free_func</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name></name> <operator>!=</operator> <name>strm</name> <operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>INIT_STATE</name> <operator>&amp;&amp;</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>GZIP_STATE</name> <operator>&amp;&amp;</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>EXTRA_STATE</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>NAME_STATE</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>COMMENT_STATE</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>HCRC_STATE</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>BUSY_STATE</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>FINISH_STATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetDictionary</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>dictionary</name></type></decl></parameter>, <parameter><decl><type><name>dictLength</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>dictionary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>dictLength</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wrap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>avail</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_const</name> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>dictionary</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>wrap</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>INIT_STATE</name><operator>)</operator> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>dictLength</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>wrap</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dictionary</name> <operator>+=</operator> <name>dictLength</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>dictLength</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>dictLength</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>z_const</name> <name>Bytef</name> <operator>*</operator><operator>)</operator><name>dictionary</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator> <operator>(</operator><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>str</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>avail</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <name>wrap</name></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateGetDictionary</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>dictionary</name></type></decl></parameter>, <parameter><decl><type><name>dictLength</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>dictionary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name> <modifier>*</modifier></type><name>dictLength</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dictionary</name> <operator>!=</operator> <name>Z_NULL</name> <operator>&amp;&amp;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dictLength</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>dictLength</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateResetKeep</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>data_type</name></name> <operator>=</operator> <name>Z_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>GZIP_STATE</name></expr> </then><else>:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr> ?</condition><then> <expr><name>INIT_STATE</name></expr> </then><else>: <expr><name>BUSY_STATE</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <name>Z_NO_FLUSH</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateReset</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>deflateResetKeep</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>lm_init</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateSetHeader</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>head</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>gz_headerp</name></type> <name>head</name></decl>;</decl_stmt>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePending</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>pending</name></type></decl></parameter>, <parameter><decl><type><name>bits</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>pending</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>bits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pending</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>pending</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>bits</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflatePrime</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>bits</name></type></decl></parameter>, <parameter><decl><type><name>value</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>put</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>Buf_size</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_BUF_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>put</name> <operator>=</operator> <name>Buf_size</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>put</name> <operator>&gt;</operator> <name>bits</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>put</name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_buf</name></name> <operator>|=</operator> <operator>(</operator><name>ush</name><operator>)</operator><operator>(</operator><operator>(</operator><name>value</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>put</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+=</operator> <name>put</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_flush_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>value</name> <operator>&gt;&gt;=</operator> <name>put</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bits</name> <operator>-=</operator> <name>put</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>bits</name></expr>)</condition>;</do>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateParams</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>level</name></type></decl></parameter>, <parameter><decl><type><name>strategy</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>compress_func</name></type> <name>func</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>level</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>level</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal> <operator>||</operator> <name><name>strategy</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>strategy</name></expr></argument> &gt;</argument_list></name> <name>Z_FIXED</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>func</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>strategy</name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>||</operator> <name>func</name> <operator>!=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>deflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BLOCK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>Z_STREAM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Z_BUF_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>!=</operator> <name>level</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>slide_hash</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>max_lazy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>good_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>nice_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>max_chain</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateTune</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>good_length</name></type></decl></parameter>, <parameter><decl><type><name>max_lazy</name></type></decl></parameter>, <parameter><decl><type><name>nice_length</name></type></decl></parameter>, <parameter><decl><type><name>max_chain</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>good_length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_lazy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nice_length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_chain</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>good_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>max_lazy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name> <operator>=</operator> <name>nice_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>max_chain</name></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>uLong</name> <name>ZEXPORT</name></type> <name>deflateBound</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>sourceLen</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uLong</name></type> <name>sourceLen</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uLong</name></type> <name>complen</name></decl>, <decl><type ref="prev"/><name>wraplen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>complen</name> <operator>=</operator> <name>sourceLen</name> <operator>+</operator>

<operator>(</operator><operator>(</operator><name>sourceLen</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>sourceLen</name> <operator>+</operator> <literal type="number">63</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>complen</name> <operator>+</operator> <literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">6</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wraplen</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><name>wraplen</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator></expr>)</condition>;</do></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><name>wraplen</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name><operator>++</operator></expr>)</condition>;</do></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wraplen</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<default>default:</default> 

<expr_stmt><expr><name>wraplen</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name> <operator>!=</operator> <literal type="number">15</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>!=</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>complen</name> <operator>+</operator> <name>wraplen</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>sourceLen</name> <operator>+</operator> <operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>+</operator>

<operator>(</operator><name>sourceLen</name> <operator>&gt;&gt;</operator> <literal type="number">25</literal><operator>)</operator> <operator>+</operator> <literal type="number">13</literal> <operator>-</operator> <literal type="number">6</literal> <operator>+</operator> <name>wraplen</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>local</name> <name>void</name></type> <name>putShortMSB</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>b</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>b</name></decl>;</decl_stmt>

<block>{<block_content>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name>b</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>local</name> <name>void</name></type> <name>flush_pending</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>_tr_flush_bits</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCRC_UPDATE</name><parameter_list>(<parameter><type><name>beg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; (beg)) strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + (beg), s-&gt;pending - (beg)); } while (0)</cpp:value></cpp:define>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflate</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>old_flush</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>flush</name> <operator>&gt;</operator> <name>Z_BLOCK</name> <operator>||</operator> <name>flush</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>

<operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>==</operator> <name>Z_NULL</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>FINISH_STATE</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>old_flush</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <name>flush</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RANK</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>RANK</name><argument_list>(<argument><expr><name>old_flush</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>FINISH_STATE</name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ERR_RETURN</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>INIT_STATE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uInt</name></type> <name>header</name> <init>= <expr><operator>(</operator><name>Z_DEFLATED</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>w_bits</name></name><operator>-</operator><literal type="number">8</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>level_flags</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>level_flags</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>header</name> <operator>|=</operator> <operator>(</operator><name>level_flags</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>header</name> <operator>|=</operator> <name>PRESET_DICT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>header</name> <operator>+=</operator> <literal type="number">31</literal> <operator>-</operator> <operator>(</operator><name>header</name> <operator>%</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>GZIP_STATE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">139</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:

<expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then>

<expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>OS_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>text</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>

<operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>

<operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>

<operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>

<operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name> <operator>==</operator> <name>Z_NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary><operator>)</operator></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:

<expr><operator>(</operator><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>&gt;=</operator> <name>Z_HUFFMAN_ONLY</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then>

<expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>os</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>EXTRA_STATE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>EXTRA_STATE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ulg</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name></type> <name>left</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra_len</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>+</operator> <name>left</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uInt</name></type> <name>copy</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>+=</operator> <name>copy</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>left</name> <operator>-=</operator> <name>copy</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>extra</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>+=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>NAME_STATE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>NAME_STATE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ulg</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>name</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>COMMENT_STATE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>COMMENT_STATE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name></name> <operator>!=</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ulg</name></type> <name>beg</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>comment</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>gzindex</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><call><name>HCRC_UPDATE</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>HCRC_STATE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>HCRC_STATE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>gzhead</name><operator>-&gt;</operator><name>hcrc</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>Z_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>BUSY_STATE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>

<operator>(</operator><name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>FINISH_STATE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>block_state</name></type> <name>bstate</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bstate</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>deflate_stored</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_HUFFMAN_ONLY</name></expr> ?</condition><then> <expr><call><name>deflate_huff</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_RLE</name></expr> ?</condition><then> <expr><call><name>deflate_rle</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator><operator>)</operator><operator>(</operator><name>s</name><operator>,</operator> <name>flush</name><operator>)</operator></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>finish_started</name> <operator>||</operator> <name>bstate</name> <operator>==</operator> <name>finish_done</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>FINISH_STATE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>need_more</name> <operator>||</operator> <name>bstate</name> <operator>==</operator> <name>finish_started</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bstate</name> <operator>==</operator> <name>block_done</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_PARTIAL_FLUSH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_tr_align</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_BLOCK</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FULL_FLUSH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_flush</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

<return>return <expr><name>Z_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>Byte</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putShortMSB</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name> <operator>=</operator> <operator>-</operator><name><name>s</name><operator>-&gt;</operator><name>wrap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Z_OK</name></expr> </then><else>: <expr><name>Z_STREAM_END</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateEnd</name> <parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TRY_FREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ZFREE</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>status</name> <operator>==</operator> <name>BUSY_STATE</name></expr> ?</condition><then> <expr><name>Z_DATA_ERROR</name></expr> </then><else>: <expr><name>Z_OK</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>deflateCopy</name> <parameter_list>(<parameter><decl><type><name>dest</name></type></decl></parameter>, <parameter><decl><type><name>source</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>dest</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>source</name></decl>;</decl_stmt>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAXSEG_64K</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ushf</name> <modifier>*</modifier></type><name>overlay</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>deflateStateCheck</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>dest</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>source</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>(</operator><name>deflate_state</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ds</name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator>struct <name>internal_state</name> <name>FAR</name> <operator>*</operator><operator>)</operator> <name>ds</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>ds</name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name>ss</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deflate_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>strm</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>Posf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>hash_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>overlay</name> <operator>=</operator> <operator>(</operator><name>ushf</name> <operator>*</operator><operator>)</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>=</operator> <operator>(</operator><name>uchf</name> <operator>*</operator><operator>)</operator> <name>overlay</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>ds</name><operator>-&gt;</operator><name>prev</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator> <name><name>ds</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>Z_NULL</name> <operator>||</operator>

<name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>==</operator> <name>Z_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>deflateEnd</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Z_MEM_ERROR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Byte</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ss</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>w_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><operator>(</operator><name>voidpf</name><operator>)</operator><name><name>ss</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>hash_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>pending_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><name><name>ds</name><operator>-&gt;</operator><name>pending_buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>pending_out</name></name> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>pending_buf</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name>overlay</name> <operator>+</operator> <name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>l_buf</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>pending_buf</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ush</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>*</operator><name><name>ds</name><operator>-&gt;</operator><name>lit_bufsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>l_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>dyn_ltree</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>d_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>dyn_dtree</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>bl_desc</name><operator>.</operator><name>dyn_tree</name></name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>bl_tree</name></name></expr>;</expr_stmt>

<return>return <expr><name>Z_OK</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></function>

<function><type><name>local</name> <name>unsigned</name></type> <name>read_buf</name><parameter_list>(<parameter><decl><type><name>strm</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>size</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>adler32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GZIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>wrap</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <call><name>crc32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>local</name> <name>void</name></type> <name>lm_init</name> <parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><literal type="number">2L</literal><operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>max_lazy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>good_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>good_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>nice_length</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name> <operator>=</operator> <name><name>configuration_table</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>level</name></name></expr>]</index></name><operator>.</operator><name>max_chain</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>match_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ASMV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>cur_match</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt> 

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>chain_length</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>max_chain_length</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>best_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>nice_match</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>nice_match</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>IPos</name></type> <name>limit</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;</operator> <operator>(</operator><name>IPos</name><operator>)</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <operator>(</operator><name>IPos</name><operator>)</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Posf</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>wmask</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>ush</name></type> <name>scan_start</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><name>scan</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>ush</name></type> <name>scan_end</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>Byte</name></type> <name>scan_end1</name> <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>Byte</name></type> <name>scan_end</name> <init>= <expr><name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal></expr></argument>, <argument><expr><literal type="string">"Code too clever"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>good_match</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chain_length</name> <operator>&gt;&gt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uInt</name><operator>)</operator><name>nice_match</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nice_match</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"need lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><literal type="string">"no future"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>cur_match</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal><operator>)</operator></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>scan_end</name> <operator>||</operator>

<operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><name>match</name> <operator>!=</operator> <name>scan_start</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name><name>match</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"scan[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scan</name><operator>++</operator></expr><operator>,</operator> <expr><name>match</name><operator>++</operator></expr>;</expr_stmt>

<do>do <block>{<block_content>

</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>==</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>match</name><operator>+=</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scan</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>MAX_MATCH</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name><operator>-</operator><name>scan</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>scan</name> <operator>=</operator> <name>strend</name> <operator>-</operator> <operator>(</operator><name>MAX_MATCH</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><name>best_len</name></expr>]</index></name> <operator>!=</operator> <name>scan_end</name> <operator>||</operator>

<name><name>match</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>scan_end1</name> <operator>||</operator>

<operator>*</operator><name>match</name> <operator>!=</operator> <operator>*</operator><name>scan</name> <operator>||</operator>

<operator>*</operator><operator>++</operator><name>match</name> <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scan</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>match</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr></argument>, <argument><expr><literal type="string">"match[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>scan</name> <operator>=</operator> <name>strend</name> <operator>-</operator> <name>MAX_MATCH</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>best_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>=</operator> <name>cur_match</name></expr>;</expr_stmt>

<expr_stmt><expr><name>best_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>nice_match</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNALIGNED_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>scan_end</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>ushf</name><operator>*</operator><operator>)</operator><operator>(</operator><name>scan</name><operator>+</operator><name>best_len</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>scan_end1</name> <operator>=</operator> <name><name>scan</name><index>[<expr><name>best_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>scan_end</name> <operator>=</operator> <name><name>scan</name><index>[<expr><name>best_len</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>cur_match</name> <operator>=</operator> <name><name>prev</name><index>[<expr><name>cur_match</name> <operator>&amp;</operator> <name>wmask</name></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <name>limit</name>

<operator>&amp;&amp;</operator> <operator>--</operator><name>chain_length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uInt</name><operator>)</operator><name>best_len</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>uInt</name><operator>)</operator><name>best_len</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><name>local</name> <name>uInt</name></type> <name>longest_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>cur_match</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IPos</name></type> <name>cur_match</name></decl>;</decl_stmt> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>register</specifier> <name>Bytef</name> <modifier>*</modifier></type><name>strend</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>hash_bits</name></name> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>MAX_MATCH</name> <operator>==</operator> <literal type="number">258</literal></expr></argument>, <argument><expr><literal type="string">"Code too clever"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"need lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur_match</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><literal type="string">"no future"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>cur_match</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>match</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>match</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>scan</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scan</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>match</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>scan</name> <operator>==</operator> <operator>*</operator><name>match</name></expr></argument>, <argument><expr><literal type="string">"match[2]?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>match</name> <operator>&amp;&amp;</operator>

<name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>MIN_MATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>MIN_MATCH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>=</operator> <name>cur_match</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>uInt</name><operator>)</operator><name>len</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>uInt</name><operator>)</operator><name>len</name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZLIB_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQUAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><name>local</name> <name>void</name></type> <name>check_match</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>start</name></type></decl></parameter>, <parameter><decl><type><name>match</name></type></decl></parameter>, <parameter><decl><type><name>length</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IPos</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>zmemcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>match</name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EQUAL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" start %u, match %u, length %d\n"</literal></expr></argument>,

<argument><expr><name>start</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c%c"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>match</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>start</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><call><name>z_error</name><argument_list>(<argument><expr><literal type="string">"invalid match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>z_verbose</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"\\[%d,%d]"</literal></expr></argument>, <argument><expr><name>start</name><operator>-</operator><name>match</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>start</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>--</operator><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_match</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>match</name></type></parameter>, <parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>local</name> <name>void</name></type> <name>fill_window</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>more</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name></type> <name>wsize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr></argument>, <argument><expr><literal type="string">"already enough lookahead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>more</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>more</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>more</name> <operator>=</operator> <name>wsize</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>more</name> <operator>==</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>more</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;=</operator> <name>wsize</name><operator>+</operator><call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><name>wsize</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>wsize</name> <operator>-</operator> <name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>-=</operator> <name>wsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-=</operator> <name>wsize</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>-=</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>wsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>slide_hash</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>more</name> <operator>+=</operator> <name>wsize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>more</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"more &lt; 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>, <argument><expr><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uInt</name></type> <name>str</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> <operator>!=</operator> <literal type="number">3</literal></expr></cpp:if>

<expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name><operator>-</operator><literal type="number">3</literal> <name>more</name> <name>times</name></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name>str</name> <operator>+</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev</name><index>[<expr><name>str</name> <operator>&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>w_mask</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>head</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Pos</name><operator>)</operator><name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ulg</name></type> <name>curr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <operator>(</operator><name>ulg</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ulg</name></type> <name>init</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name>curr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name>curr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init</name> <operator>&gt;</operator> <name>WIN_INIT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name>WIN_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name>curr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <name>curr</name> <operator>+</operator> <name>init</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>curr</name> <operator>+</operator> <name>WIN_INIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>init</name> <operator>=</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>curr</name> <operator>+</operator> <name>WIN_INIT</name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zmemzero</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>high_water</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>+=</operator> <name>init</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ulg</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name>MIN_LOOKAHEAD</name></expr></argument>,

<argument><expr><literal type="string">"not enough room for search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK_ONLY</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : (charf *)Z_NULL), (ulg)((long)s-&gt;strstart - s-&gt;block_start), (last)); s-&gt;block_start = s-&gt;strstart; flush_pending(s-&gt;strm); Tracev((stderr,"[FLUSH]")); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_BLOCK</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ FLUSH_BLOCK_ONLY(s, last); if (s-&gt;strm-&gt;avail_out == 0) return (last) ? finish_started : need_more; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_STORED</name></cpp:macro> <cpp:value>65535</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &gt; (b) ? (b) : (a))</cpp:value></cpp:define>

<function><type><name>local</name> <name>block_state</name></type> <name>deflate_stored</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>min_block</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>-</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>left</name></decl>, <decl><type ref="prev"/><name>have</name></decl>, <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>used</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>MAX_STORED</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>have</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+</operator> <literal type="number">42</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>&lt;</operator> <name>have</name></expr>)</condition><block type="pseudo"><block_content> 

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-</operator> <name>have</name></expr>;</expr_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>ulg</name><operator>)</operator><name>left</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>left</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>have</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>have</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>min_block</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name><operator>)</operator> <operator>||</operator>

<name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name> <operator>||</operator>

<name>len</name> <operator>!=</operator> <name>left</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <ternary><condition><expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>==</operator> <name>left</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>~</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>~</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZLIB_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>compressed_len</name></name> <operator>+=</operator> <name>len</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bits_sent</name></name> <operator>+=</operator> <name>len</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>left</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>left</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>+=</operator> <name>left</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>left</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><name>last</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><name>used</name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>used</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name>used</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>-</operator> <name>used</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name>used</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>+=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>used</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>insert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>finish_done</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>!=</operator> <name>Z_FINISH</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>block_done</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window_size</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;</operator> <name>have</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>&gt;=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zmemcpy</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>matches</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>have</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>have</name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>have</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>read_buf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name>have</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>high_water</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>have</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bi_valid</name></name> <operator>+</operator> <literal type="number">42</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>have</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pending_buf_size</name></name> <operator>-</operator> <name>have</name></expr></argument>, <argument><expr><name>MAX_STORED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>min_block</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>have</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>w_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;=</operator> <name>min_block</name> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>left</name> <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_FINISH</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>left</name> <operator>&lt;=</operator> <name>have</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <ternary><condition><expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<name>len</name> <operator>==</operator> <name>left</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_stored_block</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>charf</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>block_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>block_start</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_pending</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>strm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>last</name></expr> ?</condition><then> <expr><name>finish_started</name></expr> </then><else>: <expr><name>need_more</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>local</name> <name>block_state</name></type> <name>deflate_fast</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>need_more</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash_head</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hash_head</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name>hash_head</name> <operator>&lt;=</operator> <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>max_insert_length</name></name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name><operator>--</operator></expr>;</expr_stmt> 

<do>do <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UPDATE_HASH</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>ins_h</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIN_MATCH</name> <operator>!=</operator> <literal type="number">3</literal></expr></cpp:if>

<expr_stmt><expr><name>Call</name> <macro><name>UPDATE_HASH</name><argument_list>()</argument_list></macro> <name>MIN_MATCH</name><operator>-</operator><literal type="number">3</literal> <name>more</name> <name>times</name></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> </then><else>: <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>finish_done</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>block_done</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FASTEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>local</name> <name>block_state</name></type> <name>deflate_slow</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>IPos</name></type> <name>hash_head</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;</operator> <name>MIN_LOOKAHEAD</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>need_more</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash_head</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr><operator>,</operator> <expr><name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hash_head</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>max_lazy_match</name></name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name>hash_head</name> <operator>&lt;=</operator> <call><name>MAX_DIST</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <call><name>longest_match</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>Z_FILTERED</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TOO_FAR</name> <operator>&lt;=</operator> <literal type="number">32767</literal></expr></cpp:if>

<operator>||</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>==</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator>

<name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>match_start</name></name> <operator>&gt;</operator> <name>TOO_FAR</name><operator>)</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uInt</name></type> <name>max_insert</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_match</name></name></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;=</operator> <name>max_insert</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>INSERT_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name>hash_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>prev_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK_ONLY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>need_more</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>flush</name> <operator>!=</operator> <name>Z_NO_FLUSH</name></expr></argument>, <argument><expr><literal type="string">"no flush?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_lit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&lt;</operator> <name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr> </then><else>: <expr><name>MIN_MATCH</name><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>finish_done</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>block_done</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>local</name> <name>block_state</name></type> <name>deflate_rle</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name></type> <name>prev</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>scan</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>strend</name></decl>;</decl_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;=</operator> <name>MAX_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&lt;=</operator> <name>MAX_MATCH</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>need_more</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>*</operator><name>scan</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>strend</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+</operator> <name>MAX_MATCH</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

</block_content>}</block> while <condition>(<expr><name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>

<name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>

<name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>

<name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <operator>*</operator><operator>++</operator><name>scan</name> <operator>&amp;&amp;</operator>

<name>scan</name> <operator>&lt;</operator> <name>strend</name></expr>)</condition>;</do>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name>MAX_MATCH</name> <operator>-</operator> <operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name>strend</name> <operator>-</operator> <name>scan</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan</name> <operator>&lt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name></name><operator>+</operator><operator>(</operator><name>uInt</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>window_size</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"wild scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>&gt;=</operator> <name>MIN_MATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_dist</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>-</operator> <name>MIN_MATCH</name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>-=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>match_length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>finish_done</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>block_done</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>local</name> <name>block_state</name></type> <name>deflate_huff</name><parameter_list>(<parameter><decl><type><name>s</name></type></decl></parameter>, <parameter><decl><type><name>flush</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>deflate_state</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bflush</name></decl>;</decl_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fill_window</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_NO_FLUSH</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>need_more</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>match_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Tracevv</name><argument_list>(<argument><expr><operator>(</operator><name>stderr</name><operator>,</operator><literal type="string">"%c"</literal><operator>,</operator> <name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_tr_tally_lit</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>window</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bflush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>lookahead</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>strstart</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bflush</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>insert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>finish_done</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_lit</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FLUSH_BLOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>block_done</name></expr>;</return>

</block_content>}</block></function>

</unit>
