<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\shlr\heap\include\r_jemalloc\internal\ph.h"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { a_type *phn_prev; a_type *phn_next; a_type *phn_lchild; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { a_type *ph_root; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_lchild_get</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a_phn-&gt;a_field.phn_lchild)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_lchild_set</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>, <parameter><type><name>a_lchild</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_phn-&gt;a_field.phn_lchild = a_lchild; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_next_get</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a_phn-&gt;a_field.phn_next)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_prev_set</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>, <parameter><type><name>a_prev</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_phn-&gt;a_field.phn_prev = a_prev; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_prev_get</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a_phn-&gt;a_field.phn_prev)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_next_set</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>, <parameter><type><name>a_next</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_phn-&gt;a_field.phn_next = a_next; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_merge_ordered</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn0</name></type></parameter>, <parameter><type><name>a_phn1</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_type *phn0child; assert(a_phn0 != NULL); assert(a_phn1 != NULL); assert(a_cmp(a_phn0, a_phn1) &lt;= 0); phn_prev_set(a_type, a_field, a_phn1, a_phn0); phn0child = phn_lchild_get(a_type, a_field, a_phn0); phn_next_set(a_type, a_field, a_phn1, phn0child); if (phn0child != NULL) phn_prev_set(a_type, a_field, phn0child, a_phn1); phn_lchild_set(a_type, a_field, a_phn0, a_phn1); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>phn_merge</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn0</name></type></parameter>, <parameter><type><name>a_phn1</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>, <parameter><type><name>r_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (a_phn0 == NULL) r_phn = a_phn1; else if (a_phn1 == NULL) r_phn = a_phn0; else if (a_cmp(a_phn0, a_phn1) &lt; 0) { phn_merge_ordered(a_type, a_field, a_phn0, a_phn1, a_cmp); r_phn = a_phn0; } else { phn_merge_ordered(a_type, a_field, a_phn1, a_phn0, a_cmp); r_phn = a_phn1; } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph_merge_siblings</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>, <parameter><type><name>r_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_type *head = NULL; a_type *tail = NULL; a_type *phn0 = a_phn; a_type *phn1 = phn_next_get(a_type, a_field, phn0); if (phn1 != NULL) { a_type *phnrest = phn_next_get(a_type, a_field, phn1); if (phnrest != NULL) phn_prev_set(a_type, a_field, phnrest, NULL); phn_prev_set(a_type, a_field, phn0, NULL); phn_next_set(a_type, a_field, phn0, NULL); phn_prev_set(a_type, a_field, phn1, NULL); phn_next_set(a_type, a_field, phn1, NULL); phn_merge(a_type, a_field, phn0, phn1, a_cmp, phn0); head = tail = phn0; phn0 = phnrest; while (phn0 != NULL) { phn1 = phn_next_get(a_type, a_field, phn0); if (phn1 != NULL) { phnrest = phn_next_get(a_type, a_field, phn1); if (phnrest != NULL) { phn_prev_set(a_type, a_field, phnrest, NULL); } phn_prev_set(a_type, a_field, phn0, NULL); phn_next_set(a_type, a_field, phn0, NULL); phn_prev_set(a_type, a_field, phn1, NULL); phn_next_set(a_type, a_field, phn1, NULL); phn_merge(a_type, a_field, phn0, phn1, a_cmp, phn0); phn_next_set(a_type, a_field, tail, phn0); tail = phn0; phn0 = phnrest; } else { phn_next_set(a_type, a_field, tail, phn0); tail = phn0; phn0 = NULL; } } phn0 = head; phn1 = phn_next_get(a_type, a_field, phn0); if (phn1 != NULL) { while (true) { head = phn_next_get(a_type, a_field, phn1); assert(phn_prev_get(a_type, a_field, phn0) == NULL); phn_next_set(a_type, a_field, phn0, NULL); assert(phn_prev_get(a_type, a_field, phn1) == NULL); phn_next_set(a_type, a_field, phn1, NULL); phn_merge(a_type, a_field, phn0, phn1, a_cmp, phn0); if (head == NULL) break; phn_next_set(a_type, a_field, tail, phn0); tail = phn0; phn0 = head; phn1 = phn_next_get(a_type, a_field, phn0); } } } r_phn = phn0; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph_merge_aux</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_ph</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_type *phn = phn_next_get(a_type, a_field, a_ph-&gt;ph_root); if (phn != NULL) { phn_prev_set(a_type, a_field, a_ph-&gt;ph_root, NULL); phn_next_set(a_type, a_field, a_ph-&gt;ph_root, NULL); phn_prev_set(a_type, a_field, phn, NULL); ph_merge_siblings(a_type, a_field, phn, a_cmp, phn); assert(phn_next_get(a_type, a_field, phn) == NULL); phn_merge(a_type, a_field, a_ph-&gt;ph_root, phn, a_cmp, a_ph-&gt;ph_root); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph_merge_children</name><parameter_list>(<parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_phn</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>, <parameter><type><name>r_phn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a_type *lchild = phn_lchild_get(a_type, a_field, a_phn); if (lchild == NULL) r_phn = NULL; else { ph_merge_siblings(a_type, a_field, lchild, a_cmp, r_phn); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph_proto</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_prefix</name></type></parameter>, <parameter><type><name>a_ph_type</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr void a_prefix##new(a_ph_type *ph); a_attr bool a_prefix##empty(a_ph_type *ph); a_attr a_type *a_prefix##first(a_ph_type *ph); a_attr void a_prefix##insert(a_ph_type *ph, a_type *phn); a_attr a_type *a_prefix##remove_first(a_ph_type *ph); a_attr void a_prefix##remove(a_ph_type *ph, a_type *phn);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ph_gen</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_prefix</name></type></parameter>, <parameter><type><name>a_ph_type</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_field</name></type></parameter>, <parameter><type><name>a_cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr void a_prefix##new(a_ph_type *ph) { memset(ph, 0, sizeof(ph(a_type))); } a_attr bool a_prefix##empty(a_ph_type *ph) { return (ph-&gt;ph_root == NULL); } a_attr a_type * a_prefix##first(a_ph_type *ph) { if (ph-&gt;ph_root == NULL) return (NULL); ph_merge_aux(a_type, a_field, ph, a_cmp); return (ph-&gt;ph_root); } a_attr void a_prefix##insert(a_ph_type *ph, a_type *phn) { memset(&amp;phn-&gt;a_field, 0, sizeof(phn(a_type))); if (ph-&gt;ph_root == NULL) ph-&gt;ph_root = phn; else { phn_next_set(a_type, a_field, phn, phn_next_get(a_type, a_field, ph-&gt;ph_root)); if (phn_next_get(a_type, a_field, ph-&gt;ph_root) != NULL) { phn_prev_set(a_type, a_field, phn_next_get(a_type, a_field, ph-&gt;ph_root), phn); } phn_prev_set(a_type, a_field, phn, ph-&gt;ph_root); phn_next_set(a_type, a_field, ph-&gt;ph_root, phn); } } a_attr a_type * a_prefix##remove_first(a_ph_type *ph) { a_type *ret; if (ph-&gt;ph_root == NULL) return (NULL); ph_merge_aux(a_type, a_field, ph, a_cmp); ret = ph-&gt;ph_root; ph_merge_children(a_type, a_field, ph-&gt;ph_root, a_cmp, ph-&gt;ph_root); return (ret); } a_attr void a_prefix##remove(a_ph_type *ph, a_type *phn) { a_type *replace, *parent; if (ph-&gt;ph_root == phn) { ph_merge_aux(a_type, a_field, ph, a_cmp); if (ph-&gt;ph_root == phn) { ph_merge_children(a_type, a_field, ph-&gt;ph_root, a_cmp, ph-&gt;ph_root); return; } } if ((parent = phn_prev_get(a_type, a_field, phn)) != NULL) { if (phn_lchild_get(a_type, a_field, parent) != phn) parent = NULL; } ph_merge_children(a_type, a_field, phn, a_cmp, replace); if (replace != NULL) { if (parent != NULL) { phn_prev_set(a_type, a_field, replace, parent); phn_lchild_set(a_type, a_field, parent, replace); } else { phn_prev_set(a_type, a_field, replace, phn_prev_get(a_type, a_field, phn)); if (phn_prev_get(a_type, a_field, phn) != NULL) { phn_next_set(a_type, a_field, phn_prev_get(a_type, a_field, phn), replace); } } phn_next_set(a_type, a_field, replace, phn_next_get(a_type, a_field, phn)); if (phn_next_get(a_type, a_field, phn) != NULL) { phn_prev_set(a_type, a_field, phn_next_get(a_type, a_field, phn), replace); } } else { if (parent != NULL) { a_type *next = phn_next_get(a_type, a_field, phn); phn_lchild_set(a_type, a_field, parent, next); if (next != NULL) { phn_prev_set(a_type, a_field, next, parent); } } else { assert(phn_prev_get(a_type, a_field, phn) != NULL); phn_next_set(a_type, a_field, phn_prev_get(a_type, a_field, phn), phn_next_get(a_type, a_field, phn)); } if (phn_next_get(a_type, a_field, phn) != NULL) { phn_prev_set(a_type, a_field, phn_next_get(a_type, a_field, phn), phn_prev_get(a_type, a_field, phn)); } } }</cpp:value></cpp:define>

</unit>
