<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\shlr\heap\include\r_jemalloc\internal\tsd.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_H_TYPES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_TSD_CLEANUPS_MAX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>malloc_tsd_cleanup_t</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<typedef>typedef <type><name><name>struct</name> <name>tsd_init_block_s</name></name></type> <name>tsd_init_block_t</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>tsd_init_head_s</name></name></type> <name>tsd_init_head_t</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>tsd_s</name></name></type> <name>tsd_t</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>tsdn_s</name></name></type> <name>tsdn_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSDN_NULL</name></cpp:macro> <cpp:value>((tsdn_t *)0)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{

<decl><name>tsd_state_uninitialized</name></decl>,

<decl><name>tsd_state_nominal</name></decl>,

<decl><name>tsd_state_purgatory</name></decl>,

<decl><name>tsd_state_reincarnated</name></decl>

}</block></enum></type> <name>tsd_state_t</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_types</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_types</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_types</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typedef struct { bool initialized; a_type val; } a_name##tsd_wrapper_t;</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_types</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typedef struct { bool initialized; a_type val; } a_name##tsd_wrapper_t;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_protos</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr bool a_name##tsd_boot0(void); a_attr void a_name##tsd_boot1(void); a_attr bool a_name##tsd_boot(void); a_attr bool a_name##tsd_booted_get(void); a_attr a_type * a_name##tsd_get(bool init); a_attr void a_name##tsd_set(a_type *val);</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_externs</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern __thread a_type a_name##tsd_tls; extern __thread bool a_name##tsd_initialized; extern bool a_name##tsd_booted;</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_externs</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern __thread a_type a_name##tsd_tls; extern pthread_key_t a_name##tsd_tsd; extern bool a_name##tsd_booted;</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_externs</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern DWORD a_name##tsd_tsd; extern a_name##tsd_wrapper_t a_name##tsd_boot_wrapper; extern bool a_name##tsd_booted;</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_externs</name><parameter_list>(<parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern pthread_key_t a_name##tsd_tsd; extern tsd_init_head_t a_name##tsd_init_head; extern a_name##tsd_wrapper_t a_name##tsd_boot_wrapper; extern bool a_name##tsd_booted;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_data</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr __thread a_type JEMALLOC_TLS_MODEL a_name##tsd_tls = a_initializer; a_attr __thread bool JEMALLOC_TLS_MODEL a_name##tsd_initialized = false; a_attr bool a_name##tsd_booted = false;</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_data</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr __thread a_type JEMALLOC_TLS_MODEL a_name##tsd_tls = a_initializer; a_attr pthread_key_t a_name##tsd_tsd; a_attr bool a_name##tsd_booted = false;</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_data</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr DWORD a_name##tsd_tsd; a_attr a_name##tsd_wrapper_t a_name##tsd_boot_wrapper = { false, a_initializer }; a_attr bool a_name##tsd_booted = false;</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_data</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr pthread_key_t a_name##tsd_tsd; a_attr tsd_init_head_t a_name##tsd_init_head = { ql_head_initializer(blocks), MALLOC_MUTEX_INITIALIZER }; a_attr a_name##tsd_wrapper_t a_name##tsd_boot_wrapper = { false, a_initializer }; a_attr bool a_name##tsd_booted = false;</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_funcs</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>, <parameter><type><name>a_cleanup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr bool a_name##tsd_cleanup_wrapper(void) { if (a_name##tsd_initialized) { a_name##tsd_initialized = false; a_cleanup(&amp;a_name##tsd_tls); } return (a_name##tsd_initialized); } a_attr bool a_name##tsd_boot0(void) { if (a_cleanup != malloc_tsd_no_cleanup) { malloc_tsd_cleanup_register( &amp;a_name##tsd_cleanup_wrapper); } a_name##tsd_booted = true; return (false); } a_attr void a_name##tsd_boot1(void) { } a_attr bool a_name##tsd_boot(void) { return (a_name##tsd_boot0()); } a_attr bool a_name##tsd_booted_get(void) { return (a_name##tsd_booted); } a_attr bool a_name##tsd_get_allocates(void) { return (false); } a_attr a_type * a_name##tsd_get(bool init) { assert(a_name##tsd_booted); return (&amp;a_name##tsd_tls); } a_attr void a_name##tsd_set(a_type *val) { assert(a_name##tsd_booted); a_name##tsd_tls = (*val); if (a_cleanup != malloc_tsd_no_cleanup) a_name##tsd_initialized = true; }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_funcs</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>, <parameter><type><name>a_cleanup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr bool a_name##tsd_boot0(void) { if (a_cleanup != malloc_tsd_no_cleanup) { if (pthread_key_create(&amp;a_name##tsd_tsd, a_cleanup) != 0) return (true); } a_name##tsd_booted = true; return (false); } a_attr void a_name##tsd_boot1(void) { } a_attr bool a_name##tsd_boot(void) { return (a_name##tsd_boot0()); } a_attr bool a_name##tsd_booted_get(void) { return (a_name##tsd_booted); } a_attr bool a_name##tsd_get_allocates(void) { return (false); } a_attr a_type * a_name##tsd_get(bool init) { assert(a_name##tsd_booted); return (&amp;a_name##tsd_tls); } a_attr void a_name##tsd_set(a_type *val) { assert(a_name##tsd_booted); a_name##tsd_tls = (*val); if (a_cleanup != malloc_tsd_no_cleanup) { if (pthread_setspecific(a_name##tsd_tsd, (void *)(&amp;a_name##tsd_tls))) { malloc_write("&lt;jemalloc&gt;: Error" " setting TSD for "#a_name"\n"); if (opt_abort) abort(); } } }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_funcs</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>, <parameter><type><name>a_cleanup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr bool a_name##tsd_cleanup_wrapper(void) { DWORD error = GetLastError(); a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *) TlsGetValue(a_name##tsd_tsd); SetLastError(error); if (wrapper == NULL) return (false); if (a_cleanup != malloc_tsd_no_cleanup &amp;&amp; wrapper-&gt;initialized) { wrapper-&gt;initialized = false; a_cleanup(&amp;wrapper-&gt;val); if (wrapper-&gt;initialized) { return (true); } } malloc_tsd_dalloc(wrapper); return (false); } a_attr void a_name##tsd_wrapper_set(a_name##tsd_wrapper_t *wrapper) { if (!TlsSetValue(a_name##tsd_tsd, (void *)wrapper)) { malloc_write("&lt;jemalloc&gt;: Error setting" " TSD for "#a_name"\n"); abort(); } } a_attr a_name##tsd_wrapper_t * a_name##tsd_wrapper_get(bool init) { DWORD error = GetLastError(); a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *) TlsGetValue(a_name##tsd_tsd); SetLastError(error); if (init &amp;&amp; unlikely(wrapper == NULL)) { wrapper = (a_name##tsd_wrapper_t *) malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t)); if (wrapper == NULL) { malloc_write("&lt;jemalloc&gt;: Error allocating" " TSD for "#a_name"\n"); abort(); } else { wrapper-&gt;initialized = false; wrapper-&gt;val = a_initializer; } a_name##tsd_wrapper_set(wrapper); } return (wrapper); } a_attr bool a_name##tsd_boot0(void) { a_name##tsd_tsd = TlsAlloc(); if (a_name##tsd_tsd == TLS_OUT_OF_INDEXES) return (true); if (a_cleanup != malloc_tsd_no_cleanup) { malloc_tsd_cleanup_register( &amp;a_name##tsd_cleanup_wrapper); } a_name##tsd_wrapper_set(&amp;a_name##tsd_boot_wrapper); a_name##tsd_booted = true; return (false); } a_attr void a_name##tsd_boot1(void) { a_name##tsd_wrapper_t *wrapper; wrapper = (a_name##tsd_wrapper_t *) malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t)); if (wrapper == NULL) { malloc_write("&lt;jemalloc&gt;: Error allocating" " TSD for "#a_name"\n"); abort(); } memcpy(wrapper, &amp;a_name##tsd_boot_wrapper, sizeof(a_name##tsd_wrapper_t)); a_name##tsd_wrapper_set(wrapper); } a_attr bool a_name##tsd_boot(void) { if (a_name##tsd_boot0()) return (true); a_name##tsd_boot1(); return (false); } a_attr bool a_name##tsd_booted_get(void) { return (a_name##tsd_booted); } a_attr bool a_name##tsd_get_allocates(void) { return (true); } a_attr a_type * a_name##tsd_get(bool init) { a_name##tsd_wrapper_t *wrapper; assert(a_name##tsd_booted); wrapper = a_name##tsd_wrapper_get(init); if (a_name##tsd_get_allocates() &amp;&amp; !init &amp;&amp; wrapper == NULL) return (NULL); return (&amp;wrapper-&gt;val); } a_attr void a_name##tsd_set(a_type *val) { a_name##tsd_wrapper_t *wrapper; assert(a_name##tsd_booted); wrapper = a_name##tsd_wrapper_get(true); wrapper-&gt;val = *(val); if (a_cleanup != malloc_tsd_no_cleanup) wrapper-&gt;initialized = true; }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc_tsd_funcs</name><parameter_list>(<parameter><type><name>a_attr</name></type></parameter>, <parameter><type><name>a_name</name></type></parameter>, <parameter><type><name>a_type</name></type></parameter>, <parameter><type><name>a_initializer</name></type></parameter>, <parameter><type><name>a_cleanup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a_attr void a_name##tsd_cleanup_wrapper(void *arg) { a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)arg; if (a_cleanup != malloc_tsd_no_cleanup &amp;&amp; wrapper-&gt;initialized) { wrapper-&gt;initialized = false; a_cleanup(&amp;wrapper-&gt;val); if (wrapper-&gt;initialized) { if (pthread_setspecific(a_name##tsd_tsd, (void *)wrapper)) { malloc_write("&lt;jemalloc&gt;: Error" " setting TSD for "#a_name"\n"); if (opt_abort) abort(); } return; } } malloc_tsd_dalloc(wrapper); } a_attr void a_name##tsd_wrapper_set(a_name##tsd_wrapper_t *wrapper) { if (pthread_setspecific(a_name##tsd_tsd, (void *)wrapper)) { malloc_write("&lt;jemalloc&gt;: Error setting" " TSD for "#a_name"\n"); abort(); } } a_attr a_name##tsd_wrapper_t * a_name##tsd_wrapper_get(bool init) { a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *) pthread_getspecific(a_name##tsd_tsd); if (init &amp;&amp; unlikely(wrapper == NULL)) { tsd_init_block_t block; wrapper = (a_name##tsd_wrapper_t *) tsd_init_check_recursion(&amp;a_name##tsd_init_head, &amp;block); if (wrapper) return (wrapper); wrapper = (a_name##tsd_wrapper_t *) malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t)); block.data = (void *)wrapper; if (wrapper == NULL) { malloc_write("&lt;jemalloc&gt;: Error allocating" " TSD for "#a_name"\n"); abort(); } else { wrapper-&gt;initialized = false; wrapper-&gt;val = a_initializer; } a_name##tsd_wrapper_set(wrapper); tsd_init_finish(&amp;a_name##tsd_init_head, &amp;block); } return (wrapper); } a_attr bool a_name##tsd_boot0(void) { if (pthread_key_create(&amp;a_name##tsd_tsd, a_name##tsd_cleanup_wrapper) != 0) return (true); a_name##tsd_wrapper_set(&amp;a_name##tsd_boot_wrapper); a_name##tsd_booted = true; return (false); } a_attr void a_name##tsd_boot1(void) { a_name##tsd_wrapper_t *wrapper; wrapper = (a_name##tsd_wrapper_t *) malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t)); if (wrapper == NULL) { malloc_write("&lt;jemalloc&gt;: Error allocating" " TSD for "#a_name"\n"); abort(); } memcpy(wrapper, &amp;a_name##tsd_boot_wrapper, sizeof(a_name##tsd_wrapper_t)); a_name##tsd_wrapper_set(wrapper); } a_attr bool a_name##tsd_boot(void) { if (a_name##tsd_boot0()) return (true); a_name##tsd_boot1(); return (false); } a_attr bool a_name##tsd_booted_get(void) { return (a_name##tsd_booted); } a_attr bool a_name##tsd_get_allocates(void) { return (true); } a_attr a_type * a_name##tsd_get(bool init) { a_name##tsd_wrapper_t *wrapper; assert(a_name##tsd_booted); wrapper = a_name##tsd_wrapper_get(init); if (a_name##tsd_get_allocates() &amp;&amp; !init &amp;&amp; wrapper == NULL) return (NULL); return (&amp;wrapper-&gt;val); } a_attr void a_name##tsd_set(a_type *val) { a_name##tsd_wrapper_t *wrapper;</cpp:value></cpp:define> 

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a_name</name><operator>#</operator><operator>#</operator><name>tsd_booted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> \

<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <name>a_name</name><operator>#</operator><operator>#</operator><call><name>tsd_wrapper_get</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> \

<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>val</name><operator>)</operator></expr>;</expr_stmt> \

<if_stmt><if>if <condition>(<expr><name>a_cleanup</name> <operator>!=</operator> <name>malloc_tsd_no_cleanup</name></expr>)</condition><block type="pseudo"><block_content> \

<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> \

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_H_STRUCTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

struct <macro><name>tsd_init_block_s</name></macro> <block>{<block_content>

<macro><name>ql_elm</name><argument_list>(<argument>tsd_init_block_t</argument>)</argument_list></macro> <expr_stmt><expr><name>link</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>pthread_t</name></type> <name>thread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

</block_content>}</block><empty_stmt>;</empty_stmt>

<struct>struct <name>tsd_init_head_s</name> <block>{

<macro><name>ql_head</name><argument_list>(<argument>tsd_init_block_t</argument>)</argument_list></macro> <expr_stmt><expr><name>blocks</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>malloc_mutex_t</name></type> <name>lock</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_TSD</name></cpp:macro> <cpp:value>O(tcache, tcache_t *) O(thread_allocated, uint64_t) O(thread_deallocated, uint64_t) O(prof_tdata, prof_tdata_t *) O(iarena, arena_t *) O(arena, arena_t *) O(arenas_tdata, arena_tdata_t *) O(narenas_tdata, unsigned) O(arenas_tdata_bypass, bool) O(tcache_enabled, tcache_enabled_t) O(quarantine, quarantine_t *) O(witnesses, witness_list_t) O(witness_fork, bool)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSD_INITIALIZER</name></cpp:macro> <cpp:value>{ tsd_state_uninitialized, NULL, 0, 0, NULL, NULL, NULL, NULL, 0, false, tcache_enabled_default, NULL, ql_head_initializer(witnesses), false }</cpp:value></cpp:define>

<struct>struct <name>tsd_s</name> <block>{

<decl_stmt><decl><type><name>tsd_state_t</name></type> <name>state</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t n;</cpp:value></cpp:define>

<expr_stmt><expr><name>MALLOC_TSD</name></expr></expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>O</name></cpp:undef>

}</block>;</struct>

<struct>struct <name>tsdn_s</name> <block>{

<decl_stmt><decl><type><name>tsd_t</name></type> <name>tsd</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>tsd_t</name></type> <name>tsd_initializer</name> <init>= <expr><name>TSD_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<macro><name>malloc_tsd_types</name><argument_list>(<argument/>, <argument>tsd_t</argument>)</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_H_EXTERNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>malloc_tsd_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>malloc_tsd_dalloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>wrapper</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>malloc_tsd_no_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>malloc_tsd_cleanup_register</name><parameter_list>(<parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>malloc_tsd_boot0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>malloc_tsd_boot1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_MALLOC_THREAD_CLEANUP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TLS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>tsd_init_check_recursion</name><parameter_list>(<parameter><decl><type><name>tsd_init_head_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>,

<parameter><decl><type><name>tsd_init_block_t</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>tsd_init_finish</name><parameter_list>(<parameter><decl><type><name>tsd_init_head_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>tsd_init_block_t</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type> <name>tsd_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_H_INLINES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_ENABLE_INLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>malloc_tsd_protos</name><argument_list>(<argument>JEMALLOC_ATTR(unused)</argument>, <argument/>, <argument>tsd_t</argument>)</argument_list></macro>

<function_decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd_fetch_impl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd_fetch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsd_tsdn</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>tsd_nominal</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t *tsd_##n##p_get(tsd_t *tsd); t tsd_##n##_get(tsd_t *tsd); void tsd_##n##_set(tsd_t *tsd, t n);</cpp:value></cpp:define>

<function_decl><type><name>MALLOC_TSD</name>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>O</name></cpp:undef>

<name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn_fetch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>tsdn_null</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsdn_tsd</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_ENABLE_INLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_TSD_C_</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<macro><name>malloc_tsd_externs</name><argument_list>(<argument/>, <argument>tsd_t</argument>)</argument_list></macro>

<macro><name>malloc_tsd_funcs</name><argument_list>(<argument>JEMALLOC_ALWAYS_INLINE</argument>, <argument/>, <argument>tsd_t</argument>, <argument>tsd_initializer</argument>, <argument>tsd_cleanup</argument>)</argument_list></macro>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>tsd_t</name> <modifier>*</modifier></type>

<name>tsd_fetch_impl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_get</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>init</name> <operator>&amp;&amp;</operator> <call><name>tsd_get_allocates</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>tsd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>tsd</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr></return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>tsd_state_nominal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>tsd_state_uninitialized</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>tsd_state_nominal</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>tsd_state_purgatory</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>tsd_state_reincarnated</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tsd_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>tsd_state_reincarnated</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>tsd</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>tsd_t</name> <modifier>*</modifier></type>

<name>tsd_fetch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><call><name>tsd_fetch_impl</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>tsdn_t</name> <modifier>*</modifier></type>

<name>tsd_tsdn</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>tsd</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>JEMALLOC_INLINE</name> <name>bool</name></type>

<name>tsd_nominal</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name><name>tsd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>tsd_state_nominal</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>JEMALLOC_ALWAYS_INLINE t * tsd_##n##p_get(tsd_t *tsd) { return (&amp;tsd-&gt;n); } JEMALLOC_ALWAYS_INLINE t tsd_##n##_get(tsd_t *tsd) { return (*tsd_##n##p_get(tsd)); } JEMALLOC_ALWAYS_INLINE void tsd_##n##_set(tsd_t *tsd, t n) { assert(tsd-&gt;state == tsd_state_nominal); tsd-&gt;n = n; }</cpp:value></cpp:define>

<function><type><name>MALLOC_TSD</name>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>O</name></cpp:undef>

<name>JEMALLOC_ALWAYS_INLINE</name> <name>tsdn_t</name> <modifier>*</modifier></type>

<name>tsdn_fetch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tsd_booted_get</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>tsd_tsdn</name><argument_list>(<argument><expr><call><name>tsd_fetch_impl</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>bool</name></type>

<name>tsdn_null</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>tsdn</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>JEMALLOC_ALWAYS_INLINE</name> <name>tsd_t</name> <modifier>*</modifier></type>

<name>tsdn_tsd</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><operator>&amp;</operator><name><name>tsdn</name><operator>-&gt;</operator><name>tsd</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
