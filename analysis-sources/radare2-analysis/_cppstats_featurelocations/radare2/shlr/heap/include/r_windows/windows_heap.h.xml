<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\shlr\heap\include\r_windows\windows_heap.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WINDOWS_HEAP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWS_HEAP_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winternl.h&gt;</cpp:file></cpp:include>



















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_FLAG</name></cpp:macro> <cpp:value>(1ULL &lt;&lt; (sizeof (size_t) * 8 - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LFH_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LARGE_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT + 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT + 2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGMENT_HEAP_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT + 3))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VS_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT + 4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_BLOCK</name></cpp:macro> <cpp:value>(1 &lt;&lt; (SHIFT + 5))</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>_HEAP_LOCAL_DATA</name></name> <modifier>*</modifier></type><name>PHEAP_LOCAL_DATA</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>_HEAP_SUBSEGMENT</name></name> <modifier>*</modifier></type><name>PHEAP_SUBSEGMENT</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>_LFH_HEAP</name></name> <modifier>*</modifier></type><name>PLFH_HEAP</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>_HEAP</name></name> <modifier>*</modifier></type><name>PHEAP</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>_RTL_BALANCED_NODE</name></name> <modifier>*</modifier></type><name>PRTL_BALANCED_NODE</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_RTL_BALANCED_NODE</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name><name>Children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>Left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>Right</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>Red</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>Balance</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>ParentValue</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>RTL_BALANCED_NODE</name><operator>,</operator> *<name>PRTL_BALANCED_NODE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_RB_TREE</name> <block>{
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>Root</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>BOOL</name></type> <name>Encoded</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>Min</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>RTL_RB_TREE</name><operator>,</operator> *<name>PRTL_RB_TREE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_COUNTERS</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalMemoryReserved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalMemoryCommitted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalMemoryLargeUCR</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalSizeInVirtualBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>TotalSegments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>TotalUCRs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>CommittOps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>DeCommitOps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>LockAcquires</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>LockCollisions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>CommitRate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>DecommittRate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>CommitFailures</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>InBlockCommitFailures</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>PollIntervalCounter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>DecommitsSinceLastCheck</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>HeapPollInterval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>AllocAndFreeOps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>AllocationIndicesActive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>InBlockDeccommits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>InBlockDeccomitSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>HighWatermarkSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>LastPolledSize</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_COUNTERS</name><operator>,</operator> *<name>PHEAP_COUNTERS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_BUCKET_COUNTERS</name> <block>{
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>TotalBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>SubSegmentCounts</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>Aggregate64</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_BUCKET_COUNTERS</name><operator>,</operator> *<name>PHEAP_BUCKET_COUNTERS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_INTERLOCK_SEQ</name> <block>{ 
<union>union <block>{
<decl_stmt><decl><type><name>WORD</name></type> <name>Depth</name></decl>;</decl_stmt>
<union>union <block>{
<union>union <block>{
<decl_stmt><decl><type><name>WORD</name></type> <name>Hint</name> <range>: <expr><literal type="number">15</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WORD</name></type> <name>Lock</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>WORD</name></type> <name>Hint16</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>INT32</name></type> <name>Exchg</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>INTERLOCK_SEQ</name><operator>,</operator> *<name>PINTERLOCK_SEQ</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_UNPACKED_ENTRY</name> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PVOID</name></type> <name>PreviousBlockPrivateData</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SmallTagIndex</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SubSegmentCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>PreviousSize</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT8</name></type> <name>SegmentOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>LFHFlags</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT8</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>CompactHeader</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SubSegmentCode</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</union>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT16</name></type> <name>PreviousSize</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT8</name></type> <name>SegmentOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>LFHFlags</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT8</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>HEAP_UNPACKED_ENTRY</name><operator>,</operator> *<name>PHEAP_UNPACKED_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_EXTENDED_ENTRY</name> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Reserved</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>FunctionIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>ContextValue</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>InterceptorValue</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT16</name></type> <name>UnusedBytesLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>EntryOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>ExtendedBlockSignature</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_EXTENDED_ENTRY</name><operator>,</operator> *<name>PHEAP_EXTENDED_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_ENTRY</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>HEAP_UNPACKED_ENTRY</name></type> <name>UnpackedEntry</name></decl>;</decl_stmt>
<struct>struct <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PVOID</name></type> <name>PreviousBlockPrivateData</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SmallTagIndex</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SubSegmentCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>PreviousSize</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT8</name></type> <name>SegmentOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>LFHFlags</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT8</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>CompactHeader</name></decl>;</decl_stmt>
}</block>;</union>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SmallTagIndex</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SubSegmentCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>PreviousSize</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT8</name></type> <name>SegmentOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>LFHFlags</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT8</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>HEAP_EXTENDED_ENTRY</name></type> <name>ExtendedEntry</name></decl>;</decl_stmt>
<struct>struct <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Reserved</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>FunctionIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>ContextValue</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>InterceptorValue</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>UINT16</name></type> <name>UnusedBytesLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>EntryOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>ExtendedBlockSignature</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>UINT16</name></type> <name>FunctionIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>ContextValue</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<struct>struct <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ReservedForAlignment</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Code1</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>Code2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Code3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Code4</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Code234</name></decl>;</decl_stmt>
}</block>;</union>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>AgregateCode</name></decl>;</decl_stmt>
}</block>;</union>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>InterceptorValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>UnusedBytesLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>EntryOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>ExtendedBlockSignature</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Code1</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>Code2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Code3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Code4</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Code234</name></decl>;</decl_stmt>
}</block>;</union>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>AgregateCode</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</union>
}</block></struct></type> <name>HEAP_ENTRY</name><operator>,</operator> *<name>PHEAP_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LOCK</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>RTL_CRITICAL_SECTION</name></type> <name>CriticalSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Resource</name></decl>;</decl_stmt>
}</block> <decl><name>Lock</name></decl>;</union>
}</block></struct></type> <name>HEAP_LOCK</name><operator>,</operator> *<name>PHEAP_LOCK</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_TAG_ENTRY</name> <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Allocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Frees</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>TagIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>CreatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WCHAR</name></type> <name><name>TagName</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING0_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>HEAP_TAG_ENTRY</name><operator>,</operator> *<name>PHEAP_TAG_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_PSEUDO_TAG_ENTRY</name> <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Allocs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Frees</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Size</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_PSEUDO_TAG_ENTRY</name><operator>,</operator> *<name>PHEAP_PSEUDO_TAG_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_TUNING_PARAMETERS</name> <block>{
<decl_stmt><decl><type><name>ULONG32</name></type> <name>CommittThresholdShift</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING0_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>MaxPreCommittThreshold</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_TUNING_PARAMETERS</name><operator>,</operator> *<name>PHEAP_TUNING_PARAMETERS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_HEAP_MEMORY_LIMIT_DATA</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitLimitBytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitLimitFailureCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>MaxAllocationSizeBytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>AllocationLimitFailureCode</name></decl>;</decl_stmt>
}</block></struct></type> <name>RTL_HEAP_MEMORY_LIMIT_DATA</name><operator>,</operator> *<name>PRTL_HEAP_MEMORY_LIMIT_DATA</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_HP_ENV_HANDLE</name> <block>{
<decl_stmt><decl><type><name>PVOID</name></type> <name><name>h</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RTL_HP_ENV_HANDLE</name><operator>,</operator> *<name>PRTL_HP_ENV_HANDLE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_HP_SEG_ALLOC_POLICY</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>MinLargePages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>MaxLargePages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>MinUtilization</name></decl>;</decl_stmt>
}</block></struct></type> <name>RTL_HP_SEG_ALLOC_POLICY</name><operator>,</operator> *<name>PRTL_HP_SEG_ALLOC_POLICY</name>;</typedef>

<typedef>typedef <type><enum>enum <name>_RTLP_HP_LOCK_TYPE</name> <block>{
<decl><name>HeapLockPaged</name></decl>,
<decl><name>HeapLockNonPaged</name></decl>,
<decl><name>HeapLockTypeMax</name></decl>
}</block></enum></type> <name>RTLP_HP_LOCK_TYPE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_SUBALLOCATOR_CALLBACKS</name> <block>{
<decl_stmt><decl><type><name>PVOID</name></type> <name>Allocate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Free</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Commit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Decommit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ExtendContext</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_SUBALLOCATOR_CALLBACKS</name><operator>,</operator> *<name>PHEAP_SUBALLOCATOR_CALLBACKS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_HP_VS_CONFIG</name> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>PageAlignLargeAllocs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>FullDecommit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block> <decl><name>Flags</name></decl>;</struct>
}</block></struct></type> <name>RTL_HP_VS_CONFIG</name><operator>,</operator> *<name>PRTL_HP_VS_CONFIG</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_VS_SUBSEGMENT</name> <block>{
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>ListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitBitmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Signature</name> <range>: <expr><literal type="number">15</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>FullCommit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Spare</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_VS_SUBSEGMENT</name><operator>,</operator> *<name>PHEAP_VS_SUBSEGMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_VS_CONTEXT</name> <block>{
<decl_stmt><decl><type><name>RTL_SRWLOCK</name></type> <name>Lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>LockType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_RB_TREE</name></type> <name>FreeChunkTree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SubsegmentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalCommittedUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>FreeCommittedUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name><name>DelayFreeContext</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>PVOID</name></type> <name>BackendCtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_SUBALLOCATOR_CALLBACKS</name></type> <name>Callbacks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_HP_VS_CONFIG</name></type> <name>Config</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Padding</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_VS_CONTEXT</name><operator>,</operator> *<name>PHEAP_VS_CONTEXT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_VS_CHUNK_HEADER_SIZE</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>HeaderBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>KeyUShort</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>KeyULong</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>USHORT</name></type> <name>MemoryCost</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>UnsafeSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>UnsafePrevSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Allocated</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
}</block></struct></type> <name>HEAP_VS_CHUNK_HEADER_SIZE</name><operator>,</operator> *<name>PHEAP_VS_CHUNK_HEADER_SIZE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_VS_CHUNK_HEADER</name> <block>{
<decl_stmt><decl><type><name>HEAP_VS_CHUNK_HEADER_SIZE</name></type> <name>Sizes</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>EncodedSegmentPageOffset</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>UnusedBytes</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>SkipDuringWalk</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Spare</name> <range>: <expr><literal type="number">22</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>AllocatedChunkBits</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_VS_CHUNK_HEADER</name><operator>,</operator> *<name>PHEAP_VS_CHUNK_HEADER</name>;</typedef>

<enum>enum <block>{
<decl><name>PAGE_RANGE_FLAGS_LFH_SUBSEGMENT</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<decl><name>PAGE_RANGE_FLAGS_COMMITED</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>PAGE_RANGE_FLAGS_ALLOCATED</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>PAGE_RANGE_FLAGS_FIRST</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
<decl><name>PAGE_RANGE_FLAGS_VS_SUBSEGMENT</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl> 
}</block>;</enum>

<typedef>typedef <type><struct>struct <name>_HEAP_PAGE_RANGE_DESCRIPTOR</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>RTL_BALANCED_NODE</name></type> <name>TreeNode</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>TreeSignature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
}</block>;</struct>
<union>union <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>ExtraPresent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Spare0</name> <range>: <expr><literal type="number">15</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
}</block>;</union>
<decl_stmt><decl><type><name>UCHAR</name></type> <name>RangeFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UCHAR</name></type> <name>CommittedPageCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>Spare</name></decl>;</decl_stmt>
<union>union <block>{

<decl_stmt><decl><type><name>UCHAR</name></type> <name><name>Align</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>UCHAR</name></type> <name>UnitOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UCHAR</name></type> <name>UnitSize</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_PAGE_RANGE_DESCRIPTOR</name><operator>,</operator> *<name>PHEAP_PAGE_RANGE_DESCRIPTOR</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_PAGE_SEGMENT</name> <block>{
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>ListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Signature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>SegmentCommitState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UCHAR</name></type> <name>UnusedWatermark</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>HEAP_PAGE_RANGE_DESCRIPTOR</name></type> <name><name>DescArray</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_PAGE_SEGMENT</name><operator>,</operator> *<name>PHEAP_PAGE_SEGMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_HP_LFH_CONFIG</name> <block>{
<decl_stmt><decl><type><name>USHORT</name></type> <name>MaxBlockSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>WitholdPageCrossingBlocks</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block></struct></type> <name>RTL_HP_LFH_CONFIG</name><operator>,</operator> *<name>PRTL_HP_LFH_CONFIG</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_SUBSEGMENT_STAT</name> <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>Index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>Count</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_SUBSEGMENT_STAT</name><operator>,</operator> *<name>PHEAP_LFH_SUBSEGMENT_STAT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_SUBSEGMENT_STATS</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT_STAT</name></type> <name><name>Buckets</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT64</name></type> <name>Stats</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_LFH_SUBSEGMENT_STATS</name><operator>,</operator> *<name>PHEAP_LFH_SUBSEGMENT_STATS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_SUBSEGMENT_OWNER</name> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>IsBucket</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>Spare0</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>BYTE</name></type> <name>BucketIndex</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>SlotCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>SlotIndex</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>BYTE</name></type> <name>Spare1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>AvailableSubsegmentCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_SRWLOCK</name></type> <name>Lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>AvailableSubsegmentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>FullSubsegmentList</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_SUBSEGMENT_OWNER</name><operator>,</operator> *<name>PHEAP_LFH_SUBSEGMENT_OWNER</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_FAST_REF</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>PVOID</name></type> <name>Target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>RefCount</name> <range>: <expr><literal type="number">12</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_LFH_FAST_REF</name><operator>,</operator> *<name>PHEAP_LFH_FAST_REF</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_AFFINITY_SLOT</name> <block>{
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT_OWNER</name></type> <name>State</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_FAST_REF</name></type> <name>ActiveSubsegment</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_AFFINITY_SLOT</name><operator>,</operator> *<name>PHEAP_LFH_AFFINITY_SLOT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_BUCKET</name> <block>{
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT_OWNER</name></type> <name>State</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalBlockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalSubsegmentCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT</name></type> <name>ReciprocalBlockSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>ContentionCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>AffinityMappingLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PUINT8</name></type> <name>ProcAffinityMapping</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_LFH_AFFINITY_SLOT</name> <modifier>*</modifier></type><name>AffinitySlots</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_BUCKET</name><operator>,</operator> *<name>PHEAP_LFH_BUCKET</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_CONTEXT</name> <block>{
<decl_stmt><decl><type><name>PVOID</name></type> <name>BackendCtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_SUBALLOCATOR_CALLBACKS</name></type> <name>Callbacks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PUINT8</name></type> <name>AffinityModArray</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>MaxAffinity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>LockType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>MemStatsOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_HP_LFH_CONFIG</name></type> <name>Config</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT_STATS</name></type> <name>BucketStats</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SubsegmentCreationLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name><name>Padding</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_LFH_BUCKET</name></type> <name><name>Buckets</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_CONTEXT</name><operator>,</operator> *<name>PHEAP_LFH_CONTEXT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>UINT32</name></type> <name>EncodedData</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>BlockSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>FirstBlockOffset</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
}</block></struct></type> <name>HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</name><operator>,</operator> *<name>PHEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_SUBSEGMENT</name> <block>{
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>ListEntry</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>PHEAP_LFH_SUBSEGMENT_OWNER</name></type> <name>Owner</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>DelayFree</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitLock</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>FreeCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>BlockCount</name></decl>;</decl_stmt>
}</block>;</struct>
<union>union <block>{
<decl_stmt><decl><type><name>SHORT</name></type> <name>InterlockedShort</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LONG</name></type> <name>InterlockedLong</name></decl>;</decl_stmt>
}</block>;</union>
}</block>;</union>
<decl_stmt><decl><type><name>UINT16</name></type> <name>FreeHint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>Location</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>WitheldBlockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</name></type> <name>BlockOffsets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>CommitUnitShift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>CommitUnitCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>CommitStateOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name><name>BlockBitmap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LFH_SUBSEGMENT</name><operator>,</operator> *<name>PHEAP_LFH_SUBSEGMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LARGE_ALLOC_DATA</name> <block>{
<decl_stmt><decl><type><name>RTL_BALANCED_NODE</name></type> <name>TreeNode</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>VirtualAddess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>UnusedBytes</name></decl>;</decl_stmt>
}</block>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>UINT64</name></type> <name>BitMask</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>ExtraPresent</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>GuardPageCount</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>GuardPageAlignment</name> <range>: <expr><literal type="number">6</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>Spare</name> <range>: <expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT64</name></type> <name>AllocatedPages</name> <range>: <expr><literal type="number">52</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
}</block>;</union>
}</block></struct></type> <name>HEAP_LARGE_ALLOC_DATA</name><operator>,</operator> *<name>PHEAP_LARGE_ALLOC_DATA</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SmallPagesInUseWithinLarge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>OpportunisticLargePageCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS</name><operator>,</operator> *<name>PHEAP_OPPORTUNISTIC_LARGE_PAGE_STATS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_RUNTIME_MEMORY_STATS</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalReservedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>FreeCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>LfhFreeCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_OPPORTUNISTIC_LARGE_PAGE_STATS</name></type> <name><name>LargePageStats</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_HP_SEG_ALLOC_POLICY</name></type> <name>LargePageUtilizationPolicy</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_RUNTIME_MEMORY_STATS</name><operator>,</operator> *<name>PHEAP_RUNTIME_MEMORY_STATS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_SEG_CONTEXT</name> <block>{
<decl_stmt><decl><type><name>UINT64</name></type> <name>SegmentMask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>UnitShift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>PagesPerUnitShift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>FirstDescriptorIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>CachedCommitSoftShift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>CachedCommitHighShift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT</name></type> <name>MaxAllocationSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>OlpStatsOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>MemStatsOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>LfhContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>VsContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_HP_ENV_HANDLE</name></type> <name>EnvHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Heap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SegmentLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SegmentListHead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SegmentCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_RB_TREE</name></type> <name>FreePageRanges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>FreeSegmentListLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SINGLE_LIST_ENTRY</name></type> <name><name>FreeSegmentList</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name><name>Padding</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_SEG_CONTEXT</name><operator>,</operator> *<name>PHEAP_SEG_CONTEXT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_SEGMENT_HEAP</name> <block>{
<decl_stmt><decl><type><name>RTL_HP_ENV_HANDLE</name></type> <name>EnvHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Signature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>GlobalFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Interceptor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>ProcessHeapListIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>AllocatedFromMetadata</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>RTL_HEAP_MEMORY_LIMIT_DATA</name></type> <name>CommitLimitData</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT64</name></type> <name>ReservedMustBeZero1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>UserContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ReservedMustBeZero2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Spare</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
<decl_stmt><decl><type><name>RTL_SRWLOCK</name></type> <name>LargeMetadataLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_RB_TREE</name></type> <name>LargeAllocMetadata</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>WPARAM</name></type> <name>LargeReservedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>LargeCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_RUN_ONCE</name></type> <name>StackTraceInitVar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name><name>Padding</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_RUNTIME_MEMORY_STATS</name></type> <name>MemStats</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>GlobalLockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>GlobalLockOwner</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_SRWLOCK</name></type> <name>ContextExtendLock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PUINT8</name></type> <name>AllocatedBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PUINT8</name></type> <name>UncommittedBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PUINT8</name></type> <name>ReservedLimit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_SEG_CONTEXT</name></type> <name><name>SegContexts</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_VS_CONTEXT</name></type> <name>VsContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_CONTEXT</name></type> <name>LfhContext</name></decl>;</decl_stmt>
}</block></struct></type> <name>SEGMENT_HEAP</name><operator>,</operator> *<name>PSEGMENT_HEAP</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_SEGMENT</name> <block>{
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>Entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SegmentSignature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SegmentFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SegmentListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP</name></type> <name>Heap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>BaseAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfPages</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING0_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PHEAP_ENTRY</name></type> <name>FirstEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_ENTRY</name></type> <name>LastValidEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfUnCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfUnCommittedRanges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>SegmentAllocatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Reserved</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING1_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>UCRSegmentList</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_SEGMENT</name><operator>,</operator> *<name>PHEAP_SEGMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>HEAP_SEGMENT</name></type> <name>Segment</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>Entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SegmentSignature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>SegmentFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SegmentListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP</name></type> <name>Heap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>BaseAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_ENTRY</name></type> <name>FirstEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_ENTRY</name></type> <name>LastValidEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfUnCommittedPages</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NumberOfUnCommittedRanges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>SegmentAllocatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>Reserved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>UCRSegmentList</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>ForceFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>CompatibilityFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>EncodeFlagMask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>Encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Interceptor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>VirtualMemoryThreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>Signature</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING0_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SegmentReserve</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SegmentCommit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>DeCommitFreeBlockThreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>DeCommitTotalFreeThreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>TotalFreeSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>MaximumAllocationSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>ProcessHeapsListIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>HeaderValidateLength</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING1_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PVOID</name></type> <name>HeaderValidateCopy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>NextAvailableTagIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>MaximumTagIndex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING2_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PHEAP_TAG_ENTRY</name></type> <name>TagEntries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>UCRList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>AlignRound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>AlignMask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>VirtualAllocdBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SegmentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>AllocatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING03_</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG32</name></type> <name>NonDedicatedListLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>BlocksIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>UCRIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_PSEUDO_TAG_ENTRY</name></type> <name>PseudoTagEntries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>FreeLists</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_LOCK</name></type> <name>LockVariable</name></decl>;</decl_stmt>
<function_decl><type><name>LONG32</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>CommitRoutine</name>) <parameter_list>(<parameter><decl><type><name>PVOID</name></type></decl></parameter>, <parameter><decl><type><name>PVOID</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>WPARAM</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>RTL_RUN_ONCE</name></type> <name>StackTraceInitVar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_HEAP_MEMORY_LIMIT_DATA</name></type> <name>CommitLimitData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>FrontEndHeap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>FrontHeapLockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>FrontEndHeapType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>RequestedFrontEndHeapType</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING4_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PUINT16</name></type> <name>FrontEndHeapUsageData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>FrontEndHeapMaximumIndex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>FrontEndHeapStatusBitmap</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>FrontEndHeapStatusBitmap</name><index>[<expr><literal type="number">257</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING5_</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING1_</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>HEAP_COUNTERS</name></type> <name>Counters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_TUNING_PARAMETERS</name></type> <name>TuningParameters</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP</name><operator>,</operator> *<name>PHEAP</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_ENTRY_EXTRA</name> <block>{
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>AllocatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>TagIndex</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT8</name></type> <name><name>_PADDING0_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>Settable</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT64</name></type> <name>ZeroInit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT64</name></type> <name>ZeroInit1</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>UINT64</name></type> <name>ZeroInit</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</union>
}</block></struct></type> <name>HEAP_ENTRY_EXTRA</name><operator>,</operator> *<name>PHEAP_ENTRY_EXTRA</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_VIRTUAL_ALLOC_ENTRY</name> <block>{
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>Entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY_EXTRA</name></type> <name>ExtraStuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>CommitSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>ReserveSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>BusyBlock</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_VIRTUAL_ALLOC_ENTRY</name><operator>,</operator> *<name>PHEAP_VIRTUAL_ALLOC_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_LFH_BLOCK_ZONE</name> <block>{
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>ListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LONG</name></type> <name>NextIndex</name></decl>;</decl_stmt>




}</block></struct></type> <name>LFH_BLOCK_ZONE</name><operator>,</operator> *<name>PLFH_BLOCK_ZONE</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_USERDATA_OFFSETS</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>UINT32</name></type> <name>StrideAndOffset</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>UINT16</name></type> <name>FirstAllocationOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>BlockStride</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
}</block></struct></type> <name>HEAP_USERDATA_OFFSETS</name><operator>,</operator> *<name>PHEAP_USERDATA_OFFSETS</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_RTL_BITMAP_EX</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SizeOfBitMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name> <modifier>*</modifier></type><name>Buffer</name></decl>;</decl_stmt>
}</block></struct></type> <name>RTL_BITMAP_EX</name><operator>,</operator> *<name>PRTL_BITMAP_EX</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_USERDATA_HEADER</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>SINGLE_LIST_ENTRY</name></type> <name>SFreeListEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_SUBSEGMENT</name></type> <name>SubSegment</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Reserved</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT32</name></type> <name>SizeIndexAndPadding</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>UCHAR</name></type> <name>SizeIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UCHAR</name></type> <name>GuardPagePresent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>PaddingBytes</name></decl>;</decl_stmt>
}</block>;</struct>
}</block>;</union>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Signature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_USERDATA_OFFSETS</name></type> <name>EncodedOffsets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTL_BITMAP_EX</name></type> <name>BusyBitmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>BitmapData</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_USERDATA_HEADER</name><operator>,</operator> *<name>PHEAP_USERDATA_HEADER</name>;</typedef>


<typedef>typedef <type><name><name>struct</name> <name>_HEAP_SUBSEGMENT</name></name> <modifier>*</modifier></type><name>PHEAP_SUBSEGMENT</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_HEAP_LOCAL_SEGMENT_INFO</name> <block>{
<decl_stmt><decl><type><name>PHEAP_LOCAL_DATA</name></type> <name>LocalData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_SUBSEGMENT</name></type> <name>ActiveSubsegment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_SUBSEGMENT</name></type> <name><name>CachedItems</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLIST_HEADER</name></type> <name>SListHeader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_BUCKET_COUNTERS</name></type> <name>Counters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>LastOpSequence</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>BucketIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>LastUsed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT16</name></type> <name>NoThrashCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_LOCAL_SEGMENT_INFO</name><operator>,</operator> *<name>PHEAP_LOCAL_SEGMENT_INFO</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_SUBSEGMENT</name> <block>{
<decl_stmt><decl><type><name>PHEAP_LOCAL_SEGMENT_INFO</name></type> <name>LocalInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_USERDATA_HEADER</name></type> <name>UserBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLIST_HEADER</name></type> <name>DelayFreeList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>INTERLOCK_SEQ</name></type> <name>AggregateExchg</name></decl>;</decl_stmt>
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>WORD</name></type> <name>BlockSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WORD</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WORD</name></type> <name>BlockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SizeIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>AffinityIndex</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ULONG</name></type> <name><name>Alignment</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SINGLE_LIST_ENTRY</name></type> <name>SFreeListEntry</name></decl>;</decl_stmt>
}</block></struct></type> <name>HEAP_SUBSEGMENT</name><operator>,</operator> *<name>PHEAP_SUBSEGMENT</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LFH_MEM_POLICIES</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>AllPolicies</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>UINT8</name></type> <name>DisableAffinity</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SlowSubsegmentGrowth</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Spare</name> <range>: <expr><literal type="number">30</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
}</block>;</union>
}</block></struct></type> <name>HEAP_LFH_MEM_POLICIES</name><operator>,</operator> *<name>PHEAP_LFH_MEM_POLICIES</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_LOCAL_DATA</name> <block>{
<decl_stmt><decl><type><name>SLIST_HEADER</name></type> <name>DeletedSubSegments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PLFH_BLOCK_ZONE</name></type> <name>CrtZone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PLFH_HEAP</name></type> <name>LowFragHeap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>Sequence</name></decl>;</decl_stmt>

}</block></struct></type> <name>HEAP_LOCAL_DATA</name><operator>,</operator> *<name>PHEAP_LOCAL_DATA</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_BUCKET</name> <block>{
<decl_stmt><decl><type><name>WORD</name></type> <name>BlockUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT8</name></type> <name>SizeIndex</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>Flags</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>BYTE</name></type> <name>UseAffinity</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BYTE</name></type> <name>DebugFlags</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
}</block>;</union>
}</block>;</union>
}</block></struct></type> <name>HEAP_BUCKET</name><operator>,</operator> *<name>PHEAP_BUCKET</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HEAP_BUCKET_RUN_INFO</name> <block>{
<union>union <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>ULONG</name></type> <name>Bucket</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>RunLength</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>UINT64</name></type> <name>Aggregate64</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HEAP_BUCKET_RUN_INFO</name><operator>,</operator> *<name>PHEAP_BUCKET_RUN_INFO</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_USER_MEMORY_CACHE_ENTRY</name> <block>{
<decl_stmt><decl><type><name>SLIST_HEADER</name></type> <name>UserBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>AvailableBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>MinimumDepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>CacheShiftThreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>Allocations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>Frees</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>CacheHits</name></decl>;</decl_stmt>
}</block></struct></type> <name>USER_MEMORY_CACHE_ENTRY</name><operator>,</operator> *<name>PUSER_MEMORY_CACHE_ENTRY</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_LFH_HEAP</name> <block>{
<decl_stmt><decl><type><name>RTL_SRWLOCK</name></type> <name>Lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>SubSegmentZones</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Heap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>NextSegmentInfoArrayAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>FirstUncommittedAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ReservedAddressLimit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>SegmentCreate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>SegmentDelete</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>MinimumCacheDepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>CacheShiftThreshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SizeInCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_BUCKET_RUN_INFO</name></type> <name>RunInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USER_MEMORY_CACHE_ENTRY</name></type> <name><name>UserBlockCache</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_MEM_POLICIES</name></type> <name>MemoryPolicies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_BUCKET</name></type> <name><name>Buckets</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_LOCAL_SEGMENT_INFO</name></type> <name><name>SegmentInfoArrays</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHEAP_LOCAL_SEGMENT_INFO</name></type> <name><name>AffinitizedInfoArrays</name><index>[<expr><literal type="number">129</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PSEGMENT_HEAP</name></type> <name>SegmentAllocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LOCAL_DATA</name></type> <name><name>LocalData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>LFH_HEAP</name><operator>,</operator> *<name>PLFH_HEAP</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HeapBlockBasicInfo</name> <block>{
<decl_stmt><decl><type><name>WPARAM</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>extra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>address</name></decl>;</decl_stmt>
}</block></struct></type> <name>HeapBlockBasicInfo</name><operator>,</operator> *<name>PHeapBlockBasicInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HeapBlockExtraInfo</name> <block>{ 
<decl_stmt><decl><type><name>WPARAM</name></type> <name>heap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>segment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>unusedBytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>granularity</name></decl>;</decl_stmt>
}</block></struct></type> <name>HeapBlockExtraInfo</name><operator>,</operator> *<name>PHeapBlockExtraInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HeapBlock</name> <block>{
<decl_stmt><decl><type><name>ULONG_PTR</name></type> <name>dwAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>dwSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>dwFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extraInfo</name></decl>;</decl_stmt>
}</block></struct></type> <name>HeapBlock</name><operator>,</operator> *<name>PHeapBlock</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_DEBUG_BUFFER</name> <block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>SectionHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>SectionBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>RemoteSectionBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>SectionBaseDelta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>EventPairHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>RemoteEventPairHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>RemoteProcessId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>RemoteThreadHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>InfoClassMask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>SizeOfInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>AllocatedSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>SectionSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ModuleInformation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>BackTraceInformation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>HeapInformation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>LockInformation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>SpecificHeap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>RemoteProcessHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>VerifierOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>ProcessHeap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>CriticalSectionHandle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>CriticalSectionOwnerThread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name><name>Reserved</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>DEBUG_BUFFER</name><operator>,</operator> *<name>PDEBUG_BUFFER</name>;</typedef>


<typedef>typedef <type><struct>struct <name>_DEBUG_HEAP_INFORMATION</name> <block>{
<decl_stmt><decl><type><name>PVOID</name></type> <name>Base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>Granularity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>USHORT</name></type> <name>CreatorBackTraceIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>Allocated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>Committed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>TagCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>BlockCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>PseudoTagCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>PseudoTagGranularity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name><name>Reserved</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Tags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>Blocks</name></decl>;</decl_stmt>
}</block></struct></type> <name>DEBUG_HEAP_INFORMATION</name><operator>,</operator> *<name>PDEBUG_HEAP_INFORMATION</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_HeapInformation</name> <block>{
<decl_stmt><decl><type><name>DWORD</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DEBUG_HEAP_INFORMATION</name></type> <name><name>heaps</name><index>[]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>HeapInformation</name><operator>,</operator> *<name>PHeapInformation</name>;</typedef>

<function_decl><type><name>PDEBUG_BUFFER</name></type> (<name>NTAPI</name> <modifier>*</modifier><name>RtlCreateQueryDebugBuffer</name>)<parameter_list>(
<parameter><decl><type><name>IN</name> <name>DWORD</name></type> <name>Size</name></decl></parameter>,
<parameter><decl><type><name>IN</name> <name>BOOLEAN</name></type> <name>EventPair</name></decl></parameter>
)</parameter_list>;</function_decl>

<function_decl><type><name>NTSTATUS</name></type> (<name>NTAPI</name> <modifier>*</modifier><name>RtlQueryProcessDebugInformation</name>)<parameter_list>(
<parameter><decl><type><name>IN</name> <name>DWORD</name></type> <name>ProcessId</name></decl></parameter>,
<parameter><decl><type><name>IN</name> <name>DWORD</name></type> <name>DebugInfoClassMask</name></decl></parameter>,
<parameter><decl><type><name>IN</name> <name>OUT</name> <name>PDEBUG_BUFFER</name></type> <name>DebugBuffer</name></decl></parameter>
)</parameter_list>;</function_decl>

<function_decl><type><name>NTSTATUS</name></type> (<name>NTAPI</name> <modifier>*</modifier><name>RtlDestroyQueryDebugBuffer</name>)<parameter_list>(
<parameter><decl><type><name>IN</name> <name>PDEBUG_BUFFER</name></type> <name>DebugBuffer</name></decl></parameter>
)</parameter_list>;</function_decl>

<function_decl><type><name>__kernel_entry</name> <name>NTSTATUS</name></type> (<name>NTAPI</name> <modifier>*</modifier><name>w32_NtQueryInformationProcess</name>)<parameter_list>(
<parameter><decl><type><name>IN</name> <name>HANDLE</name></type> <name>ProcessHandle</name></decl></parameter>,
<parameter><decl><type><name>IN</name> <name>PROCESSINFOCLASS</name></type> <name>ProcessInformationClass</name></decl></parameter>,
<parameter><decl><type><name>OUT</name> <name>PVOID</name></type> <name>ProcessInformation</name></decl></parameter>,
<parameter><decl><type><name>IN</name> <name>ULONG</name></type> <name>ProcessInformationLength</name></decl></parameter>,
<parameter><decl><type><name>OUT</name> <name>PULONG</name></type> <name>ReturnLength</name></decl></parameter>
)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif></unit>
