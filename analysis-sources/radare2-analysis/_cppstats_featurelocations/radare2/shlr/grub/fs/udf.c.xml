<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\shlr\grub\fs\udf.c">


















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/mm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/misc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/disk.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/dl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/fshelp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grub/charset.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_MAX_PDS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_MAX_PMS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U16</name></cpp:macro> <cpp:value>grub_le_to_cpu16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U32</name></cpp:macro> <cpp:value>grub_le_to_cpu32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U64</name></cpp:macro> <cpp:value>grub_le_to_cpu64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_LOG2_BLKSZ</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_BLKSZ</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_PVD</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_AVDP</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_VDP</name></cpp:macro> <cpp:value>0x0003</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_IUVD</name></cpp:macro> <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_PD</name></cpp:macro> <cpp:value>0x0005</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_LVD</name></cpp:macro> <cpp:value>0x0006</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_USD</name></cpp:macro> <cpp:value>0x0007</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_TD</name></cpp:macro> <cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_LVID</name></cpp:macro> <cpp:value>0x0009</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_FSD</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_FID</name></cpp:macro> <cpp:value>0x0101</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_AED</name></cpp:macro> <cpp:value>0x0102</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_IE</name></cpp:macro> <cpp:value>0x0103</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_TE</name></cpp:macro> <cpp:value>0x0104</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_FE</name></cpp:macro> <cpp:value>0x0105</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_EAHD</name></cpp:macro> <cpp:value>0x0106</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_USE</name></cpp:macro> <cpp:value>0x0107</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_SBD</name></cpp:macro> <cpp:value>0x0108</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_PIE</name></cpp:macro> <cpp:value>0x0109</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_TAG_IDENT_EFE</name></cpp:macro> <cpp:value>0x010A</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_UNDEF</name></cpp:macro> <cpp:value>0x00</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_USE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_PIE</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_IE</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_DIRECTORY</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_REGULAR</name></cpp:macro> <cpp:value>0x05</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_BLOCK</name></cpp:macro> <cpp:value>0x06</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_CHAR</name></cpp:macro> <cpp:value>0x07</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_EA</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_FIFO</name></cpp:macro> <cpp:value>0x09</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_SOCKET</name></cpp:macro> <cpp:value>0x0A</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_TE</name></cpp:macro> <cpp:value>0x0B</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_SYMLINK</name></cpp:macro> <cpp:value>0x0C</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_TYPE_STREAMDIR</name></cpp:macro> <cpp:value>0x0D</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_FLAG_AD_MASK</name></cpp:macro> <cpp:value>0x0007</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_FLAG_AD_SHORT</name></cpp:macro> <cpp:value>0x0000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_FLAG_AD_LONG</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_FLAG_AD_EXT</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_ICBTAG_FLAG_AD_IN_ICB</name></cpp:macro> <cpp:value>0x0003</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_EXT_NORMAL</name></cpp:macro> <cpp:value>0x00000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_EXT_NREC_ALLOC</name></cpp:macro> <cpp:value>0x40000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_EXT_NREC_NALLOC</name></cpp:macro> <cpp:value>0x80000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_EXT_MASK</name></cpp:macro> <cpp:value>0xC0000000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_FID_CHAR_HIDDEN</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_FID_CHAR_DIRECTORY</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_FID_CHAR_DELETED</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_FID_CHAR_PARENT</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_FID_CHAR_METADATA</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_BEA01</name></cpp:macro> <cpp:value>"BEA01"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_BOOT2</name></cpp:macro> <cpp:value>"BOOT2"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_CD001</name></cpp:macro> <cpp:value>"CD001"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_CDW02</name></cpp:macro> <cpp:value>"CDW02"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_NSR02</name></cpp:macro> <cpp:value>"NSR02"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_NSR03</name></cpp:macro> <cpp:value>"NSR03"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_STD_IDENT_TEA01</name></cpp:macro> <cpp:value>"TEA01"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS0</name></cpp:macro> <cpp:value>0x00</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS1</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS2</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS3</name></cpp:macro> <cpp:value>0x03</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS4</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS5</name></cpp:macro> <cpp:value>0x05</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS6</name></cpp:macro> <cpp:value>0x06</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS7</name></cpp:macro> <cpp:value>0x07</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_CHARSPEC_TYPE_CS8</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_PARTMAP_TYPE_1</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRUB_UDF_PARTMAP_TYPE_2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_lb_addr
{
grub_uint32_t block_num;
grub_uint16_t part_ref;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_short_ad
{
grub_uint32_t length;
grub_uint32_t position;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_long_ad
{
grub_uint32_t length;
struct grub_udf_lb_addr block;
grub_uint8_t imp_use[<literal type="number">6</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_extent_ad
{
grub_uint32_t length;
grub_uint32_t start;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_charspec
{
grub_uint8_t charset_type;
grub_uint8_t charset_info[<literal type="number">63</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_timestamp
{
grub_uint16_t type_and_timezone;
grub_uint16_t year;
grub_uint8_t month;
grub_uint8_t day;
grub_uint8_t hour;
grub_uint8_t minute;
grub_uint8_t second;
grub_uint8_t centi_seconds;
grub_uint8_t hundreds_of_micro_seconds;
grub_uint8_t micro_seconds;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_regid
{
grub_uint8_t flags;
grub_uint8_t ident[<literal type="number">23</literal>];
grub_uint8_t ident_suffix[<literal type="number">8</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_tag
{
grub_uint16_t tag_ident;
grub_uint16_t desc_version;
grub_uint8_t tag_checksum;
grub_uint8_t reserved;
grub_uint16_t tag_serial_number;
grub_uint16_t desc_crc;
grub_uint16_t desc_crc_length;
grub_uint32_t tag_location;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_fileset
{
struct grub_udf_tag tag;
struct grub_udf_timestamp datetime;
grub_uint16_t interchange_level;
grub_uint16_t max_interchange_level;
grub_uint32_t charset_list;
grub_uint32_t max_charset_list;
grub_uint32_t fileset_num;
grub_uint32_t fileset_desc_num;
struct grub_udf_charspec vol_charset;
grub_uint8_t vol_ident[<literal type="number">128</literal>];
struct grub_udf_charspec fileset_charset;
grub_uint8_t fileset_ident[<literal type="number">32</literal>];
grub_uint8_t copyright_file_ident[<literal type="number">32</literal>];
grub_uint8_t abstract_file_ident[<literal type="number">32</literal>];
struct grub_udf_long_ad root_icb;
struct grub_udf_regid domain_ident;
struct grub_udf_long_ad next_ext;
struct grub_udf_long_ad streamdir_icb;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_icbtag
{
grub_uint32_t prior_recorded_num_direct_entries;
grub_uint16_t strategy_type;
grub_uint16_t strategy_parameter;
grub_uint16_t num_entries;
grub_uint8_t reserved;
grub_uint8_t file_type;
struct grub_udf_lb_addr parent_idb;
grub_uint16_t flags;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_file_ident
{
struct grub_udf_tag tag;
grub_uint16_t version_num;
grub_uint8_t characteristics;
grub_uint8_t file_ident_length;
struct grub_udf_long_ad icb;
grub_uint16_t imp_use_length;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_file_entry
{
struct grub_udf_tag tag;
struct grub_udf_icbtag icbtag;
grub_uint32_t uid;
grub_uint32_t gid;
grub_uint32_t permissions;
grub_uint16_t link_count;
grub_uint8_t record_format;
grub_uint8_t record_display_attr;
grub_uint32_t record_length;
grub_uint64_t file_size;
grub_uint64_t blocks_recorded;
struct grub_udf_timestamp access_time;
struct grub_udf_timestamp modification_time;
struct grub_udf_timestamp attr_time;
grub_uint32_t checkpoint;
struct grub_udf_long_ad extended_attr_idb;
struct grub_udf_regid imp_ident;
grub_uint64_t unique_id;
grub_uint32_t ext_attr_length;
grub_uint32_t alloc_descs_length;
grub_uint8_t ext_attr[<literal type="number">1872</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_extended_file_entry
{
struct grub_udf_tag tag;
struct grub_udf_icbtag icbtag;
grub_uint32_t uid;
grub_uint32_t gid;
grub_uint32_t permissions;
grub_uint16_t link_count;
grub_uint8_t record_format;
grub_uint8_t record_display_attr;
grub_uint32_t record_length;
grub_uint64_t file_size;
grub_uint64_t object_size;
grub_uint64_t blocks_recorded;
struct grub_udf_timestamp access_time;
struct grub_udf_timestamp modification_time;
struct grub_udf_timestamp create_time;
struct grub_udf_timestamp attr_time;
grub_uint32_t checkpoint;
grub_uint32_t reserved;
struct grub_udf_long_ad extended_attr_icb;
struct grub_udf_long_ad streamdir_icb;
struct grub_udf_regid imp_ident;
grub_uint64_t unique_id;
grub_uint32_t ext_attr_length;
grub_uint32_t alloc_descs_length;
grub_uint8_t ext_attr[<literal type="number">1832</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_vrs
{
grub_uint8_t type;
grub_uint8_t magic[<literal type="number">5</literal>];
grub_uint8_t version;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_avdp
{
struct grub_udf_tag tag;
struct grub_udf_extent_ad vds;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_pd
{
struct grub_udf_tag tag;
grub_uint32_t seq_num;
grub_uint16_t flags;
grub_uint16_t part_num;
struct grub_udf_regid contents;
grub_uint8_t contents_use[<literal type="number">128</literal>];
grub_uint32_t access_type;
grub_uint32_t start;
grub_uint32_t length;
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>grub_udf_partmap</name>
<block>{
<decl_stmt><decl><type><name>grub_uint8_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint8_t</name></type> <name>length</name></decl>;</decl_stmt>
<union>union
<block>{
<struct>struct
<block>{
<decl_stmt><decl><type><name>grub_uint16_t</name></type> <name>seq_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint16_t</name></type> <name>part_num</name></decl>;</decl_stmt>
}</block> <decl><name>type1</name></decl>;</struct>

<struct>struct
<block>{
<decl_stmt><decl><type><name>grub_uint8_t</name></type> <name><name>ident</name><index>[<expr><literal type="number">62</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>type2</name></decl>;</struct>
}</block>;</union>
}</block>;</struct>

<macro><name>R_PACKED</name> <argument_list>(
<argument>struct grub_udf_lvd
{
struct grub_udf_tag tag;
grub_uint32_t seq_num;
struct grub_udf_charspec charset;
grub_uint8_t ident[<literal type="number">128</literal>];
grub_uint32_t bsize;
struct grub_udf_regid domain_ident;
struct grub_udf_long_ad root_fileset;
grub_uint32_t map_table_length;
grub_uint32_t num_part_maps;
struct grub_udf_regid imp_ident;
grub_uint8_t imp_use[<literal type="number">128</literal>];
struct grub_udf_extent_ad integrity_seq_ext;
grub_uint8_t part_maps[<literal type="number">1608</literal>];
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>grub_udf_data</name>
<block>{
<decl_stmt><decl><type><name>grub_disk_t</name></type> <name>disk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_lvd</name></name></type> <name>lvd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_pd</name></name></type> <name><name>pds</name><index>[<expr><name>GRUB_UDF_MAX_PDS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_partmap</name></name> <modifier>*</modifier></type><name><name>pms</name><index>[<expr><name>GRUB_UDF_MAX_PMS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_long_ad</name></name></type> <name>root_icb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>npd</name></decl>, <decl><type ref="prev"/><name>npm</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>grub_fshelp_node</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<union>union
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_file_entry</name></name></type> <name>fe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_extended_file_entry</name></name></type> <name>efe</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>int</name></type> <name>part_ref</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>grub_dl_t</name></type> <name>my_mod</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>grub_uint32_t</name></type>
<name>grub_udf_get_block</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>grub_uint16_t</name></type> <name>part_ref</name></decl></parameter>, <parameter><decl><type><name>grub_uint32_t</name></type> <name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>part_ref</name> <operator>=</operator> <call><name>U16</name> <argument_list>(<argument><expr><name>part_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>part_ref</name> <operator>&gt;=</operator> <name><name>data</name><operator>-&gt;</operator><name>npm</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid part ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>U32</name> <argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pds</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>pms</name><index>[<expr><name>part_ref</name></expr>]</index></name><operator>-&gt;</operator><name><name>type1</name><operator>.</operator><name>part_num</name></name></expr>]</index></name><operator>.</operator><name>start</name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_err_t</name></type>
<name>grub_udf_read_icb</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>grub_udf_long_ad</name></name> <modifier>*</modifier></type><name>icb</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>grub_uint32_t</name></type> <name>block</name></decl>;</decl_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>grub_udf_get_block</name> <argument_list>(<argument><expr><name>data</name></expr></argument>,
<argument><expr><name><name>icb</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>part_ref</name></name></expr></argument>,
<argument><expr><name><name>icb</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>block_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>grub_errno</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>grub_errno</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>disk</name></name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_file_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>fe</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>grub_errno</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GRUB_UDF_TAG_IDENT_FE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GRUB_UDF_TAG_IDENT_EFE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid fe/efe descriptor"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>part_ref</name></name> <operator>=</operator> <name><name>icb</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>part_ref</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_disk_addr_t</name></type>
<name>grub_udf_read_block</name> <parameter_list>(<parameter><decl><type><name>grub_fshelp_node_t</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>grub_disk_addr_t</name></type> <name>fileblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_disk_addr_t</name></type> <name>filebytes</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_FE</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>ext_attr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>ext_attr_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>alloc_descs_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>efe</name><operator>.</operator><name>ext_attr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>efe</name><operator>.</operator><name>ext_attr_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>efe</name><operator>.</operator><name>alloc_descs_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>icbtag</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>GRUB_UDF_ICBTAG_FLAG_AD_MASK</name><operator>)</operator>
<operator>==</operator> <name>GRUB_UDF_ICBTAG_FLAG_AD_SHORT</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_short_ad</name></name> <modifier>*</modifier></type><name>ad</name> <init>= <expr><operator>(</operator>struct <name>grub_udf_short_ad</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>/=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_short_ad</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>filebytes</name> <operator>=</operator> <name>fileblock</name> <operator>*</operator> <name>GRUB_UDF_BLKSZ</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>filebytes</name> <operator>&lt;</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>GRUB_UDF_EXT_MASK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
<expr><operator>(</operator><call><name>grub_udf_get_block</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>part_ref</name></name></expr></argument>,
<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <operator>(</operator><name>filebytes</name> <operator>/</operator> <name>GRUB_UDF_BLKSZ</name><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>filebytes</name> <operator>-=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ad</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_long_ad</name></name> <modifier>*</modifier></type><name>ad</name> <init>= <expr><operator>(</operator>struct <name>grub_udf_long_ad</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>/=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_long_ad</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>filebytes</name> <operator>=</operator> <name>fileblock</name> <operator>*</operator> <name>GRUB_UDF_BLKSZ</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>filebytes</name> <operator>&lt;</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>block_num</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>GRUB_UDF_EXT_MASK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
<expr><operator>(</operator><call><name>grub_udf_get_block</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>part_ref</name></name></expr></argument>,
<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>block_num</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <operator>(</operator><name>filebytes</name> <operator>/</operator> <name>GRUB_UDF_BLKSZ</name><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>filebytes</name> <operator>-=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>ad</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ad</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_ssize_t</name></type>
<name>grub_udf_read_file</name> <parameter_list>(<parameter><decl><type><name>grub_fshelp_node_t</name></type> <name>node</name></decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>read_hook</name>) <parameter_list>(<parameter><decl><type><name>grub_disk_addr_t</name></type> <name>sector</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>length</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>grub_size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>icbtag</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>GRUB_UDF_ICBTAG_FLAG_AD_MASK</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>GRUB_UDF_ICBTAG_FLAG_AD_IN_ICB</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>U16</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_FE</name><operator>)</operator></expr> ?</condition><then>
<expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>ext_attr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>ext_attr_length</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>:
<expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>efe</name><operator>.</operator><name>ext_attr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>efe</name><operator>.</operator><name>ext_attr_length</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grub_memcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>GRUB_UDF_ICBTAG_FLAG_AD_EXT</name></expr>:</case>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid extent type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><call><name>grub_fshelp_read_file</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>disk</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>read_hook</name></expr></argument>, <argument><expr><name>closure</name></expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>grub_udf_read_block</name></expr></argument>,
<argument><expr><call><name>U64</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>file_size</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>sblocklist</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">256</literal></expr>, <expr><literal type="number">512</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type>
<name>grub_udf_mount</name> <parameter_list>(<parameter><decl><type><name>grub_disk_t</name></type> <name>disk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_fileset</name></name></type> <name>root_fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sblklist</name> <init>= <expr><name>sblocklist</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint32_t</name></type> <name>block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>grub_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>disk</name></name> <operator>=</operator> <name>disk</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>block</name> <operator>=</operator> <literal type="number">16</literal></expr>;</init><condition>;</condition> <incr><expr><name>block</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_vrs</name></name></type> <name>vrs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_vrs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>vrs</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_NSR03</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_NSR02</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_BEA01</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_BOOT2</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_CD001</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_CDW02</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>grub_memcmp</name> <argument_list>(<argument><expr><name><name>vrs</name><operator>.</operator><name>magic</name></name></expr></argument>, <argument><expr><name>GRUB_UDF_STD_IDENT_TEA01</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_avdp</name></name></type> <name>avdp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><operator>*</operator><name>sblklist</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_avdp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>avdp</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>U16</name> <argument_list>(<argument><expr><name><name>avdp</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_AVDP</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>avdp</name><operator>.</operator><name>vds</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sblklist</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sblklist</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>npd</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>npm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_tag</name></name></type> <name>tag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name> <operator>=</operator> <call><name>U16</name> <argument_list>(<argument><expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_PD</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>npd</name></name> <operator>&gt;=</operator> <name>GRUB_UDF_MAX_PDS</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"too many PDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_pd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>pds</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>npd</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>npd</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_LVD</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_partmap</name></name> <modifier>*</modifier></type><name>ppm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_lvd</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>lvd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>npm</name></name> <operator>+</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>num_part_maps</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>GRUB_UDF_MAX_PMS</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"too many partition maps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ppm</name> <operator>=</operator> <operator>(</operator>struct <name>grub_udf_partmap</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>part_maps</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <call><name>U32</name> <argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>num_part_maps</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ppm</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>GRUB_UDF_PARTMAP_TYPE_1</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"partmap type not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pms</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>npm</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ppm</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ppm</name> <operator>=</operator> <operator>(</operator>struct <name>grub_udf_partmap</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ppm</name> <operator>+</operator>
<call><name>U32</name> <argument_list>(<argument><expr><name><name>ppm</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name> <operator>&gt;</operator> <name>GRUB_UDF_TAG_IDENT_TD</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid tag ident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>tag</name><operator>.</operator><name>tag_ident</name></name> <operator>==</operator> <name>GRUB_UDF_TAG_IDENT_TD</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>block</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>npm</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>npd</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>pms</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>type1</name><operator>.</operator><name>part_num</name></name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>pds</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>part_num</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pms</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>type1</name><operator>.</operator><name>part_num</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>npd</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"can\'t find PD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>grub_udf_get_block</name> <argument_list>(<argument><expr><name>data</name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>root_fileset</name><operator>.</operator><name>block</name><operator>.</operator><name>part_ref</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>root_fileset</name><operator>.</operator><name>block</name><operator>.</operator><name>block_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>grub_errno</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_disk_read</name> <argument_list>(<argument><expr><name>disk</name></expr></argument>, <argument><expr><name>block</name> <operator>&lt;&lt;</operator> <name>GRUB_UDF_LOG2_BLKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_udf_fileset</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>root_fs</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"not an UDF filesystem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>U16</name> <argument_list>(<argument><expr><name><name>root_fs</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GRUB_UDF_TAG_IDENT_FSD</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid fileset descriptor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>root_icb</name></name> <operator>=</operator> <name><name>root_fs</name><operator>.</operator><name>root_icb</name></name></expr>;</expr_stmt>

<return>return <expr><name>data</name></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>grub_udf_iterate_dir</name> <parameter_list>(<parameter><decl><type><name>grub_fshelp_node_t</name></type> <name>dir</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>hook</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>grub_fshelp_filetype</name></name></type> <name>filetype</name></decl></parameter>,
<parameter><decl><type><name>grub_fshelp_node_t</name></type> <name>node</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>grub_fshelp_node_t</name></type> <name>child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_file_ident</name></name></type> <name>dirent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint32_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>grub_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_fshelp_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>child</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>grub_memcpy</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>child</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>dir</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_fshelp_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hook</name> <argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>GRUB_FSHELP_DIR</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <call><name>U64</name> <argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>file_size</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>grub_udf_read_file</name> <argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dirent</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dirent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dirent</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>U16</name> <argument_list>(<argument><expr><name><name>dirent</name><operator>.</operator><name>tag</name><operator>.</operator><name>tag_ident</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GRUB_UDF_TAG_IDENT_FID</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>grub_error</name> <argument_list>(<argument><expr><name>GRUB_ERR_BAD_FS</name></expr></argument>, <argument><expr><literal type="string">"invalid fid tag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>grub_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>grub_fshelp_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>child</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_udf_read_icb</name> <argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dirent</name><operator>.</operator><name>icb</name></name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dirent</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>U16</name> <argument_list>(<argument><expr><name><name>dirent</name><operator>.</operator><name>imp_use_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dirent</name><operator>.</operator><name>characteristics</name></name> <operator>&amp;</operator> <name>GRUB_UDF_FID_CHAR_PARENT</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>hook</name> <argument_list>(<argument><expr><literal type="string">".."</literal></expr></argument>, <argument><expr><name>GRUB_FSHELP_DIR</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>grub_fshelp_filetype</name></name></type> <name>type</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>grub_uint8_t</name></type> <name><name>raw</name><index>[<expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint16_t</name></type> <name><name>utf16</name><index>[<expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint8_t</name></type> <name><name>filename</name><index>[<expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>grub_uint8_t</name> <modifier>*</modifier></type> <name>raw</name> <init>= <expr><call><name>grub_malloc</name> <argument_list>(<argument><expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint16_t</name> <modifier>*</modifier></type> <name>utf16</name> <init>= <expr><call><name>grub_malloc</name> <argument_list>(<argument><expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>grub_uint8_t</name> <modifier>*</modifier></type> <name>filename</name> <init>= <expr><call><name>grub_malloc</name> <argument_list>(<argument><expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>grub_size_t</name></type> <name>utf16len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>dirent</name><operator>.</operator><name>characteristics</name></name> <operator>&amp;</operator> <name>GRUB_UDF_FID_CHAR_DIRECTORY</name><operator>)</operator></expr> ?</condition><then>
<expr><operator>(</operator><name>GRUB_FSHELP_DIR</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>GRUB_FSHELP_REG</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>grub_udf_read_file</name> <argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>raw</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>!=</operator> <name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>raw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>utf16len</name> <operator>=</operator> <name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf16len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>raw</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>raw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>utf16len</name> <operator>=</operator> <operator>(</operator><name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf16len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>raw</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>raw</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>raw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name><name>raw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><call><name>grub_utf16_to_utf8</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>utf16</name></expr></argument>, <argument><expr><name>utf16len</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hook</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>filename</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>closure</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name><name>dirent</name><operator>.</operator><name>file_ident_length</name></name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>grub_free</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>grub_udf_dir_closure</name>
<block>{
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>hook</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grub_dirhook_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>iterate</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>grub_fshelp_filetype</name></name></type> <name>filetype</name></decl></parameter>,
<parameter><decl><type><name>grub_fshelp_node_t</name></type> <name>node</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_dir_closure</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>closure</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_dirhook_info</name></name></type> <name>info</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>grub_memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>dir</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>filetype</name> <operator>&amp;</operator> <name>GRUB_FSHELP_TYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>GRUB_FSHELP_DIR</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>c</name><operator>-&gt;</operator><name>hook</name></name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>closure</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_err_t</name></type>
<name>grub_udf_dir</name> <parameter_list>(<parameter><decl><type><name>grub_device_t</name></type> <name>device</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>hook</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>grub_dirhook_info</name></name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>closure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name></type> <name>rootnode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name> <modifier>*</modifier></type><name>foundnode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_dir_closure</name></name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grub_dl_ref</name> <argument_list>(<argument><expr><name>my_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>grub_udf_mount</name> <argument_list>(<argument><expr><name><name>device</name><operator>-&gt;</operator><name>disk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_udf_read_icb</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>root_icb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootnode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_fshelp_find_file</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootnode</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>foundnode</name></expr></argument>,
<argument><expr><name>grub_udf_iterate_dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GRUB_FSHELP_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hook</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>hook</name></name> <operator>=</operator> <name>hook</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>closure</name></name> <operator>=</operator> <name>closure</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>grub_udf_iterate_dir</name> <argument_list>(<argument><expr><name>foundnode</name></expr></argument>, <argument><expr><name>iterate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>foundnode</name> <operator>!=</operator> <operator>&amp;</operator><name>rootnode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>foundnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grub_dl_unref</name> <argument_list>(<argument><expr><name>my_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>grub_errno</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_err_t</name></type>
<name>grub_udf_open</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>grub_file</name></name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name></type> <name>rootnode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name> <modifier>*</modifier></type><name>foundnode</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grub_dl_ref</name> <argument_list>(<argument><expr><name>my_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>grub_udf_mount</name> <argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>device</name><operator>-&gt;</operator><name>disk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_udf_read_icb</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>root_icb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootnode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grub_fshelp_find_file</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootnode</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>foundnode</name></expr></argument>,
<argument><expr><name>grub_udf_iterate_dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GRUB_FSHELP_REG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>foundnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>U64</name> <argument_list>(<argument><expr><name><name>foundnode</name><operator>-&gt;</operator><name>fe</name><operator>.</operator><name>file_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>grub_dl_unref</name> <argument_list>(<argument><expr><name>my_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>grub_errno</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_ssize_t</name></type>
<name>grub_udf_read</name> <parameter_list>(<parameter><decl><type><name>grub_file_t</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>grub_size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator>struct <name>grub_fshelp_node</name> <operator>*</operator><operator>)</operator> <name><name>file</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>grub_udf_read_file</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>read_hook</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>closure</name></name></expr></argument>,
<argument><expr><name><name>file</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_err_t</name></type>
<name>grub_udf_close</name> <parameter_list>(<parameter><decl><type><name>grub_file_t</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_fshelp_node</name></name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator>struct <name>grub_fshelp_node</name> <operator>*</operator><operator>)</operator> <name><name>file</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>grub_dl_unref</name> <argument_list>(<argument><expr><name>my_mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>GRUB_ERR_NONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>grub_err_t</name></type>
<name>grub_udf_label</name> <parameter_list>(<parameter><decl><type><name>grub_device_t</name></type> <name>device</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>grub_udf_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>grub_udf_mount</name> <argument_list>(<argument><expr><name><name>device</name><operator>-&gt;</operator><name>disk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>label</name> <operator>=</operator> <call><name>grub_strdup</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>lvd</name><operator>.</operator><name>ident</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>grub_free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>label</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>grub_errno</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>struct</name> <name>grub_fs</name></name></type> <name>grub_udf_fs</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"udf"</literal></expr>,
<expr><operator>.</operator><name>dir</name> <operator>=</operator> <name>grub_udf_dir</name></expr>,
<expr><operator>.</operator><name>open</name> <operator>=</operator> <name>grub_udf_open</name></expr>,
<expr><operator>.</operator><name>read</name> <operator>=</operator> <name>grub_udf_read</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>grub_udf_close</name></expr>,
<expr><operator>.</operator><name>label</name> <operator>=</operator> <name>grub_udf_label</name></expr>,
<expr><operator>.</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
