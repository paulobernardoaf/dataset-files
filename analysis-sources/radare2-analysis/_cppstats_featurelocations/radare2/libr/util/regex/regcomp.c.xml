<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\util\regex\regcomp.c">



































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_regex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex2.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cname.h"</cpp:file></cpp:include>





<struct>struct <name>parse</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>strip</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sopno</name></type> <name>ssize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sopno</name></type> <name>slen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ncsalloc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NPAREN</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>sopno</name></type> <name><name>pbegin</name><index>[<expr><name>NPAREN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sopno</name></type> <name><name>pend</name><index>[<expr><name>NPAREN</name></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_ere</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_ere_exp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_bre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>p_simp_re</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>p_count</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_bracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_b_term</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_b_cclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>p_b_eclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>p_b_symbol</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>p_b_coll_elem</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>othercase</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bothcases</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ordinary</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>special</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>nonnewline</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repeat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>seterr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cset</name> <modifier>*</modifier></type><name>allocset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freeset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>freezeset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>firstch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>nch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mcadd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mcinvert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mccase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>isinsets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>samesets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>categorize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>sopno</name></type> <name>dupl</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doemit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sop</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doinsert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sop</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dofwd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>, <parameter><decl><type><name>sop</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enlarge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sopno</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>stripsnug</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findmust</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>sopno</name></type> <name>pluscount</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nuls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt> 





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEEK</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(*p-&gt;next)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PEEK2</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(*(p-&gt;next+1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;next &lt; p-&gt;end)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORE2</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;next+1 &lt; p-&gt;end)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(MORE() &amp;&amp; PEEK() == (c))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEETWO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(MORE() &amp;&amp; MORE2() &amp;&amp; PEEK() == (a) &amp;&amp; PEEK2() == (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((SEE(c)) ? (NEXT(), 1) : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EATTWO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((SEETWO(a, b)) ? (NEXT2(), 1) : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;next++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT2</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;next += 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXTn</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(p-&gt;next += (n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETNEXT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(*p-&gt;next++)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETERROR</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>seterr(p, (e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE</name><parameter_list>(<parameter><type><name>co</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)((co) || SETERROR(e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUSTSEE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(REQUIRE(MORE() &amp;&amp; PEEK() == (c), e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUSTEAT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(REQUIRE(MORE() &amp;&amp; GETNEXT() == (c), e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUSTNOTSEE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(REQUIRE(!MORE() || PEEK() != (c), e))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMIT</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>sopnd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>doemit(p, (sop)(op), (size_t)(sopnd))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>pos</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>doinsert(p, (sop)(op), HERE()-(pos)+1, pos)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AHEAD</name><parameter_list>(<parameter><type><name>pos</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dofwd(p, pos, HERE()-(pos))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASTERN</name><parameter_list>(<parameter><type><name>sop</name></type></parameter>, <parameter><type><name>pos</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EMIT(sop, HERE()-(pos))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HERE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;slen)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THERE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;slen - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THERETHERE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p-&gt;slen - 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROP</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(p-&gt;slen -= (n))</cpp:value></cpp:define>


<function><type><name>R_API</name> <name>int</name></type> <name>r_regex_match</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RRegex</name></type> <name>rx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>re_flags</name> <init>= <expr><call><name>r_regex_flags</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_regex_comp</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>re_flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"FAIL TO COMPILE %s\n"</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_regex_exec</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>re_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_regex_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>ret</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
regex_t preg;
regmatch_t pmatch[NUM_MATCHES];
if (regcomp(&amp;preg, reg, REG_EXTENDED))
return -1;
return (regexec (&amp;preg, str, NUM_MATCHES, pmatch, 0))?1:0;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RRegex</name> <modifier>*</modifier></type><name>r_regex_new</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RRegex</name></type> <name>rx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RRegex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_regex_comp</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>r_regex_flags</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr><name>RRegex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rx</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RRegex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_regex_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>f</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'e'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_EXTENDED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_ICASE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_NOSUB</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_NEWLINE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_NOSPEC</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_PEND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>R_REGEX_DUMP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_regex_fini</name><parameter_list>(<parameter><decl><type><name>RRegex</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preg</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>!=</operator> <name>MAGIC1</name></expr>)</condition> <block>{<block_content> 
<return>return;</return> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <name><name>preg</name><operator>-&gt;</operator><name>re_g</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>MAGIC2</name></expr>)</condition> <block>{<block_content> 
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>strip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>must</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_regex_free</name><parameter_list>(<parameter><decl><type><name>RRegex</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_regex_fini</name> <argument_list>(<argument><expr><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>R_API</name> <name>int</name></type> <name>r_regex_comp</name><parameter_list>(<parameter><decl><type><name>RRegex</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parse</name></name></type> <name>pa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name>pa</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GOODFLAGS</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(f)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GOODFLAGS</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((f)&amp;~R_REGEX_DUMP)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>cflags</name> <operator>=</operator> <call><name>GOODFLAGS</name> <argument_list>(<argument><expr><name>cflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preg</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>R_REGEX_EXTENDED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>R_REGEX_NOSPEC</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_REGEX_INVARG</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&amp;</operator> <name>R_REGEX_PEND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>-&gt;</operator><name>re_endp</name></name> <operator>&lt;</operator> <name>pattern</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_REGEX_INVARG</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>preg</name><operator>-&gt;</operator><name>re_endp</name></name> <operator>-</operator> <name>pattern</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>(</operator>struct <name>re_guts</name> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>re_guts</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>NC</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cat_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_REGEX_ESPACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>









<decl_stmt><decl><type><name>size_t</name></type> <name>maxlen</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>maxlen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_REGEX_ESPACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_flags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name>len</name> <operator>/</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_REGEX_ESPACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <operator>(</operator><name>sop</name> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_REGEX_ESPACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_REGEX_ESPACE</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pattern</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ncsalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NPAREN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>csetsize</name></name> <operator>=</operator> <name>NC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>setbits</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>ncsets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nbol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>neol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>must</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nsub</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>ncategories</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>categories</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>catspace</name><index>[<expr><operator>-</operator><operator>(</operator><name>CHAR_MIN</name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt> 
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>memset</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>g</name><operator>-&gt;</operator><name>catspace</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NC</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>cat_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>backrefs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>EMIT</name> <argument_list>(<argument><expr><name>OEND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>firststate</name></name> <operator>=</operator> <call><name>THERE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&amp;</operator> <name>R_REGEX_EXTENDED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_ere</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cflags</name> <operator>&amp;</operator> <name>R_REGEX_NOSPEC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_str</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>p_bre</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OUT</name></expr></argument>, <argument><expr><name>OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>EMIT</name> <argument_list>(<argument><expr><name>OEND</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>laststate</name></name> <operator>=</operator> <call><name>THERE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>categorize</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stripsnug</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>findmust</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nplus</name></name> <operator>=</operator> <call><name>pluscount</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>MAGIC2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>nsub</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_g</name></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>=</operator> <name>MAGIC1</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>REDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>&amp;</operator> <name>BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SETERROR</name> <argument_list>(<argument><expr><name>R_REGEX_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_regex_fini</name> <argument_list>(<argument><expr><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>p_ere</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stop</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>bool</name></type> <name>isFirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>prevback</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>prevfwd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>conc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>conc</name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>MORE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>PEEK</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'|'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>stop</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_ere_exp</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>REQUIRE</name> <argument_list>(<argument><expr><call><name>HERE</name> <argument_list>()</argument_list></call> <operator>!=</operator> <name>conc</name></expr></argument>, <argument><expr><name>R_REGEX_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isFirst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>INSERT</name> <argument_list>(<argument><expr><name>OCH_</name></expr></argument>, <argument><expr><name>conc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>prevfwd</name> <operator>=</operator> <name>conc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prevback</name> <operator>=</operator> <name>conc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>isFirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>OOR1</name></expr></argument>, <argument><expr><name>prevback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prevback</name> <operator>=</operator> <call><name>THERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><name>prevfwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>prevfwd</name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OOR2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFirst</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><name>prevfwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_CH</name></expr></argument>, <argument><expr><name>prevback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>p_ere_exp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>subno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wascaret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MORE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content> 
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>GETNEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nsub</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>subno</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nsub</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subno</name> <operator>&lt;</operator> <name>NPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <call><name>HERE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OLPAREN</name></expr></argument>, <argument><expr><name>subno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEE</name> <argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_ere</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>subno</name> <operator>&lt;</operator> <name>NPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>subno</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>ORPAREN</name></expr></argument>, <argument><expr><name>subno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MUSTEAT</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><name>R_REGEX_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'^'</literal></expr>:</case>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OBOL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>USEBOL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nbol</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>wascaret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OEOL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>USEEOL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>neol</name></name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>R_REGEX_NEWLINE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>nonnewline</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name> <argument_list>(<argument><expr><name>OANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<expr_stmt><expr><call><name>p_bracket</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EESCAPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>GETNEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ordinary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>special</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'{'</literal></expr>:</case> 
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><operator>!</operator><call><name>MORE</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>ordinary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MORE</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PEEK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator>
<operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <call><name>MORE2</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK2</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><operator>!</operator><name>wascaret</name></expr></argument>, <argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OPLUS_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_PLUS</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OQUEST_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_QUEST</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OPLUS_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_PLUS</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OCH_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>OOR1</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OOR2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><call><name>THERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_CH</name></expr></argument>, <argument><expr><call><name>THERETHERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'{'</literal></expr>:</case>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>p_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count2</name> <operator>=</operator> <call><name>p_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;=</operator> <name>count2</name></expr></argument>, <argument><expr><name>R_REGEX_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>count2</name> <operator>=</operator> <name>INTFINITY</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>count2</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<while>while <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PEEK</name> <argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MORE</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PEEK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator>
<operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <call><name>MORE2</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK2</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>p_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>MORE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ordinary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>GETNEXT</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>p_bre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>end1</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>end2</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>sopno</name></type> <name>start</name> <init>= <expr><call><name>HERE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>wasdollar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OBOL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>USEBOL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nbol</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><call><name>MORE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEETWO</name><argument_list>(<argument><expr><name>end1</name></expr></argument>, <argument><expr><name>end2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wasdollar</name> <operator>=</operator> <call><name>p_simp_re</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>wasdollar</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>DROP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OEOL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>USEEOL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>neol</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>HERE</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>start</name></expr></argument>, <argument><expr><name>R_REGEX_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>p_simp_re</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>starordinary</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>subno</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKSL</name></cpp:macro> <cpp:value>(1&lt;&lt;CHAR_BIT)</cpp:value></cpp:define>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MORE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content> 
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>GETNEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EESCAPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>BACKSL</name> <operator>|</operator> <call><name>GETNEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>R_REGEX_NEWLINE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>nonnewline</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name> <argument_list>(<argument><expr><name>OANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<expr_stmt><expr><call><name>p_bracket</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'{'</literal></expr>:</case>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'('</literal></expr>:</case>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nsub</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>subno</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nsub</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subno</name> <operator>&lt;</operator> <name>NPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <call><name>HERE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OLPAREN</name></expr></argument>, <argument><expr><name>subno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEETWO</name> <argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_bre</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>subno</name> <operator>&lt;</operator> <name>NPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>subno</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>ORPAREN</name></expr></argument>, <argument><expr><name>subno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">')'</literal></expr>:</case> 
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'}'</literal></expr>:</case>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'1'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'2'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'3'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'4'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'5'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'6'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'7'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'8'</literal></expr>:</case>
<case>case <expr><name>BACKSL</name><operator>|</operator><literal type="char">'9'</literal></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><operator>~</operator><name>BACKSL</name><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nsub</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OBACK_</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>OP</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OLPAREN</name> <operator>&amp;&amp;</operator>
<call><name>OP</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ORPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dupl</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>O_BACK</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ESUBREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>backrefs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>starordinary</name></expr></argument>, <argument><expr><name>R_REGEX_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>ordinary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OPLUS_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_PLUS</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OQUEST_</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_QUEST</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>p_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>MORE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count2</name> <operator>=</operator> <call><name>p_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>count</name> <operator>&lt;=</operator> <name>count2</name></expr></argument>, <argument><expr><name>R_REGEX_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>count2</name> <operator>=</operator> <name>INTFINITY</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>count2</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<while>while <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEETWO</name> <argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content> 
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>p_count</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>MORE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><call><name>PEEK</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;=</operator> <name>DUPMAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name>count</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><call><name>GETNEXT</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ndigits</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>ndigits</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;=</operator> <name>DUPMAX</name></expr></argument>, <argument><expr><name>R_REGEX_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>count</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>p_bracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>invert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><literal type="string">"[:&lt;:]]"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OBOW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXTn</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><literal type="string">"[:&gt;:]]"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OEOW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NEXTn</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cs</name> <operator>=</operator> <call><name>allocset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>EAT</name> <argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>invert</name><operator>++</operator></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EAT</name> <argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>EAT</name> <argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PEEK</name> <argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEETWO</name> <argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>p_b_term</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>EAT</name> <argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>MUSTEAT</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>freeset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>cflags</name></name><operator>&amp;</operator><name>R_REGEX_ICASE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ci</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHIN</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isalpha</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>othercase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>!=</operator> <name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mccase</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>invert</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHIN</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHsub</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>R_REGEX_NEWLINE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHsub</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mcinvert</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name></expr>)</condition> <block>{<block_content> 
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>nch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>ordinary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>firstch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OANYOF</name></expr></argument>, <argument><expr><call><name>freezeset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>p_b_term</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>finish</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<switch>switch <condition>(<expr><ternary><condition><expr><operator>(</operator><call><name>MORE</name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name>PEEK</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>MORE2</name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name>PEEK2</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return> 
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case> 
<expr_stmt><expr><call><name>NEXT2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PEEK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">']'</literal></expr></argument>, <argument><expr><name>R_REGEX_ECTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_b_cclass</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_ECTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'='</literal></expr>:</case> 
<expr_stmt><expr><call><name>NEXT2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PEEK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">']'</literal></expr></argument>, <argument><expr><name>R_REGEX_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_b_eclass</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> 

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>p_b_symbol</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MORE2</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PEEK2</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EAT</name> <argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>finish</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>finish</name> <operator>=</operator> <call><name>p_b_symbol</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>finish</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><name>start</name> <operator>&lt;=</operator> <name>finish</name></expr></argument>, <argument><expr><name>R_REGEX_ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>finish</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>p_b_cclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cclass</name></name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>PEEK</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>-</operator> <name>sp</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>cclasses</name></expr>;</init> <condition><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ECTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>chars</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>u</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHadd</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>multis</name></name></expr>;</init> <condition><expr><operator>*</operator><name>u</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>u</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>MCadd</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>p_b_eclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>p_b_coll_elem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHadd</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>char</name></type> 
<name>p_b_symbol</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>value</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>MORE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EATTWO</name> <argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>GETNEXT</name> <argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>p_b_coll_elem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE</name><argument_list>(<argument><expr><call><name>EATTWO</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_REGEX_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>char</name></type> 
<name>p_b_coll_elem</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>endc</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cname</name></name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>MORE</name> <argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEETWO</name> <argument_list>(<argument><expr><name>endc</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MORE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_EBRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>-</operator> <name>sp</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>cnames</name></expr>;</init> <condition><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>code</name></name><operator>)</operator></expr>;</return> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>*</operator><name>sp</name><operator>)</operator></expr>;</return> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>char</name></type> 
<name>othercase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isupper</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>ut8</name><operator>)</operator><call><name>tolower</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>islower</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>ut8</name><operator>)</operator><call><name>toupper</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content> 
<return>return <expr><operator>(</operator><name>ch</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ch</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bothcases</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldnext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldend</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>bracket</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>othercase</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ch</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>bracket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>bracket</name><operator>+</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_bracket</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>bracket</name><operator>+</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>oldnext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>oldend</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>ordinary</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>cat_t</name> <modifier>*</modifier></type><name>cap</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>categories</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>R_REGEX_ICASE</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>othercase</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bothcases</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OCHAR</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cap</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cap</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>ncategories</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>special</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldnext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldend</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>bracket</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>digits</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>GETNEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>digits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GETNEXT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>strtol</name> <argument_list>(<argument><expr><name>digits</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ordinary</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><call><name>ordinary</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><call><name>ordinary</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><call><name>ordinary</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>bracket</name></expr></argument>, <argument><expr><literal type="string">"\t\r\n ]"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>bracket</name></expr></argument>, <argument><expr><literal type="string">"0-9]"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>bracket</name></expr></argument>, <argument><expr><literal type="string">"a-z]"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>SETERROR</name> <argument_list>(<argument><expr><name>R_REGEX_INVARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>bracket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>bracket</name> <operator>+</operator> <name>num</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>p_bracket</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>bracket</name> <operator>+</operator> <name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>oldnext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>oldend</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>nonnewline</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldnext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldend</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>bracket</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>bracket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>bracket</name><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bracket</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>p_bracket</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>bracket</name><operator>+</operator><literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>oldnext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>oldend</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>repeat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>sopno</name></type> <name>start</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>sopno</name></type> <name>finish</name> <init>= <expr><call><name>HERE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INF</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((f)*8 + (t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n) &lt;= 1) ? (n) : ((n) == INTFINITY) ? INF : N)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>sopno</name></type> <name>copy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>REP</name><argument_list>(<argument><expr><call><name>MAP</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MAP</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>:</case> 
<expr_stmt><expr><call><name>DROP</name><argument_list>(<argument><expr><name>finish</name><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case> 
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>:</case> 
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case> 

<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OCH_</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>OOR1</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OOR2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><call><name>THERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_CH</name></expr></argument>, <argument><expr><call><name>THERETHERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case> 

<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>:</case> 

<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OCH_</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>OOR1</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>OOR2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>AHEAD</name><argument_list>(<argument><expr><call><name>THERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_CH</name></expr></argument>, <argument><expr><call><name>THERETHERE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>dupl</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>finish</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>==</operator> <name>finish</name><operator>+</operator><literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>to</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case> 
<expr_stmt><expr><call><name>INSERT</name><argument_list>(<argument><expr><name>OPLUS_</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASTERN</name><argument_list>(<argument><expr><name>O_PLUS</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>:</case> 
<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>dupl</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>finish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name>from</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>to</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>REP</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case> 
<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>dupl</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>finish</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name>from</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> 
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>seterr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>nuls</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>nuls</name></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return> 
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>cset</name> <modifier>*</modifier></type> <name>allocset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>no</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>ncsets</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>css</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>no</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>ncsalloc</name></name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ncsalloc</name></name> <operator>+=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ncsalloc</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nc</name> <operator>%</operator> <name>CHAR_BIT</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>nomem</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>nc</name> <operator>/</operator> <name>CHAR_BIT</name> <operator>*</operator> <name>css</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>cset</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name></name></expr></argument>, <argument><expr><name>nc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>nomem</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>nomem</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>no</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name> <operator>+</operator> <name>css</name> <operator>*</operator> <operator>(</operator><name>i</name> <operator>/</operator> <name>CHAR_BIT</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name> <operator>+</operator> <operator>(</operator><name>nbytes</name> <operator>-</operator> <name>css</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>css</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name></name> <operator>||</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>nomem</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cs</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name><index>[<expr><name>no</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name> <operator>+</operator> <name>css</name><operator>*</operator><operator>(</operator><operator>(</operator><name>no</name><operator>)</operator><operator>/</operator><name>CHAR_BIT</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>mask</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>no</name><operator>)</operator> <operator>%</operator> <name>CHAR_BIT</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>smultis</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return<expr><operator>(</operator><name>cs</name><operator>)</operator></expr>;</return>
<label><name>nomem</name>:</label>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return<expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>freeset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cset</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>ncsets</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>css</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>css</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>CHsub</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>top</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>ncsets</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type> 
<name>freezeset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name>h</name> <init>= <expr><name><name>cs</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cset</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>ncsets</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>css</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>cs2</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>cs2</name> <operator>&lt;</operator> <name>top</name></expr>;</condition> <incr><expr><name>cs2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cs2</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>h</name> <operator>&amp;&amp;</operator> <name>cs2</name> <operator>!=</operator> <name>cs</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>css</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>!</operator><call><name>CHIN</name> <argument_list>(<argument><expr><name>cs2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>!</operator><operator>!</operator><call><name>CHIN</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>css</name></expr>)</condition> <block>{<block_content>
<break>break;</break> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>cs2</name> <operator>&lt;</operator> <name>top</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>freeset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cs</name> <operator>=</operator> <name>cs2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return<expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>cs</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>sets</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>firstch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>css</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>css</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHIN</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>char</name><operator>)</operator><name>i</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return> 
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>nch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>css</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>css</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHIN</name> <argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return<expr><operator>(</operator><name>n</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>mcadd</name><parameter_list>( <parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>oldend</name> <init>= <expr><name><name>cs</name><operator>-&gt;</operator><name>smultis</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>smultis</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name></expr></argument>, <argument><expr><name><name>cs</name><operator>-&gt;</operator><name>smultis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>np</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRLCPY</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>multis</name></name> <operator>+</operator> <name>oldend</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cs</name><operator>-&gt;</operator><name>smultis</name></name> <operator>-</operator> <name>oldend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>mcinvert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>mccase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>cset</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>isinsets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ncols</name> <init>= <expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>ncsets</name></name><operator>+</operator><operator>(</operator><name>CHAR_BIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>uc</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>)</operator><name>c</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>col</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>col</name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>col</name><index>[<expr><name>uc</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> 
<name>samesets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ncols</name> <init>= <expr><operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>ncsets</name></name><operator>+</operator><operator>(</operator><name>CHAR_BIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>CHAR_BIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>uc1</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>)</operator><name>c1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>uc2</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>)</operator><name>c2</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>col</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>setbits</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>col</name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>csetsize</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>col</name><index>[<expr><name>uc1</name></expr>]</index></name> <operator>!=</operator> <name><name>col</name><index>[<expr><name>uc2</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return<expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>categorize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>cat_t</name> <modifier>*</modifier></type><name>cats</name> <init>= <expr><ternary><condition><expr><name>g</name></expr>?</condition><then> <expr><name><name>g</name><operator>-&gt;</operator><name>categories</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cat_t</name></type> <name>cat</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>cats</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>CHAR_MIN</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>CHAR_MAX</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>( <expr><operator>*</operator><operator>(</operator><name>cats</name><operator>+</operator><name>c</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>isinsets</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cat</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>ncategories</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cats</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>cat</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>c2</name> <operator>=</operator> <name>c</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>c2</name> <operator>&lt;=</operator> <name>CHAR_MAX</name></expr>;</condition> <incr><expr><name>c2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cats</name><index>[<expr><name>c2</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>samesets</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cats</name><index>[<expr><name>c2</name></expr>]</index></name> <operator>=</operator> <name>cat</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>sopno</name></type> 
<name>dupl</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>sopno</name></type> <name>start</name></decl></parameter>, 
<parameter><decl><type><name>sopno</name></type> <name>finish</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>sopno</name></type> <name>ret</name> <init>= <expr><call><name>HERE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>len</name> <init>= <expr><name>finish</name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>finish</name> <operator>&gt;=</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>enlarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>slen</name></name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name></name> <operator>+</operator> <name>start</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>doemit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sop</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>opnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>opnd</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>OPSHIFT</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>ssize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>enlarge</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>ssize</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SOP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>opnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>doinsert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sop</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>opnd</name></decl></parameter>, <parameter><decl><type><name>sopno</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sopno</name></type> <name>sn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sop</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sn</name> <operator>=</operator> <call><name>HERE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EMIT</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>opnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>HERE</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>sn</name><operator>+</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>sn</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NPAREN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pbegin</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pend</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt> 

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>pos</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>(</operator><call><name>HERE</name><argument_list>()</argument_list></call><operator>-</operator><name>pos</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>dofwd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sopno</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>sop</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>OPSHIFT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <call><name>OP</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>|</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>enlarge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sopno</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><name>sop</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name></name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ssize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>stripsnug</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>slen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <operator>(</operator><name>sop</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>strip</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>slen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>strip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SETERROR</name><argument_list>(<argument><expr><name>R_REGEX_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>strip</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>findmust</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>newstart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sopno</name></type> <name>newlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sop</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>i</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>newlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>scan</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>strip</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>scan</name><operator>++</operator></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OCHAR</name></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>newstart</name> <operator>=</operator> <name>scan</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>newlen</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OPLUS_</name></expr>:</case> 
<case>case <expr><name>OLPAREN</name></expr>:</case>
<case>case <expr><name>ORPAREN</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>OQUEST_</name></expr>:</case> 
<case>case <expr><name>OCH_</name></expr>:</case>
<expr_stmt><expr><name>scan</name><operator>--</operator></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>scan</name> <operator>+=</operator> <call><name>OPND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>scan</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>O_QUEST</name> <operator>&amp;&amp;</operator> <call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>O_CH</name> <operator>&amp;&amp;</operator>
<call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OOR2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>BAD</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>O_QUEST</name> <operator>&amp;&amp;</operator> <call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>O_CH</name></expr>)</condition>;</do>

<default>default:</default> 
<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>&gt;</operator> <name><name>g</name><operator>-&gt;</operator><name>mlen</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>newstart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mlen</name></name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block> while <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OEND</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>must</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>g</name><operator>-&gt;</operator><name>mlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>must</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>must</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>scan</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>mlen</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><call><name>OP</name> <argument_list>(<argument><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>scan</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OCHAR</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>must</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>mlen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>OPND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>must</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>mlen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>sopno</name></type> 
<name>pluscount</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parse</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_guts</name></name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sop</name> <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sop</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>plusnest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sopno</name></type> <name>maxnest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>strip</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>scan</name><operator>++</operator></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OPLUS_</name></expr>:</case>
<expr_stmt><expr><name>plusnest</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>O_PLUS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>plusnest</name> <operator>&gt;</operator> <name>maxnest</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxnest</name> <operator>=</operator> <name>plusnest</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>plusnest</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block> while <condition>(<expr><call><name>OP</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OEND</name></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>plusnest</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>iflags</name></name> <operator>|=</operator> <name>BAD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return<expr><operator>(</operator><name>maxnest</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
