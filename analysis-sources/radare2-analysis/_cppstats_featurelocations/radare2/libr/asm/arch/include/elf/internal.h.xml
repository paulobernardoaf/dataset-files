<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\asm\arch\include\elf\internal.h">



































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_ELF_INTERNAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_ELF_INTERNAL_H</name></cpp:macro></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EI_NIDENT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 

<typedef>typedef <type><struct>struct <name>elf_internal_ehdr</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>e_ident</name><index>[<expr><name>EI_NIDENT</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>e_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_size_type</name></type> <name>e_phoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_size_type</name></type> <name>e_shoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>e_version</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>e_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>e_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>e_machine</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_ehsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_phentsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_phnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_shentsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_shnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>e_shstrndx</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Ehdr</name>;</typedef>



<struct>struct <name>elf_internal_phdr</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>p_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>p_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_offset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_vaddr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_paddr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_filesz</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_memsz</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_align</name></decl>;</decl_stmt> 
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>elf_internal_phdr</name></name></type> <name>Elf_Internal_Phdr</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_shdr</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sh_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sh_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>sh_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>sh_addr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_size_type</name></type> <name>sh_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_size_type</name></type> <name>sh_entsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sh_link</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sh_info</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>file_ptr</name></type> <name>sh_offset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sh_addralign</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>asection</name> <modifier>*</modifier></type> <name>bfd_section</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Shdr</name>;</typedef>



<struct>struct <name>elf_internal_sym</name> <block>{
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>st_value</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>st_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>st_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>st_info</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>st_other</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>st_shndx</name></decl>;</decl_stmt> 
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>elf_internal_sym</name></name></type> <name>Elf_Internal_Sym</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_note</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>namesz</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>descsz</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>namedata</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>descdata</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>descpos</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Note</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_rela</name> <block>{
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>r_offset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>r_info</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>r_addend</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Rela</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_dyn</name> <block>{

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>d_tag</name></decl>;</decl_stmt> 
<union>union <block>{

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>d_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>d_ptr</name></decl>;</decl_stmt>
}</block> <decl><name>d_un</name></decl>;</union>
}</block></struct></type> <name>Elf_Internal_Dyn</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_verdef</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vd_version</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vd_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vd_ndx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vd_cnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vd_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vd_aux</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vd_next</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>bfd</name> <modifier>*</modifier></type><name>vd_bfd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vd_nodename</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_verdef</name></name> <modifier>*</modifier></type><name>vd_nextdef</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_verdaux</name></name> <modifier>*</modifier></type><name>vd_auxptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vd_exp_refno</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Verdef</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_verdaux</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vda_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vda_next</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vda_nodename</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_verdaux</name></name> <modifier>*</modifier></type><name>vda_nextptr</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Verdaux</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_verneed</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vn_version</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vn_cnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vn_file</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vn_aux</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vn_next</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>bfd</name> <modifier>*</modifier></type><name>vn_bfd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vn_filename</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_vernaux</name></name> <modifier>*</modifier></type><name>vn_auxptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_verneed</name></name> <modifier>*</modifier></type><name>vn_nextref</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Verneed</name>;</typedef>



<typedef>typedef <type><struct>struct <name>elf_internal_vernaux</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vna_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vna_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vna_other</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vna_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>vna_next</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vna_nodename</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>elf_internal_vernaux</name></name> <modifier>*</modifier></type><name>vna_nextptr</name></decl>;</decl_stmt> 
}</block></struct></type> <name>Elf_Internal_Vernaux</name>;</typedef>




<typedef>typedef <type><struct>struct <name>elf_internal_versym</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>vs_vers</name></decl>;</decl_stmt>
}</block></struct></type> <name>Elf_Internal_Versym</name>;</typedef>


<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>si_boundto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>si_flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>Elf_Internal_Syminfo</name>;</typedef>


<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>a_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bfd_vma</name></type> <name>a_val</name></decl>;</decl_stmt>
}</block></struct></type> <name>Elf_Internal_Auxv</name>;</typedef>





<struct>struct <name>elf_segment_map</name>
<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>elf_segment_map</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>p_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>p_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_paddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_vaddr_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>p_align</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>p_flags_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>p_paddr_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>p_align_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>includes_filehdr</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>includes_phdrs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>asection</name> <modifier>*</modifier></type><name><name>sections</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_SECTION_SIZE</name><parameter_list>(<parameter><type><name>sec_hdr</name></type></parameter>, <parameter><type><name>segment</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sec_hdr-&gt;sh_flags &amp; SHF_TLS) == 0 || sec_hdr-&gt;sh_type != SHT_NOBITS || segment-&gt;p_type == PT_TLS) ? sec_hdr-&gt;sh_size : 0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_IS_SECTION_IN_SEGMENT</name><parameter_list>(<parameter><type><name>sec_hdr</name></type></parameter>, <parameter><type><name>segment</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((((sec_hdr-&gt;sh_flags &amp; SHF_TLS) != 0) &amp;&amp; (segment-&gt;p_type == PT_TLS || segment-&gt;p_type == PT_LOAD)) || ((sec_hdr-&gt;sh_flags &amp; SHF_TLS) == 0 &amp;&amp; segment-&gt;p_type != PT_TLS)) &amp;&amp; (sec_hdr-&gt;sh_type == SHT_NOBITS || ((bfd_vma) sec_hdr-&gt;sh_offset &gt;= segment-&gt;p_offset &amp;&amp; (sec_hdr-&gt;sh_offset + ELF_SECTION_SIZE(sec_hdr, segment) &lt;= segment-&gt;p_offset + segment-&gt;p_filesz))) &amp;&amp; ((sec_hdr-&gt;sh_flags &amp; SHF_ALLOC) == 0 || (sec_hdr-&gt;sh_addr &gt;= segment-&gt;p_vaddr &amp;&amp; (sec_hdr-&gt;sh_addr + ELF_SECTION_SIZE(sec_hdr, segment) &lt;= segment-&gt;p_vaddr + segment-&gt;p_memsz))))</cpp:value></cpp:define>


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_IS_SECTION_IN_SEGMENT_FILE</name><parameter_list>(<parameter><type><name>sec_hdr</name></type></parameter>, <parameter><type><name>segment</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sec_hdr-&gt;sh_size &gt; 0 &amp;&amp; ELF_IS_SECTION_IN_SEGMENT (sec_hdr, segment))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_IS_SECTION_IN_SEGMENT_MEMORY</name><parameter_list>(<parameter><type><name>sec_hdr</name></type></parameter>, <parameter><type><name>segment</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ELF_SECTION_SIZE(sec_hdr, segment) &gt; 0 &amp;&amp; ELF_IS_SECTION_IN_SEGMENT (sec_hdr, segment))</cpp:value></cpp:define>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
