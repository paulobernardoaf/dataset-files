<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\core\windows_heap.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;TlHelp32.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows_heap.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"..\..\debug\p\native\maps\windows_maps.h"</cpp:file></cpp:include>









































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PDI_MODULES</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PDI_HEAPS</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PDI_HEAP_TAGS</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PDI_HEAP_BLOCKS</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PDI_HEAP_ENTRIES_EX</name></cpp:macro> <cpp:value>0x200</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>RtlpHpHeapGlobalsOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>RtlpLFHKeyOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_INFO</name><parameter_list>(<parameter><type><name>heapInfo</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (!heapInfo) {eprintf ("It wasn't possible to get the heap information\n");return;}if (!heapInfo-&gt;count) {r_cons_print ("No heaps for this process\n");return;}</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_FLAGS</name><parameter_list>(<parameter><type><name>hb</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (((flags) &amp; 0xf1) || ((flags) &amp; 0x0200)) {hb-&gt;dwFlags = LF32_FIXED;} else if ((flags) &amp; 0x20) {hb-&gt;dwFlags = LF32_MOVEABLE;} else if ((flags) &amp; 0x0100) {hb-&gt;dwFlags = LF32_FREE;}hb-&gt;dwFlags |= ((flags) &gt;&gt; SHIFT) &lt;&lt; SHIFT;</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <name>bool</name></type> <name>__is_windows_ten</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>major</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RSysInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>r_sys_info</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>info</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dot</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dot</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dot</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_sys_info_free</name> <argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>major</name> <operator>==</operator> <literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_type</name><parameter_list>(<parameter><decl><type><name>WPARAM</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LF32_FIXED</name></expr>:</case>
<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="string">"(FIXED)"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LF32_FREE</name></expr>:</case>
<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="string">"(FREE)"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LF32_MOVEABLE</name></expr>:</case>
<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="string">"(MOVEABLE)"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>heaptype</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SEGMENT_HEAP_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>heaptype</name> <operator>=</operator> <literal type="string">"Segment"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>NT_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>heaptype</name> <operator>=</operator> <literal type="string">"NT"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>LFH_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"/LFH"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>LARGE_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"/LARGE"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>BACKEND_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"/BACKEND"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>VS_BLOCK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"/VS"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s%s"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>heaptype</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>init_func</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>ntdll</name> <init>= <expr><call><name>LoadLibrary</name> <argument_list>(<argument><expr><call><name>TEXT</name> <argument_list>(<argument><expr><literal type="string">"ntdll.dll"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ntdll</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>RtlCreateQueryDebugBuffer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RtlCreateQueryDebugBuffer</name> <operator>=</operator> <operator>(</operator><call><call><name>PDEBUG_BUFFER</name> <argument_list>(<argument><expr><name>NTAPI</name> <operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>DWORD</name></expr></argument>, <argument><expr><name>BOOLEAN</name></expr></argument>)</argument_list></call><operator>)</operator><call><name>GetProcAddress</name> <argument_list>(<argument><expr><name>ntdll</name></expr></argument>, <argument><expr><literal type="string">"RtlCreateQueryDebugBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>RtlQueryProcessDebugInformation</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RtlQueryProcessDebugInformation</name> <operator>=</operator> <operator>(</operator><call><call><name>NTSTATUS</name> <argument_list>(<argument><expr><name>NTAPI</name> <operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>DWORD</name></expr></argument>, <argument><expr><name>DWORD</name></expr></argument>, <argument><expr><name>PDEBUG_BUFFER</name></expr></argument>)</argument_list></call><operator>)</operator><call><name>GetProcAddress</name> <argument_list>(<argument><expr><name>ntdll</name></expr></argument>, <argument><expr><literal type="string">"RtlQueryProcessDebugInformation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>RtlDestroyQueryDebugBuffer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RtlDestroyQueryDebugBuffer</name> <operator>=</operator> <operator>(</operator><call><call><name>NTSTATUS</name> <argument_list>(<argument><expr><name>NTAPI</name> <operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>PDEBUG_BUFFER</name></expr></argument>)</argument_list></call><operator>)</operator><call><name>GetProcAddress</name> <argument_list>(<argument><expr><name>ntdll</name></expr></argument>, <argument><expr><literal type="string">"RtlDestroyQueryDebugBuffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>w32_NtQueryInformationProcess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>w32_NtQueryInformationProcess</name> <operator>=</operator> <operator>(</operator><call><call><name>NTSTATUS</name> <argument_list>(<argument><expr><name>NTAPI</name> <operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>HANDLE</name></expr></argument>,<argument><expr><name>PROCESSINFOCLASS</name></expr></argument>,<argument><expr><name>PVOID</name></expr></argument>,<argument><expr><name>ULONG</name></expr></argument>,<argument><expr><name>PULONG</name></expr></argument>)</argument_list></call><operator>)</operator><call><name>GetProcAddress</name> <argument_list>(<argument><expr><name>ntdll</name></expr></argument>, <argument><expr><literal type="string">"NtQueryInformationProcess"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_segment_heap</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>, <parameter><decl><type><name>PVOID</name></type> <name>heapBase</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP</name></type> <name>heap</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>heapBase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heap</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>.</operator><name>SegmentSignature</name></name> <operator>==</operator> <literal type="number">0xddeeddee</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetFirstHeapBlock</name><parameter_list>(<parameter><decl><type><name>PDEBUG_HEAP_INFORMATION</name></type> <name>heapInfo</name></decl></parameter>, <parameter><decl><type><name>PHeapBlock</name></type> <name>hb</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>heapInfo</name> <operator>&amp;&amp;</operator> <name>hb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockBasicInfo</name></type> <name>block</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>(</operator><name>PHeapBlockBasicInfo</name><operator>)</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>Blocks</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SIZE_T</name></type> <name>index</name> <init>= <expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>BlockCount</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>address</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>&amp;</operator> <name>EXTRA_FLAG</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><operator>(</operator><name>PHeapBlockExtraInfo</name><operator>)</operator><operator>(</operator><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>&amp;</operator> <operator>~</operator><name>EXTRA_FLAG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>-=</operator> <name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>+</operator> <name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>+</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>Granularity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition>;</do>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>flags</name> <init>= <expr><name><name>block</name><index>[<expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name><operator>.</operator><name>flags</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UPDATE_FLAGS</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetNextHeapBlock</name><parameter_list>(<parameter><decl><type><name>PDEBUG_HEAP_INFORMATION</name></type> <name>heapInfo</name></decl></parameter>, <parameter><decl><type><name>PHeapBlock</name></type> <name>hb</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>heapInfo</name> <operator>&amp;&amp;</operator> <name>hb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockBasicInfo</name></type> <name>block</name></decl>;</decl_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <operator>(</operator><name>PHeapBlockBasicInfo</name><operator>)</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>Blocks</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SIZE_T</name></type> <name>index</name> <init>= <expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>BlockCount</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>BlockCount</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>address</name> <operator>+</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>Granularity</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition>;</do>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>&amp;</operator> <name>EXTRA_FLAG</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><operator>(</operator><name>PHeapBlockExtraInfo</name><operator>)</operator><operator>(</operator><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>&amp;</operator> <operator>~</operator><name>EXTRA_FLAG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>-=</operator> <name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>address</name> <operator>+</operator> <name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>+</operator> <name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>flags</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>&amp;</operator> <name>EXTRA_FLAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>flags</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>USHORT</name><operator>)</operator><name><name>block</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>flags</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>UPDATE_FLAGS</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_extra_info</name><parameter_list>(<parameter><decl><type><name>PDEBUG_HEAP_INFORMATION</name></type> <name>heap</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HeapBlock</name></type> <name>hb</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GetFirstHeapBlock</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>hb</name><operator>.</operator><name>extraInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>GetNextHeapBlock</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hb</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetHeapGlobalsOffset</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>modules</name> <init>= <expr><call><name>r_w32_dbg_modules</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>ntdll</name><index>[]</index></name> <init>= <expr><literal type="string">"ntdll.dll"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>lastNdtllAddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>modules</argument>, <argument>it</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>ntdll</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ntdll</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ntdll.dll not loaded."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>doopen</name> <init>= <expr><name>lastNdtllAddr</name> <operator>!=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ntdllopen</name> <init>= <expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"ob~%s"</literal></expr></argument>, <argument><expr><name>ntdll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ntdllopen</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>saddr</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>ntdllopen</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>saddr</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>doopen</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>ntdllopen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"o-%d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RtlpHpHeapGlobalsOffset</name> <operator>=</operator> <name>RtlpLFHKeyOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>doopen</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ntdllpath</name> <init>= <expr><call><name>r_lib_path</name> <argument_list>(<argument><expr><literal type="string">"ntdll"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Opening %s\n"</literal></expr></argument>, <argument><expr><name>ntdllpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"o %s 0x%"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>ntdllpath</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lastNdtllAddr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ntdllpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>RtlpHpHeapGlobalsOffset</name> <operator>||</operator> <operator>!</operator><name>RtlpLFHKeyOffset</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"idpi~RtlpHpHeapGlobals"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmd</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"idpd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"idpi~RtlpHpHeapGlobals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RtlpHpHeapGlobalsOffset</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"idpi~RtlpLFHKey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RtlpLFHKeyOffset</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>doopen</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdstrf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"o~%s"</literal></expr></argument>, <argument><expr><name>ntdll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>cmdf</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>corebind</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="string">"o-%d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetLFHKey</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>segment</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name> <modifier>*</modifier></type><name>lfhKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>lfhKeyLocation</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetHeapGlobalsOffset</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>lfhKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>segment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lfhKeyLocation</name> <operator>=</operator> <name>RtlpHpHeapGlobalsOffset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lfhKeyLocation</name> <operator>=</operator> <name>RtlpLFHKeyOffset</name></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>lfhKeyLocation</name></expr></argument>, <argument><expr><name>lfhKey</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"ReadProcessMemory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"LFH key not found.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>lfhKey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>DecodeHeapEntry</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>PHEAP</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>PHEAP_ENTRY</name></type> <name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>heap</name> <operator>&amp;&amp;</operator> <name>entry</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PHEAP_ENTRY</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>entry</name> <operator>+</operator> <name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>EncodeFlagMask</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>UINT32</name> <operator>*</operator><operator>)</operator><name>entry</name> <operator>&amp;</operator> <name><name>heap</name><operator>-&gt;</operator><name>EncodeFlagMask</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>heap</name> <operator>=</operator> <operator>(</operator><name>PHEAP</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>heap</name> <operator>+</operator> <name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><name>entry</name> <operator>^=</operator> <operator>*</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>heap</name><operator>-&gt;</operator><name>Encoding</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>DecodeLFHEntry</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>PHEAP</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>PHEAP_ENTRY</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>PHEAP_USERDATA_HEADER</name></type> <name>userBlocks</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>heap</name> <operator>&amp;&amp;</operator> <name>entry</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PHEAP_ENTRY</name><operator>)</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>entry</name> <operator>+</operator> <name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>EncodeFlagMask</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>DWORD</name> <operator>*</operator><operator>)</operator><name>entry</name> <operator>^=</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name><name>heap</name><operator>-&gt;</operator><name>BaseAddress</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>addr</name> <operator>-</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name>userBlocks</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">0xC</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>key</name> <operator>^</operator> <operator>(</operator><name>addr</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>^</operator> <operator>(</operator><operator>(</operator><name>BYTE</name> <operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>_th_query_params</name> <block>{
<decl_stmt><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>fin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>hanged</name></decl>;</decl_stmt>
}</block></struct></type> <name>th_query_params</name>;</typedef>

<function><type><specifier>static</specifier> <name>DWORD</name> <name>WINAPI</name></type> <name>__th_QueryDebugBuffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>th_query_params</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><operator>(</operator><name>th_query_params</name> <operator>*</operator><operator>)</operator><name>param</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>ret</name></name> <operator>=</operator> <call><name>RtlQueryProcessDebugInformation</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>fin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>hanged</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>GetListOfHeaps</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>ph</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>PROCESS_BASIC_INFORMATION</name></type> <name>pib</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>w32_NtQueryInformationProcess</name> <argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name>ProcessBasicInformation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pib</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>pib</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"NtQueryInformationProcess"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PEB</name></type> <name>peb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name><name>pib</name><operator>.</operator><name>PebBaseAddress</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peb</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>PEB</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>heaps</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name></type> <name>heapAddress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PVOID</name> <modifier>*</modifier></type><name>processHeaps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>numberOfHeaps</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>processHeaps</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>PVOID</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>peb</name><operator>)</operator> <operator>+</operator> <literal type="number">0xF0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>numberOfHeaps</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ULONG</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator> <name>peb</name><operator>)</operator> <operator>+</operator> <literal type="number">0xE8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>processHeaps</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>PVOID</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>peb</name><operator>)</operator> <operator>+</operator> <literal type="number">0x90</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>numberOfHeaps</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ULONG</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator> <name>peb</name><operator>)</operator> <operator>+</operator> <literal type="number">0x88</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name>processHeaps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapAddress</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>PVOID</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>heaps</name></expr></argument>, <argument><expr><name>heapAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>processHeaps</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>--</operator><name>numberOfHeaps</name></expr>)</condition>;</do>
<return>return <expr><name>heaps</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>PDEBUG_BUFFER</name></type> <name>InitHeapInfo</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>



<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name> <init>= <expr><call><name>RtlCreateQueryDebugBuffer</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>th_query_params</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>th_query_params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>params</name> <operator>=</operator> <operator>(</operator><name>th_query_params</name><operator>)</operator> <block>{ <expr><name>dbg</name></expr>, <expr><name>mask</name></expr>, <expr><name>db</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>th</name> <init>= <expr><call><name>CreateThread</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>__th_QueryDebugBuffer</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>th</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>WaitForSingleObject</name> <argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>fin</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>hanged</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"RtlQueryProcessDebugInformation hanged\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>db</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>ret</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>db</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"RtlQueryProcessDebugInformation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>db</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>==</operator> <name>PDI_HEAPS</name> <operator>&amp;&amp;</operator> <call><name>__is_windows_ten</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>RtlCreateQueryDebugBuffer</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PHeapInformation</name></type> <name>heapInfo</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapInformation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>heapInfo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h_proc</name> <init>= <expr><call><name>OpenProcess</name> <argument_list>(<argument><expr><name>PROCESS_QUERY_INFORMATION</name> <operator>|</operator> <name>PROCESS_VM_READ</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"OpenProcess failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>heaps</name> <init>= <expr><call><name>GetListOfHeaps</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>heaps</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DEBUG_HEAP_INFORMATION</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>heapInfo</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>heapBase</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>heaps</argument>, <argument>it</argument>, <argument>heapBase</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Base</name> <operator>=</operator> <name>heapBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Granularity</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Allocated</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Committed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name> <operator>=</operator> <name>heapInfo</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>heaps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>db</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GROW_BLOCKS</name><parameter_list>()</parameter_list></cpp:macro><cpp:value>if (allocated &lt;= count * sizeof (HeapBlockBasicInfo)) {SIZE_T old_alloc = allocated;allocated *= 2;PVOID tmp = blocks;blocks = realloc (blocks, allocated);if (!blocks) {blocks = tmp;goto err;}memset ((BYTE *)blocks + old_alloc, 0, old_alloc);}</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GROW_PBLOCKS</name><parameter_list>()</parameter_list></cpp:macro><cpp:value>if (*allocated &lt;= *count * sizeof (HeapBlockBasicInfo)) {SIZE_T old_alloc = *allocated;*allocated *= 2;PVOID tmp = *blocks;tmp = realloc (*blocks, *allocated);if (!tmp) {return false;}*blocks = tmp;memset ((BYTE *)(*blocks) + old_alloc, 0, old_alloc);}</cpp:value></cpp:define>












<function><type><specifier>static</specifier> <name>bool</name></type> <name>__lfh_segment_loop</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>, <parameter><decl><type><name>PHeapBlockBasicInfo</name> <modifier>*</modifier></type><name>blocks</name></decl></parameter>, <parameter><decl><type><name>SIZE_T</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>lfhKey</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>next</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>first</name> <operator>!=</operator> <name>next</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>next</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT</name></type> <name>subsegment</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LFH_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>EncodedData</name></name> <operator>^=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>lfhKey</name> <operator>^</operator> <operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>next</name> <operator>&gt;&gt;</operator> <literal type="number">0xC</literal><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>mask</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>l</name> <operator>&lt;</operator> <name><name>subsegment</name><operator>.</operator><name>BlockCount</name></name></expr>;</condition> <incr><expr><name>l</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>next</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_LFH_SUBSEGMENT</name></expr></argument>, <argument><expr><name>BlockBitmap</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <name>offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>subsegment</name><operator>.</operator><name>BlockBitmap</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>subsegment</name><operator>.</operator><name>BlockBitmap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GROW_PBLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>off</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>FirstBlockOffset</name></name> <operator>+</operator> <name>l</name> <operator>*</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>BlockSize</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>address</name> <operator>=</operator> <name>next</name> <operator>+</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>size</name> <operator>=</operator> <name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>BlockSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>LFH_BLOCK</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>subsegment</name><operator>.</operator><name>ListEntry</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>GetSegmentHeapBlocks</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>, <parameter><decl><type><name>PVOID</name></type> <name>heapBase</name></decl></parameter>, <parameter><decl><type><name>PHeapBlockBasicInfo</name> <modifier>*</modifier></type><name>blocks</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>SIZE_T</name> <modifier>*</modifier></type><name>allocated</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>h_proc</name> <operator>&amp;&amp;</operator> <name>blocks</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>allocated</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>bytesRead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SEGMENT_HEAP</name></type> <name>segheapHeader</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>heapBase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segheapHeader</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SEGMENT_HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>segheapHeader</name><operator>.</operator><name>Signature</name></name> <operator>!=</operator> <literal type="number">0xddeeddee</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>lfhKey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>lfhKeyLocation</name> <init>= <expr><name>RtlpHpHeapGlobalsOffset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>lfhKeyLocation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfhKey</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"ReadProcessMemory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"LFH key not found.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>byte</name></type> <name>numBuckets</name> <init>= <expr><call><name>_countof</name> <argument_list>(<argument><expr><name><name>segheapHeader</name><operator>.</operator><name>LfhContext</name><operator>.</operator><name>Buckets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numBuckets</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>segheapHeader</name><operator>.</operator><name>LfhContext</name><operator>.</operator><name>Buckets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_BUCKET</name></type> <name>bucket</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>segheapHeader</name><operator>.</operator><name>LfhContext</name><operator>.</operator><name>Buckets</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bucket</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LFH_BUCKET</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HEAP_LFH_AFFINITY_SLOT</name></type> <name>affinitySlot</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>paffinitySlot</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>bucket</name><operator>.</operator><name>AffinitySlots</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paffinitySlot</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>PHEAP_LFH_AFFINITY_SLOT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bucket</name><operator>.</operator><name>AffinitySlots</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>paffinitySlot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>affinitySlot</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LFH_AFFINITY_SLOT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>first</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name>paffinitySlot</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_LFH_SUBSEGMENT_OWNER</name></expr></argument>, <argument><expr><name>AvailableSubsegmentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>next</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>affinitySlot</name><operator>.</operator><name>State</name><operator>.</operator><name>AvailableSubsegmentList</name><operator>.</operator><name>Flink</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>__lfh_segment_loop</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>allocated</name></expr></argument>, <argument><expr><name>lfhKey</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>paffinitySlot</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_LFH_SUBSEGMENT_OWNER</name></expr></argument>, <argument><expr><name>FullSubsegmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>affinitySlot</name><operator>.</operator><name>State</name><operator>.</operator><name>FullSubsegmentList</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>__lfh_segment_loop</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>allocated</name></expr></argument>, <argument><expr><name>lfhKey</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>segheapHeader</name><operator>.</operator><name>LargeAllocMetadata</name><operator>.</operator><name>Root</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>node</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RTL_BALANCED_NODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RStack</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_stack_new</name> <argument_list>(<argument><expr><name><name>segheapHeader</name><operator>.</operator><name>LargeReservedPages</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRTL_BALANCED_NODE</name></type> <name>curr</name> <init>= <expr><name><name>segheapHeader</name><operator>.</operator><name>LargeAllocMetadata</name><operator>.</operator><name>Root</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content> 
<expr_stmt><expr><call><name>GROW_PBLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>curr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_stack_push</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RTL_BALANCED_NODE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>Left</name></name></expr>;</expr_stmt>
</block_content>}</block></while><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>curr</name> <operator>=</operator> <operator>(</operator><name>PRTL_BALANCED_NODE</name><operator>)</operator><call><name>r_stack_pop</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HEAP_LARGE_ALLOC_DATA</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LARGE_ALLOC_DATA</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>address</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>VirtualAddess</name></name> <operator>-</operator> <name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>LARGE_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>entry</name><operator>.</operator><name>AllocatedPages</name></name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>USHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>TreeNode</name><operator>.</operator><name>Right</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>curr</name> <operator>||</operator> <operator>!</operator><call><name>r_stack_is_empty</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><call><name>r_stack_free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>RtlpHpHeapGlobal</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>RtlpHpHeapGlobalsOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RtlpHpHeapGlobal</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_SEG_CONTEXT</name></type> <name>ctx</name> <init>= <expr><name><name>segheapHeader</name><operator>.</operator><name>SegContexts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>ctxFirstEntry</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name>heapBase</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>SEGMENT_HEAP</name></expr></argument>, <argument><expr><name>SegContexts</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SEG_CONTEXT</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>i</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_SEG_CONTEXT</name></expr></argument>, <argument><expr><name>SegmentListHead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_PAGE_SEGMENT</name></type> <name>pageSegment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>currPageSegment</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>ctx</name><operator>.</operator><name>SegmentListHead</name><operator>.</operator><name>Flink</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>currPageSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageSegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_PAGE_SEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>WPARAM</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pageSegment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>RangeFlags</name> <operator>&amp;</operator>
<operator>(</operator><name>PAGE_RANGE_FLAGS_FIRST</name> <operator>|</operator> <name>PAGE_RANGE_FLAGS_ALLOCATED</name><operator>)</operator><operator>)</operator> <operator>==</operator>
<operator>(</operator><name>PAGE_RANGE_FLAGS_FIRST</name> <operator>|</operator> <name>PAGE_RANGE_FLAGS_ALLOCATED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GROW_PBLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>address</name> <operator>=</operator> <name>currPageSegment</name> <operator>+</operator> <name>j</name> <operator>*</operator> <literal type="number">0x1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>pageSegment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>UnitSize</name> <operator>*</operator> <literal type="number">0x1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>flags</name> <operator>=</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>BACKEND_BLOCK</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>currPageSegment</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name> <operator>=</operator> <name><name>pageSegment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>UnusedBytes</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pageSegment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>RangeFlags</name> <operator>&amp;</operator> <literal type="number">0xF</literal> <operator>&amp;&amp;</operator> <name><name>pageSegment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>UnusedBytes</name> <operator>==</operator> <literal type="number">0x1000</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VS_SUBSEGMENT</name></type> <name>vsSubsegment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>from</name> <init>= <expr><name>currPageSegment</name> <operator>+</operator> <name>j</name> <operator>*</operator> <literal type="number">0x1000</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsSubsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>from</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<while>while <condition>(<expr><name>from</name> <operator>&lt;</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>start</name> <operator>+</operator> <name><name>vsSubsegment</name><operator>.</operator><name>Size</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VS_CHUNK_HEADER</name></type> <name>vsChunk</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsChunk</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vsChunk</name><operator>.</operator><name>Sizes</name><operator>.</operator><name>HeaderBits</name></name> <operator>^=</operator> <name>from</name> <operator>^</operator> <name>RtlpHpHeapGlobal</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>sz</name> <init>= <expr><name><name>vsChunk</name><operator>.</operator><name>Sizes</name><operator>.</operator><name>UnsafeSize</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vsChunk</name><operator>.</operator><name>Sizes</name><operator>.</operator><name>Allocated</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GROW_PBLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>address</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>flags</name> <operator>=</operator> <name>VS_BLOCK</name> <operator>|</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>blocks</name><operator>)</operator><index>[<expr><operator>*</operator><name>count</name></expr>]</index><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>currPageSegment</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>pageSegment</name><operator>.</operator><name>ListEntry</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>currPageSegment</name> <operator>&amp;&amp;</operator> <name>currPageSegment</name> <operator>!=</operator> <name>ctxFirstEntry</name></expr>)</condition>;</do>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PDEBUG_BUFFER</name></type> <name>GetHeapBlocks</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_32</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return> 
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>bytesRead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h_proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name> <init>= <expr><call><name>InitHeapInfo</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PDI_HEAPS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name> <operator>||</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"InitHeapInfo Failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>h_proc</name> <operator>=</operator> <call><name>OpenProcess</name> <argument_list>(<argument><expr><name>PROCESS_QUERY_INFORMATION</name> <operator>|</operator> <name>PROCESS_VM_READ</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"OpenProcess failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>lfhKey</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetLFHKey</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfhKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"GetHeapBlocks: Failed to get LFH key.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>PHeapInformation</name></type> <name>heapInfo</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>from</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_HEAP_INFORMATION</name></type> <name>heap</name> <init>= <expr><operator>&amp;</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>heapEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP</name></type> <name>heapHeader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>SIZE_T</name></type> <name>sz_entry</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heap</name><operator>-&gt;</operator><name>Base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapHeader</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>SIZE_T</name></type> <name>allocated</name> <init>= <expr><literal type="number">128</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HeapBlockBasicInfo</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHeapBlockBasicInfo</name></type> <name>blocks</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>allocated</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>blocks</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Memory Allocation failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>heapHeader</name><operator>.</operator><name>SegmentSignature</name></name> <operator>==</operator> <literal type="number">0xddeeddee</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>GetSegmentHeapBlocks</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heap</name><operator>-&gt;</operator><name>Base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocated</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>Blocks</name></name> <operator>=</operator> <name>blocks</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>BlockCount</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>PLIST_ENTRY</name></type> <name>fentry</name> <init>= <expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>heapHeader</name><operator>.</operator><name>BaseAddress</name></name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP</name></expr></argument>, <argument><expr><name>VirtualAllocdBlocks</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PLIST_ENTRY</name></type> <name>entry</name> <init>= <expr><name><name>heapHeader</name><operator>.</operator><name>VirtualAllocdBlocks</name><operator>.</operator><name>Flink</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>entry</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>entry</name> <operator>!=</operator> <name>fentry</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></type> <name>vAlloc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vAlloc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DecodeHeapEntry</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapHeader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vAlloc</name><operator>.</operator><name>BusyBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GROW_BLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>address</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>vAlloc</name><operator>.</operator><name>BusyBlock</name><operator>.</operator><name>Flags</name></name> <operator>|</operator> <name>NT_BLOCK</name> <operator>|</operator> <name>LARGE_BLOCK</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">2ULL</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name><name>vAlloc</name><operator>.</operator><name>ReserveSize</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name> <operator>=</operator> <name><name>vAlloc</name><operator>.</operator><name>ReserveSize</name></name> <operator>-</operator> <name><name>vAlloc</name><operator>.</operator><name>CommitSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>vAlloc</name><operator>.</operator><name>Entry</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>heapHeader</name><operator>.</operator><name>FrontEndHeap</name></name> <operator>&amp;&amp;</operator> <name><name>heapHeader</name><operator>.</operator><name>FrontEndHeapType</name></name> <operator>==</operator> <literal type="number">0x2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>LFH_HEAP</name></type> <name>lfhHeader</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heapHeader</name><operator>.</operator><name>FrontEndHeap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfhHeader</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>LFH_HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"ReadProcessMemory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>PLIST_ENTRY</name></type> <name>curEntry</name></decl>, <decl><type ref="prev"/><name>firstEntry</name> <init>= <expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>heapHeader</name><operator>.</operator><name>FrontEndHeap</name></name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>LFH_HEAP</name></expr></argument>, <argument><expr><name>SubSegmentZones</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>curEntry</name> <operator>=</operator> <name><name>lfhHeader</name><operator>.</operator><name>SubSegmentZones</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>


<do>do <block>{<block_content> 
<decl_stmt><decl><type><name>HEAP_LOCAL_SEGMENT_INFO</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_LOCAL_DATA</name></type> <name>localData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_SUBSEGMENT</name></type> <name>subsegment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_USERDATA_HEADER</name></type> <name>userdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LFH_BLOCK_ZONE</name></type> <name>blockZone</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>curSubsegment</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><operator>(</operator><name>curEntry</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>curSubsegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator><name><name>subsegment</name><operator>.</operator><name>BlockSize</name></name>
<operator>||</operator> <operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>subsegment</name><operator>.</operator><name>LocalInfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LOCAL_SEGMENT_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>LocalData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>localData</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LOCAL_DATA</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>localData</name><operator>.</operator><name>CrtZone</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockZone</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>LFH_BLOCK_ZONE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subsegment</name><operator>.</operator><name>UserBlocks</name></name> <operator>||</operator> <operator>!</operator><name><name>subsegment</name><operator>.</operator><name>BlockSize</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>next_subsegment</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><name><name>subsegment</name><operator>.</operator><name>BlockSize</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>subsegment</name><operator>.</operator><name>UserBlocks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>userdata</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_USERDATA_HEADER</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>userdata</name><operator>.</operator><name>EncodedOffsets</name><operator>.</operator><name>StrideAndOffset</name></name> <operator>^=</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name><name>subsegment</name><operator>.</operator><name>UserBlocks</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name><name>heapHeader</name><operator>.</operator><name>FrontEndHeap</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>lfhKey</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bitmapsz</name> <init>= <expr><operator>(</operator><name><name>userdata</name><operator>.</operator><name>BusyBitmap</name><operator>.</operator><name>SizeOfBitMap</name></name> <operator>+</operator> <literal type="number">8</literal> <operator>-</operator> <name><name>userdata</name><operator>.</operator><name>BusyBitmap</name><operator>.</operator><name>SizeOfBitMap</name></name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name> <modifier>*</modifier></type><name>bitmap</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><ternary><condition><expr><name>bitmapsz</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><name>bitmapsz</name></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>userdata</name><operator>.</operator><name>BusyBitmap</name><operator>.</operator><name>Buffer</name></name></expr></argument>, <argument><expr><name>bitmap</name></expr></argument>, <argument><expr><name>bitmapsz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>mask</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>userdata</name><operator>.</operator><name>BusyBitmap</name><operator>.</operator><name>SizeOfBitMap</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>bitmap</name> <operator>+</operator> <name>offset</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GROW_BLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>off</name> <init>= <expr><name><name>userdata</name><operator>.</operator><name>EncodedOffsets</name><operator>.</operator><name>FirstAllocationOffset</name></name> <operator>+</operator> <name>sz</name> <operator>*</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>from</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>subsegment</name><operator>.</operator><name>UserBlocks</name></name> <operator>+</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapEntry</name></expr></argument>, <argument><expr><name>sz_entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DecodeLFHEntry</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapHeader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapEntry</name></expr></argument>, <argument><expr><name><name>subsegment</name><operator>.</operator><name>UserBlocks</name></name></expr></argument>, <argument><expr><name>lfhKey</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>address</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>NT_BLOCK</name> <operator>|</operator> <name>LFH_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>curSubsegment</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>next_subsegment</name>:</label>
<expr_stmt><expr><name>curSubsegment</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>next</name> <operator>&lt;</operator> <name><name>blockZone</name><operator>.</operator><name>NextIndex</name></name> <operator>||</operator> <name><name>subsegment</name><operator>.</operator><name>BlockSize</name></name></expr>)</condition>;</do>

<decl_stmt><decl><type><name>LIST_ENTRY</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>curEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curEntry</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>Flink</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>curEntry</name> <operator>!=</operator> <name>firstEntry</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>HEAP_SEGMENT</name></type> <name>oldSegment</name></decl>, <decl><type ref="prev"/><name>segment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>firstSegment</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>heapHeader</name><operator>.</operator><name>SegmentList</name><operator>.</operator><name>Flink</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><name>firstSegment</name> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_SEGMENT</name></expr></argument>, <argument><expr><name>SegmentListEntry</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>segment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><name>from</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>segment</name><operator>.</operator><name>FirstEntry</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>next</name>;</goto>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapEntry</name></expr></argument>, <argument><expr><name>sz_entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DecodeHeapEntry</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapHeader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heapEntry</name><operator>.</operator><name>Size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SIZE_T</name></type> <name>real_sz</name> <init>= <expr><name><name>heapEntry</name><operator>.</operator><name>Size</name></name> <operator>*</operator> <name>sz_entry</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GROW_BLOCKS</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>segment</name><operator>.</operator><name>BaseAddress</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>extra</name> <operator>=</operator> <name>EXTRA_FLAG</name> <operator>|</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>address</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>heapEntry</name><operator>.</operator><name>Flags</name></name> <operator>|</operator> <name>NT_BLOCK</name> <operator>|</operator> <name>BACKEND_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>real_sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <name>real_sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>from</name> <operator>&lt;=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>segment</name><operator>.</operator><name>LastValidEntry</name></name></expr>)</condition>;</do>
<label><name>next</name>:</label>
<expr_stmt><expr><name>oldSegment</name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>segment</name><operator>.</operator><name>SegmentListEntry</name><operator>.</operator><name>Flink</name></name> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>HEAP_SEGMENT</name></expr></argument>, <argument><expr><name>SegmentListEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>oldSegment</name><operator>.</operator><name>SegmentListEntry</name><operator>.</operator><name>Flink</name></name> <operator>!=</operator> <name>firstSegment</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>Blocks</name></name> <operator>=</operator> <name>blocks</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>BlockCount</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>Committed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>heap</name><operator>-&gt;</operator><name>Allocated</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>Committed</name></name> <operator>=</operator> <name><name>heapHeader</name><operator>.</operator><name>Counters</name><operator>.</operator><name>TotalMemoryCommitted</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heap</name><operator>-&gt;</operator><name>Allocated</name></name> <operator>=</operator> <name><name>heapHeader</name><operator>.</operator><name>Counters</name><operator>.</operator><name>LastPolledSize</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>db</name></expr>;</return>
<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><name>h_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>PDEBUG_HEAP_INFORMATION</name></type> <name>heap</name> <init>= <expr><operator>&amp;</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_extra_info</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>heap</name><operator>-&gt;</operator><name>Blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PHeapBlock</name></type> <name>GetSingleSegmentBlock</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type> <name>h_proc</name></decl></parameter>, <parameter><decl><type><name>PSEGMENT_HEAP</name></type> <name>heapBase</name></decl></parameter>, <parameter><decl><type><name>WPARAM</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><name>PHeapBlock</name></type> <name>hb</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"GetSingleSegmentBlock: Allocation failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"GetSingleSegmentBlock: Allocation failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name>heapBase</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>granularity</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>headerOff</name> <init>= <expr><name>offset</name> <operator>-</operator> <name>granularity</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SEGMENT_HEAP</name></type> <name>heap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>heapBase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heap</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SEGMENT_HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>RtlpHpHeapGlobal</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>RtlpHpHeapGlobalsOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RtlpHpHeapGlobal</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>pgSegOff</name> <init>= <expr><name>headerOff</name> <operator>&amp;</operator> <name><name>heap</name><operator>.</operator><name>SegContexts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>SegmentMask</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>segSignature</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><name>pgSegOff</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>LIST_ENTRY</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>segSignature</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>WPARAM</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<decl_stmt><decl><type><name>WPARAM</name></type> <name>test</name> <init>= <expr><name>RtlpHpHeapGlobal</name> <operator>^</operator> <name>pgSegOff</name> <operator>^</operator> <name>segSignature</name> <operator>^</operator> <operator>(</operator><operator>(</operator><name>WPARAM</name><operator>)</operator><name>heapBase</name> <operator>+</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>SEGMENT_HEAP</name></expr></argument>, <argument><expr><name>SegContexts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>test</name> <operator>==</operator> <literal type="number">0xa2e64eada2e64ead</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>HEAP_PAGE_SEGMENT</name></type> <name>segment</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>pgSegOff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_PAGE_SEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>pgRangeDescOff</name> <init>= <expr><operator>(</operator><operator>(</operator><name>headerOff</name> <operator>-</operator> <name>pgSegOff</name><operator>)</operator> <operator>&gt;&gt;</operator> <name><name>heap</name><operator>.</operator><name>SegContexts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>UnitShift</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>pageIndex</name> <init>= <expr><name>pgRangeDescOff</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_PAGE_RANGE_DESCRIPTOR</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>segment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>pageIndex</name></expr>]</index></name><operator>.</operator><name>RangeFlags</name> <operator>&amp;</operator> <name>PAGE_RANGE_FLAGS_FIRST</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pageIndex</name> <operator>-=</operator> <name><name>segment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>pageIndex</name></expr>]</index></name><operator>.</operator><name>UnitOffset</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>WPARAM</name></type> <name>subsegmentOffset</name> <init>= <expr><name>pgSegOff</name> <operator>+</operator> <name>pageIndex</name> <operator>*</operator> <literal type="number">0x1000</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>segment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>pageIndex</name></expr>]</index></name><operator>.</operator><name>RangeFlags</name> <operator>&amp;</operator> <literal type="number">0xF</literal> <operator>&amp;&amp;</operator> <name><name>segment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>pageIndex</name></expr>]</index></name><operator>.</operator><name>UnusedBytes</name> <operator>==</operator> <literal type="number">0x1000</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VS_SUBSEGMENT</name></type> <name>subsegment</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>subsegmentOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subsegment</name><operator>.</operator><name>Size</name></name> <operator>^</operator> <literal type="number">0x2BED</literal><operator>)</operator> <operator>==</operator> <name><name>subsegment</name><operator>.</operator><name>Signature</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VS_CHUNK_HEADER</name></type> <name>header</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><name>headerOff</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>header</name><operator>.</operator><name>Sizes</name><operator>.</operator><name>HeaderBits</name></name> <operator>^=</operator> <name>RtlpHpHeapGlobal</name> <operator>^</operator> <name>headerOff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>header</name><operator>.</operator><name>Sizes</name><operator>.</operator><name>UnsafeSize</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>VS_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <name>granularity</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VS_CHUNK_HEADER</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>subsegmentOffset</name></expr>;</expr_stmt>
<return>return <expr><name>hb</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>segment</name><operator>.</operator><name>DescArray</name><index>[<expr><name>pageIndex</name></expr>]</index></name><operator>.</operator><name>RangeFlags</name> <operator>&amp;</operator> <name>PAGE_RANGE_FLAGS_LFH_SUBSEGMENT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_LFH_SUBSEGMENT</name></type> <name>subsegment</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>subsegmentOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LFH_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>lfhKey</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetLFHKey</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lfhKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>EncodedData</name></name> <operator>^=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>lfhKey</name> <operator>^</operator> <operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>subsegmentOffset</name> <operator>&gt;&gt;</operator> <literal type="number">0xC</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>subsegment</name><operator>.</operator><name>BlockOffsets</name><operator>.</operator><name>BlockSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>LFH_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <name>granularity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>subsegmentOffset</name></expr>;</expr_stmt>
<return>return <expr><name>hb</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x100</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>heap</name><operator>.</operator><name>LargeAllocMetadata</name><operator>.</operator><name>Root</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RTL_BALANCED_NODE</name></type> <name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>curr</name> <init>= <expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>LargeAllocMetadata</name><operator>.</operator><name>Root</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>curr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RTL_BALANCED_NODE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>curr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_LARGE_ALLOC_DATA</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>curr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_LARGE_ALLOC_DATA</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>VirtualAddess</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>VirtualAddess</name></name> <operator>-</operator> <name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFFULL</literal><operator>)</operator> <operator>&gt;</operator> <name>VirtualAddess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>curr</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>node</name><operator>.</operator><name>Right</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFFULL</literal><operator>)</operator> <operator>&lt;</operator> <name>VirtualAddess</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>curr</name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>node</name><operator>.</operator><name>Left</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name>VirtualAddess</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>entry</name><operator>.</operator><name>AllocatedPages</name></name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>-</operator> <name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>=</operator> <name>SEGMENT_HEAP_BLOCK</name> <operator>|</operator> <name>LARGE_BLOCK</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>USHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hb</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>curr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>curr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RTL_BALANCED_NODE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PHeapBlock</name></type> <name>GetSingleBlock</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>PHeapBlock</name></type> <name>hb</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PHeapBlockExtraInfo</name></type> <name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"GetSingleBlock: Allocation failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h_proc</name> <init>= <expr><call><name>OpenProcess</name> <argument_list>(<argument><expr><name>PROCESS_QUERY_INFORMATION</name> <operator>|</operator> <name>PROCESS_VM_READ</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"GetSingleBlock/OpenProcess"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>InitHeapInfo</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PDI_HEAPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HeapBlockExtraInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"GetSingleBlock: Allocation failed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>NtLFHKey</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetLFHKey</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NtLFHKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapInformation</name></type> <name>heapInfo</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DEBUG_HEAP_INFORMATION</name></type> <name>heap</name> <init>= <expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_segment_heap</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heap</name><operator>.</operator><name>Base</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hb</name> <operator>=</operator> <call><name>GetSingleSegmentBlock</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heap</name><operator>.</operator><name>Base</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hb</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>HEAP</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>entryOffset</name> <init>= <expr><name>offset</name> <operator>-</operator> <name><name>heap</name><operator>.</operator><name>Granularity</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><name><name>heap</name><operator>.</operator><name>Base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>entryOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_ENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <name><name>heap</name><operator>.</operator><name>Granularity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HEAP_ENTRY</name></type> <name>tmpEntry</name> <init>= <expr><name>entry</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DecodeHeapEntry</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpEntry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>tmpEntry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UPDATE_FLAGS</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name><name>entry</name><operator>.</operator><name>Flags</name></name> <operator>|</operator> <name>NT_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name> <operator>==</operator> <literal type="number">0x4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></type> <name>largeEntry</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>largeEntry</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <name><name>largeEntry</name><operator>.</operator><name>CommitSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>|=</operator> <name>LARGE_BLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>unusedBytes</name></name> <operator>=</operator> <name><name>largeEntry</name><operator>.</operator><name>ReserveSize</name></name> <operator>-</operator> <name><name>largeEntry</name><operator>.</operator><name>CommitSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>granularity</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_VIRTUAL_ALLOC_ENTRY</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>entry</name><operator>.</operator><name>Size</name></name> <operator>*</operator> <name><name>heap</name><operator>.</operator><name>Granularity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>|=</operator> <name>BACKEND_BLOCK</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>UnusedBytes</name></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpEntry</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>WPARAM</name></type> <name>userBlocksOffset</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmpEntry</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>^=</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name><name>h</name><operator>.</operator><name>BaseAddress</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><name>entryOffset</name> <operator>&gt;&gt;</operator> <literal type="number">0x4</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>NtLFHKey</name></expr>;</expr_stmt>
<expr_stmt><expr><name>userBlocksOffset</name> <operator>=</operator> <name>entryOffset</name> <operator>-</operator> <operator>(</operator><name>USHORT</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmpEntry</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">0xC</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmpEntry</name><operator>)</operator> <operator>^=</operator> <call><name>PtrToInt</name> <argument_list>(<argument><expr><name><name>h</name><operator>.</operator><name>BaseAddress</name></name></expr></argument>)</argument_list></call> <operator>^</operator> <operator>(</operator><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>entryOffset</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">0x4</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>NtLFHKey</name></expr>;</expr_stmt>
<expr_stmt><expr><name>userBlocksOffset</name> <operator>=</operator> <name>entryOffset</name> <operator>-</operator> <operator>(</operator><name>USHORT</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>WPARAM</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tmpEntry</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">0xC</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DecodeLFHEntry</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>userBlocksOffset</name></expr></argument>, <argument><expr><name>NtLFHKey</name></expr></argument>, <argument><expr><name>entryOffset</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HEAP_USERDATA_HEADER</name></type> <name>UserBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HEAP_SUBSEGMENT</name></type> <name>subsegment</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name>userBlocksOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>UserBlocks</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_USERDATA_HEADER</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"GetSingleBlock/ReadProcessMemory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadProcessMemory</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>, <argument><expr><operator>(</operator><name>PVOID</name><operator>)</operator><name><name>UserBlocks</name><operator>.</operator><name>SubSegment</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subsegment</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HEAP_SUBSEGMENT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name> <operator>=</operator> <operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>subsegment</name><operator>.</operator><name>BlockSize</name></name> <operator>*</operator> <name><name>heap</name><operator>.</operator><name>Granularity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <name>LFH_BLOCK</name> <operator>|</operator> <name>NT_BLOCK</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hb</name></expr>;</return>
<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><name>h_proc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>h_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RTable</name> <modifier>*</modifier></type><name>__new_heapblock_tbl</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>r_table_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"HeaderAddress"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"UserAddress"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Size"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Granularity"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Unused"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"String"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Type"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>w32_list_heaps</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>format</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ULONG</name></type> <name>pid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name> <init>= <expr><call><name>InitHeapInfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>PDI_HEAPS</name> <operator>|</operator> <name>PDI_HEAP_BLOCKS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>__is_windows_ten</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>GetHeapBlocks</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Couldn't get heap info.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PHeapInformation</name></type> <name>heapInfo</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_INFO</name> <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>r_table_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Address"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Blocks"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Allocated"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Commited"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DEBUG_HEAP_INFORMATION</name></type> <name>heap</name> <init>= <expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"address"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>BlockCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"allocated"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"committed"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Committed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_table_add_rowf</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><literal type="string">"xnnn"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Base</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>BlockCount</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Allocated</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>heap</name><operator>.</operator><name>Committed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>InfoClassMask</name></name> <operator>&amp;</operator> <name>PDI_HEAP_BLOCKS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free_extra_info</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>heap</name><operator>.</operator><name>Blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>w32_list_heaps_blocks</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>format</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DWORD</name></type> <name>pid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PDEBUG_BUFFER</name></type> <name>db</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>__is_windows_ten</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>GetHeapBlocks</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>InitHeapInfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>PDI_HEAPS</name> <operator>|</operator> <name>PDI_HEAP_BLOCKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Couldn't get heap info.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PHeapInformation</name></type> <name>heapInfo</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>HeapInformation</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_INFO</name> <argument_list>(<argument><expr><name>heapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HeapBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>HeapBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>__new_heapblock_tbl</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>heapInfo</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>go</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>BlockCount</name> <operator>&gt;</operator> <literal type="number">50000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>go</name> <operator>=</operator> <call><name>r_cons_yesno</name> <argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><literal type="string">"Are you sure you want to add %"</literal><name>PFMT64u</name><literal type="string">" flags? (y/N)"</literal></expr></argument>, <argument><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>BlockCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>, <argument><expr><operator>(</operator><name>WPARAM</name><operator>)</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"blocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GetFirstHeapBlock</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>go</name></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_type</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>dwFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>granularity</name> <init>= <expr><ternary><condition><expr><name><name>block</name><operator>-&gt;</operator><name>extraInfo</name></name></expr> ?</condition><then> <expr><name><name>block</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>granularity</name></name></expr> </then><else>: <expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Granularity</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>address</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>dwAddress</name></name> <operator>-</operator> <name>granularity</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>unusedBytes</name> <init>= <expr><ternary><condition><expr><name><name>block</name><operator>-&gt;</operator><name>extraInfo</name></name></expr> ?</condition><then> <expr><name><name>block</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"alloc.%"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>dwSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"header_address"</literal></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"user_address"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>dwAddress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"unused"</literal></expr></argument>, <argument><expr><name>unusedBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>dwSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_table_add_rowf</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><literal type="string">"xxnnns"</literal></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>dwAddress</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>dwSize</name></name></expr></argument>, <argument><expr><name>granularity</name></expr></argument>, <argument><expr><name>unusedBytes</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block> while <condition>(<expr><call><name>GetNextHeapBlock</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>InfoClassMask</name></name> <operator>&amp;</operator> <name>PDI_HEAP_BLOCKS</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free_extra_info</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>heapInfo</name><operator>-&gt;</operator><name>heaps</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>format</name> <operator>!=</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RtlDestroyQueryDebugBuffer</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">" dmh[?|b][f|j]"</literal></expr>, <expr><literal type="string">" #Memory map heap"</literal></expr>,
<expr><literal type="string">"dmh[j]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List process heaps"</literal></expr>,
<expr><literal type="string">"dmhb[?] [addr]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List process heap blocks"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_block</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">" dmhb[f|j]"</literal></expr>, <expr><literal type="string">" #Memory map heap"</literal></expr>,
<expr><literal type="string">"dmhb [addr]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List allocated heap blocks"</literal></expr>,
<expr><literal type="string">"dmhbf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Create flags for each allocated block"</literal></expr>,
<expr><literal type="string">"dmhbj [addr]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Print output in JSON format"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_map_heap_block_win</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>space</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>space</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PHeapBlock</name></type> <name>hb</name> <init>= <expr><call><name>GetSingleBlock</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>hb</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>granularity</name> <init>= <expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>granularity</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>get_type</name> <argument_list>(<argument><expr><name><name>hb</name><operator>-&gt;</operator><name>dwFlags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>__new_heapblock_tbl</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>headerAddr</name> <init>= <expr><name>off</name> <operator>-</operator> <name>granularity</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<expr_stmt><expr><call><name>r_table_add_rowf</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><literal type="string">"xxnnns"</literal></expr></argument>, <argument><expr><name>headerAddr</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name></expr></argument>, <argument><expr><name>granularity</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"header_address"</literal></expr></argument>, <argument><expr><name>headerAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"user_address"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>hb</name><operator>-&gt;</operator><name>dwSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_kN</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"unused"</literal></expr></argument>, <argument><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name><operator>-&gt;</operator><name>unusedBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>hb</name><operator>-&gt;</operator><name>extraInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>w32_list_heaps_blocks</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_debug_map_heap_win</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>init_func</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> 
<expr_stmt><expr><call><name>cmd_debug_map_heap_block_win</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>w32_list_heaps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
