<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\core\anal_tp.c">


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOOP_MAX</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<enum>enum <block>{
<decl><name>ROMEM</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ASM_TRACE</name></decl>,
<decl><name>ANAL_TRACE</name></decl>,
<decl><name>DBG_TRACE</name></decl>,
<decl><name>NONULL</name></decl>,
<decl><name>STATES_SIZE</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>r_anal_emul_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>, <argument><expr><literal type="string">"asm.trace"</literal></expr></argument>, <argument><expr><literal type="string">"dbg.trace"</literal></expr></argument>,
<argument><expr><literal type="string">"esil.nonull"</literal></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.romem"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.trace"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.trace"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.nonull"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>sp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Stack isn't initialized.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Try running aei and aeim commands before aft for default stack initialization\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_anal_emul_restore</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDB_CONTAINS</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sdb_array_contains (trace, sdb_fmt ("%d.reg.write", i), s, 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>type_pos_hit</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>trace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_stack</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>place</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>in_stack</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp_name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>sp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>write_addr</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.mem.write"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>write_addr</name> <operator>==</operator> <name>sp</name> <operator>+</operator> <name>size</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>SDB_CONTAINS</name> <argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>place</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__var_rename</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <operator>!</operator><name>v</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument> , <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_default</name> <init>= <expr><operator>(</operator><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>VARPREFIX</name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>ARGPREFIX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_default</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strlen</name> <argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_var_rename</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__var_retype</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pfx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>&amp;&amp;</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"int"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_ptr</name> <init>= <expr><operator>(</operator><name>vname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>vname</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_ptr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expand</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int32_t"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="string">"int"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"uint32_t"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="string">"unsigned int"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"uint64_t"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="string">"unsigned long long"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>expand</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_default</name> <init>= <expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_default</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pfx</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_default</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"signed"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_setf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_free</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"const "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>r_strbuf_setf</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>type</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_endswith</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>tmp1</name> <init>= <expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="string">"unsigned long long"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"uint64_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="string">"unsigned"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"uint32_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"int32_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_strbuf_free</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_src_regname</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name> <operator>||</operator> <call><name>r_strbuf_is_empty</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>op_esil</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>op_esil</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>op_esil</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ri</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ri</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_32_to_64</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>op_esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>op_esil</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>op_esil</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op_esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_addr</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>trace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regname</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>regname</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.reg.read.%s"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>_RAnalCond</name></type> <name>cond_invert</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>_RAnalCond</name></type> <name>cond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_COND_LE</name></expr>:</case>
<return>return <expr><name>R_ANAL_COND_GT</name></expr>;</return>
<case>case <expr><name>R_ANAL_COND_LT</name></expr>:</case>
<return>return <expr><name>R_ANAL_COND_GE</name></expr>;</return>
<case>case <expr><name>R_ANAL_COND_GE</name></expr>:</case>
<return>return <expr><name>R_ANAL_COND_LT</name></expr>;</return>
<case>case <expr><name>R_ANAL_COND_GT</name></expr>:</case>
<return>return <expr><name>R_ANAL_COND_LE</name></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unhandled conditional swap\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return> 


</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RKEY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sdb_fmt ("var.range.0x%"PFMT64x ".%c.%d", a, k, d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADB</name></cpp:macro> <cpp:value>a-&gt;sdb_fcns</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>var_add_range</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>_RAnalCond</name></type> <name>cond</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RKEY</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdb_array_append_num</name> <argument_list>(<argument><expr><name>ADB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_array_append_num</name> <argument_list>(<argument><expr><name>ADB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RStrBuf</name> <modifier>*</modifier></type><name>var_get_constraint</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>RKEY</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>sdb_array_length</name> <argument_list>(<argument><expr><name>ADB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>low</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>high</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>_RAnalCond</name></type> <name>cond</name> <init>= <expr><call><name>sdb_array_get_num</name> <argument_list>(<argument><expr><name>ADB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>val</name> <init>= <expr><call><name>sdb_array_get_num</name> <argument_list>(<argument><expr><name>ADB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_COND_LE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>high</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" &amp;&amp; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"&lt;= 0x%"</literal><name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_COND_LT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>high</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" &amp;&amp; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"&lt; 0x%"</literal><name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_COND_GE</name></expr>:</case>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"&gt;= 0x%"</literal><name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_COND_GT</name></expr>:</case>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"&gt; 0x%"</literal><name>PFMT64x</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&amp;&amp;</operator> <name>high</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>n</name><operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" || "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>sb</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>parse_format</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>fmt</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_fmts</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.types.spec"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>arr</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fmt</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>arr</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>tmp</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IS_LOWER</name> <argument_list>(<argument><expr><operator>*</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER</name> <argument_list>(<argument><expr><operator>*</operator><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"spec.%s.%s"</literal></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MAX</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGNAME_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INSTR</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>type_match</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fcn_name</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>baddr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>cc</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prev_idx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>userfnc</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>caddr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.types.verbose"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>stack_rev</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>in_stack</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>format</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn_name</name> <operator>||</operator> <operator>!</operator><name>cc</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>r_type_func_args_count</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>place</name> <init>= <expr><call><name>r_anal_cc_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>place</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>place</name></expr></argument>, <argument><expr><literal type="string">"stack_rev"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stack_rev</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>place</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>place</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_stack</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><literal type="string">"sym.imp."</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s missing function definition\n"</literal></expr></argument>, <argument><expr><name>fcn_name</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_stack</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>r_anal_cc_max_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>DEFAULT_MAX</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>arg_num</name> <init>= <expr><ternary><condition><expr><name>stack_rev</name></expr> ?</condition><then> <expr><operator>(</operator><name>max</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name><operator>)</operator></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>pos</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_type_func_args_type</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><name>arg_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_type_func_args_name</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><name>arg_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>userfnc</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_stack</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>place</name> <operator>=</operator> <call><name>r_anal_cc_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>arg_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>regname</name><index>[<expr><name>REGNAME_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>xaddr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>memref</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cmt_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>idx</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <name>prev_idx</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>instr_addr</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.addr"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>instr_addr</name> <operator>&lt;</operator> <name>baddr</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>instr_addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>next_op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>instr_addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next_op</name> <operator>||</operator> <operator>(</operator><name>j</name> <operator>!=</operator> <name>idx</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>next_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name>
<operator>||</operator> <name><name>next_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_JMP</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>next_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_stack</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name><literal type="string">".arg.%s"</literal></expr></argument>, <argument><expr><name>caddr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>place</name></expr>?</condition><then> <expr><name>place</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name><literal type="string">".arg.%d"</literal></expr></argument>, <argument><expr><name>caddr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.mem.read"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name> <operator>&amp;&amp;</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>memref</name> <operator>=</operator> <operator>!</operator> <operator>(</operator><operator>!</operator><name>memref</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>R_ANAL_VAR_KIND_REG</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>type_pos_hit</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>trace</name></expr></argument>, <argument><expr><name>in_stack</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>place</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmt_set</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>&amp;&amp;</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_META_TYPE_VARTYPE</name></expr></argument>, <argument><expr><name>instr_addr</name></expr></argument>,
<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>r_str_endswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmt_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>space</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_STRINGS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>formatstr</name><index>[<expr><literal type="number">0x200</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>read</name> <init>= <expr><call><name>r_io_nread_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>formatstr</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>formatstr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>read</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>formatstr</name><index>[<expr><name>read</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>types</name> <operator>=</operator> <call><name>parse_format</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>formatstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>format</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>userfnc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>memref</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__var_rename</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>instr_addr</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>regname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xaddr</name> <operator>=</operator> <call><name>get_addr</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>regname</name> <operator>&amp;&amp;</operator> <call><name>SDB_CONTAINS</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>userfnc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>memref</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__var_rename</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_PUSH</name></expr>:</case>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>instr_addr</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>regname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_LOAD</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_STORE</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>xaddr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xaddr</name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>REGNAME_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>instr_addr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr</name> <init>= <expr><call><name>get_addr</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>xaddr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name></expr>?</condition><then> <expr><name>type</name></expr></then><else>: <expr><literal type="string">"int"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>memref</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>next_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bb_cmpaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_type_match</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>resolved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Please run aeim\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>chk_constraint</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.types.constraint"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>bsize</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cur_idx</name></decl> , <decl><type ref="prev"/><name>prev_idx</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>trace_idx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hc</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_emul_init</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_emul_restore</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_emul_restore</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcn_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>str_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>prop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>prev_var</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>prev_type</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_dest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_reg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pc</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>it</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>out_function</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>bsize</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>pcval</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>addr</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator> <operator>||</operator> <name>pcval</name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsize</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>minopcode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>minopcode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loop_count</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name><literal type="string">".count"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>loop_count</name> <operator>&gt;</operator> <name>LOOP_MAX</name> <operator>||</operator> <name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name><literal type="string">".count"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loop_count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op_nonlinear</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>userfnc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cur_idx</name> <operator>=</operator> <call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>var</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>next_op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>ret</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ut32</name></type> <name>type</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name> <operator>||</operator> <name><name>aop</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_UCALL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>full_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>callee_addr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn_call</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn_call</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>full_name</name> <operator>=</operator> <name><name>fcn_call</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>callee_addr</name> <operator>=</operator> <name><name>fcn_call</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>aop</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>space</name></name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_IMPORTS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>full_name</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>callee_addr</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>full_name</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_type_func_exist</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <call><name>r_type_func_guess</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>full_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>userfnc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>Cc</name> <init>= <expr><call><name>r_anal_cc_func</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Cc</name> <operator>&amp;&amp;</operator> <call><name>r_anal_cc_exist</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>Cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>Cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>type_match</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prev_idx</name></expr></argument>,
<argument><expr><name>userfnc</name></expr></argument>, <argument><expr><name>callee_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_idx</name> <operator>=</operator> <name>cur_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><call><name>r_type_func_ret</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rr</name> <init>= <expr><call><name>r_anal_cc_ret</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret_reg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>resolved</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>fcn_name</name></expr></argument>, <argument><expr><literal type="string">"__stack_chk_fail"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.addr"</literal></expr></argument>, <argument><expr><name>cur_idx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>mov_addr</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>mop</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>mov_addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>mop</name> <operator>&amp;&amp;</operator> <name><name>mop</name><operator>-&gt;</operator><name>var</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>type</name> <init>= <expr><name><name>mop</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_rename</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>mop</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="string">"canary"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>mop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>resolved</name> <operator>&amp;&amp;</operator> <name>ret_type</name> <operator>&amp;&amp;</operator> <name>ret_reg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>src</name><index>[<expr><name>REGNAME_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.reg.write"</literal></expr></argument>, <argument><expr><name>cur_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_dest</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret_reg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>src</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <name>R_ANAL_OP_DIR_WRITE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resolved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_dest</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret_reg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cur_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cur_dest</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>foo</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>cur_dest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tmp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret_reg</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>, <argument><expr><name>foo</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>tmp</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>resolved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>next_op</name> <operator>&amp;&amp;</operator> <name><name>next_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name><operator>)</operator></expr>)</condition><block>{<block_content>



<decl_stmt><decl><type><name>char</name></type> <name><name>nsrc</name><index>[<expr><name>REGNAME_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>next_op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>nsrc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>nsrc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret_reg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nsrc</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>, <argument><expr><name>nsrc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>var</name> <operator>&amp;&amp;</operator>
<name><name>aop</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <name>R_ANAL_OP_DIR_READ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>sign</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CMP</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>next_op</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>next_op</name><operator>-&gt;</operator><name>sign</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unsigned"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>||</operator> <name><name>aop</name><operator>.</operator><name>sign</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"signed"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>prev_dest</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_STORE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>reg</name><index>[<expr><name>REGNAME_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_src_regname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>prev_dest</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str_flag</name> <operator>&amp;&amp;</operator> <name>match</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"const char *"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prop</name> <operator>&amp;&amp;</operator> <name>match</name> <operator>&amp;&amp;</operator> <name>prev_var</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prev_type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>chk_constraint</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CMP</name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>disp</name></name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>next_op</name> <operator>&amp;&amp;</operator> <name><name>next_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CJMP</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>jmp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>jmp_op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>jmp_addr</name> <init>= <expr><name><name>next_op</name><operator>-&gt;</operator><name>jump</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>jmpbb</name> <init>= <expr><call><name>r_anal_fcn_bbget_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>jmp_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_INSTR</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>jmp_op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>jmp_addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>jmp_op</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jmp_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_RET</name> <operator>&amp;&amp;</operator> <call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>jmpbb</name></expr></argument>, <argument><expr><name>jmp_addr</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <name><name>jmp_op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CJMP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>jmp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>jmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>jmp_addr</name> <operator>+=</operator> <name><name>jmp_op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>jmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>_RAnalCond</name></type> <name>cond</name> <init>= <expr><ternary><condition><expr><name>jmp</name></expr>?</condition><then> <expr><call><name>cond_invert</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>next_op</name><operator>-&gt;</operator><name>cond</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>next_op</name><operator>-&gt;</operator><name>cond</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>var_add_range</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev_var</name> <operator>=</operator> <operator>(</operator><name>var</name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <name>R_ANAL_OP_DIR_READ</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str_flag</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_dest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_LOAD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>refptr</name></name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_OP_TYPE_LOAD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr</name> <init>= <expr><call><name>r_read_ble</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>refptr</name></name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"str"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_flag_exist_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"str"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <name>str_flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"const char *"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.reg.write"</literal></expr></argument>, <argument><expr><name>cur_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>prev_dest</name> <operator>=</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>prev_type</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>prev_type</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>next_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>
</block_content>}</block>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>rvar</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp_var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl> , <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>rvar</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>lvar</name> <init>= <expr><call><name>get_link_var</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name><literal type="string">".arg.%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qres</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>qres</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>qres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lvar</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>lvar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;&amp;</operator> <name>res</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lvar</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>lvar</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>lvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>place</name> <init>= <expr><call><name>r_anal_cc_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[-] place: %s\n"</literal></expr></argument>, <argument><expr><name>place</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>place</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>place</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list2</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list2</argument>, <argument>iter2</argument>, <argument>bp_var</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bp_var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal> <name>PFMT64x</name> <literal type="string">".arg.%d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>bp_var</name><operator>-&gt;</operator><name>delta</name></name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__var_retype</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>bp_var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"No calling convention set for function '%s'\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>out_function</name>:</label>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_emul_restore</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
