<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\core\canal.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_list.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_flag.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_bin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sdb/ht_uu.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>


<enum>enum <block>{
<decl><name>R2_ARCH_THUMB</name></decl>,
<decl><name>R2_ARCH_ARM32</name></decl>,
<decl><name>R2_ARCH_ARM64</name></decl>,
<decl><name>R2_ARCH_MIPS</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>void</name></type> <name>loganal</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" &gt; 0x%08"</literal><name>PFMT64x</name><literal type="string">" %d\r"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpsize</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>as</name> <init>= <expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bs</name> <init>= <expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name><operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name><operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpfcncc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>RAnalFunction</name> <operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>as</name> <init>= <expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bs</name> <init>= <expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpedges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>as</name></decl>, <decl><type ref="prev"/><name>bs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpframe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>as</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>maxstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>maxstack</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpxrefs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>as</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numrefs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numrefs</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>as</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpcalls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>as</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numcallrefs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numcallrefs</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name> <operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpnbbs</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>as</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bs</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>as</name><operator>&gt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name>as</name><operator>&lt;</operator> <name>bs</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpaddr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getFunctionName</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><call><name>r_bin_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bf</name> <operator>&amp;&amp;</operator> <name><name>bf</name><operator>-&gt;</operator><name>o</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>kv</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>o</name><operator>-&gt;</operator><name>addr2klassmethod</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>at</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name><modifier>*</modifier></type> <name>flags</name> <init>= <expr><call><name>r_flag_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.flags.real"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>RCore</name> <modifier>*</modifier></type><name>mycore</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINLEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>fakeLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>&amp;</operator><name>fakeLen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<return>return <expr><literal type="number">2</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <name>MINLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">10</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">13</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">32</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PRINTABLE</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>is_string_at</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>olen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>rstr</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">255</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_string</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>str</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>*</operator><operator>)</operator><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>lowptr</name> <init>= <expr><name><name>cstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lowptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>lowptr</name> <operator>&amp;=</operator> <name>UT32_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0x1000</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr</name> <init>= <expr><name><name>cstr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>ptr</name> <operator>&amp;=</operator> <name>UT32_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>rstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>rstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rstr</name><index>[<expr><literal type="number">127</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>is_string</name> <argument_list>(<argument><expr><name>rstr</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>rstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>str</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>lowptr</name></expr></argument>, <argument><expr><name>rstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>rstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rstr</name><index>[<expr><literal type="number">127</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>is_string</name> <argument_list>(<argument><expr><name>rstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>rstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>rstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>str</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>olen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>ret</name></expr>?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>ut64</name></type> <name>r_core_anal_address</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>types</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RRegSet</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>r_reg_regset_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rs</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>rs-&gt;regs</argument>, <argument>iter</argument>, <argument>r</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_REG_TYPE_GPR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>val</name> <init>= <expr><call><name>r_reg_getv</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>val</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_REG</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_FUNC</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>



<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>map</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name> <operator>&amp;&amp;</operator>
<name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_PROGRAM</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_LIBRARY</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_EXEC</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_READ</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_W</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_WRITE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_HEAP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_STACK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>_perm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr>)</condition> <block>{<block_content>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>s</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>_perm</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>_perm</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>_perm</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></else></ternary></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_HEAP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_STACK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>_perm</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>_perm</name> <operator>&amp;</operator> <name>R_PERM_X</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_EXEC</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>_perm</name> <operator>&amp;</operator> <name>R_PERM_R</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_READ</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>_perm</name> <operator>&amp;</operator> <name>R_PERM_W</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_WRITE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>not_ascii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>failed_sequence</name></decl>, <decl><type ref="prev"/><name>dir</name></decl>, <decl><type ref="prev"/><name>on</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>addr</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_PRINTABLE</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>not_ascii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>not_ascii</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_ASCII</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>failed_sequence</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>on</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>addr</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>on</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>n</name> <operator>&gt;</operator> <name>on</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>on</name> <operator>+</operator> <name>dir</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>failed_sequence</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>on</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>failed_sequence</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>types</name> <operator>|=</operator> <name>R_ANAL_ADDR_TYPE_SEQUENCE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>types</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>blacklisted_word</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name><name>list</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"__stack_chk_guard"</literal></expr>,
<expr><literal type="string">"__stderrp"</literal></expr>,
<expr><literal type="string">"__stdinp"</literal></expr>,
<expr><literal type="string">"__stdoutp"</literal></expr>,
<expr><literal type="string">"_DefaultRuneLocale"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>anal_fcn_autoname</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>use_getopt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_isatty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>do_call</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>refs</name></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"str."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"flag"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>do_call</name></expr>)</condition> <block>{<block_content> 
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_call</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>blacklisted_word</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".isatty"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_isatty</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".getopt"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_getopt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"method."</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_call</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"str."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_call</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym.imp."</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_call</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"reloc."</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_call</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_getopt</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"parse_args"</literal></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_isatty</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"sub.setup_tty_%s_%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>do_call</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>do_call</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"sub.%s_%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>do_call</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>do_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_autoname_all_fcns</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>it</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"fcn."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym.func."</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>anal_fcn_autoname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_autoname_all_golang_fcns</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name><modifier>*</modifier></type> <name>section_list</name> <init>= <expr><call><name>r_bin_get_sections</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>oldstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>section</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>gopclntab</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>section_list</argument>, <argument>iter</argument>, <argument>section</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".gopclntab"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gopclntab</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>vaddr</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gopclntab</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Could not find .gopclntab section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ptr_size</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><name>gopclntab</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>ptr_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size_offset</name> <init>= <expr><name>gopclntab</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>ptr_size</name></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>temp_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_nread_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>size_offset</name></expr></argument>, <argument><expr><name>temp_size</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>size</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>temp_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_syms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_SYMBOLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>gopclntab</name> <operator>+</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>temp_delta</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>temp_func_addr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>temp_func_name</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_nread_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <name>ptr_size</name></expr></argument>, <argument><expr><name>temp_delta</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>delta</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>temp_delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>func_offset</name> <init>= <expr><name>gopclntab</name> <operator>+</operator> <name>delta</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_nread_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>func_offset</name></expr></argument>, <argument><expr><name>temp_func_addr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>r_io_nread_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>func_offset</name> <operator>+</operator> <name>ptr_size</name></expr></argument>, <argument><expr><name>temp_func_name</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>func_addr</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>temp_func_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>func_name_offset</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>temp_func_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>func_name</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>gopclntab</name> <operator>+</operator> <name>func_name_offset</name></expr></argument>, <argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>func_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_name_filter</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>func_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"sym.go.%s"</literal></expr></argument>, <argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func_addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name>ptr_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num_syms</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num_syms</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"Found %d symbols and saved them at sym.go.*"</literal></expr></argument>, <argument><expr><name>num_syms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>oldstr</name> <operator>=</operator> <call><name>r_print_rowlog</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><literal type="string">"Found no symbols."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_print_rowlog_done</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>oldstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_anal_fcn_autoname</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>anal_fcn_autoname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>dump</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name> <modifier>*</modifier></type><name>next_append</name><parameter_list>(<parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>next</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nexti</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>tmp_next</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>*</operator><name>nexti</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_next</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>tmp_next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next</name><index>[<expr><operator>*</operator><name>nexti</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nexti</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_anal_set_stringrefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name> <operator>&amp;&amp;</operator>
<call><name>r_bin_is_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>r_anal_try_get_fcn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fcndepth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>refdepth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refdepth</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>looksLikeAFunction</name> <init>= <expr><call><name>r_anal_check_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>,
<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>looksLikeAFunction</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>from</name></name> <operator>||</operator>
<name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>to</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>fcndepth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>sz</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name></type> <name>ref1</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>at</name></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>i32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut16</name></type> <name>i16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name>i8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offe</name> <init>= <expr><name>offs</name> <operator>+</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>offs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>offs</name> <operator>&lt;</operator> <name>offe</name></expr>;</condition> <incr><expr><name>offs</name> <operator>+=</operator> <name>sz</name></expr><operator>,</operator> <expr><name><name>ref1</name><operator>.</operator><name>at</name></name> <operator>+=</operator> <name>sz</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>bo</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>offs</name></expr></argument>, <argument><expr><name>bo</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>bo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>be</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>i8</name> <operator>=</operator> <call><name>r_read_ble8</name> <argument_list>(<argument><expr><name>bo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name>i8</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>i16</name> <operator>=</operator> <call><name>r_read_ble16</name> <argument_list>(<argument><expr><name>bo</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name>i16</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>i32</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>bo</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name>i32</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name><name>ref1</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><name>bo</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_anal_try_get_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref1</name></expr></argument>, <argument><expr><name>fcndepth</name></expr></argument>, <argument><expr><name>refdepth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_anal_analyze_fcn_refs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_REF_TYPE_DATA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>followdatarefs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_try_get_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_CODE</name></expr>:</case>
<case>case <expr><name>R_ANAL_REF_TYPE_CALL</name></expr>:</case>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>depth</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>


</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>function_rename</name><parameter_list>(<parameter><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locname</name> <init>= <expr><literal type="string">"loc."</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>locsize</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>locname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnname</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>locname</name></expr></argument>, <argument><expr><name>locsize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnpfx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>restofname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_FCN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fcnpfx</name> <operator>=</operator> <call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>restofname</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <name>locsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>fcnpfx</name></expr></argument>, <argument><expr><name>restofname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>autoname_imp_trampoline</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>RAnalBlock</name> <operator>*</operator><operator>)</operator> <call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ninstr</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>refs</name> <operator>&amp;&amp;</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flg</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flg</name> <operator>&amp;&amp;</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>flg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym.imp."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"sub.%s"</literal></expr></argument>, <argument><expr><name><name>flg</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_fcn_name_from_flag</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnpfx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>nameChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"loc."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"fcn."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_rename</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nameChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sect"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_rename</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nameChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nameChanged</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_rename</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s.%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>fcnpfx</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__core_anal_fcn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_next</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.hasnext"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nexti</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fcnlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_function_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnpfx</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.fcnprefix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcnpfx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fcnpfx</name> <operator>=</operator> <literal type="string">"fcn"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: new (fcn)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <call><name>r_str_constpool_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>constpool</name></name></expr></argument>, <argument><expr><call><name>r_anal_cc_default</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hint</name> <operator>&amp;&amp;</operator> <name><name>hint</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>getFunctionName</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>fcnpfx</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_fcn_invalidate_read_ahead_cache</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>delta</name> <init>= <expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>delta</name></expr></argument>, <argument><expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>noncode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fcnlen</name> <operator>=</operator> <call><name>r_anal_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>delta</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>searchstringrefs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_set_stringrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fcnlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Analyzed function size is 0 at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fcnlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>fcnlen</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_RET_ERROR</name></expr>:</case>
<case>case <expr><name>R_ANAL_RET_NEW</name></expr>:</case>
<case>case <expr><name>R_ANAL_RET_DUP</name></expr>:</case>
<case>case <expr><name>R_ANAL_RET_END</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops. Negative fcnsize at 0x%08"</literal><name>PFMT64x</name><literal type="string">" (%d)\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>fcnlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_core_flag_get_by_spaces</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_fcn_name_from_flag</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>fcnpfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcnlen</name> <operator>==</operator> <name>R_ANAL_RET_ERROR</name> <operator>||</operator>
<operator>(</operator><name>fcnlen</name> <operator>==</operator> <name>R_ANAL_RET_END</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>followbrokenfcnsrefs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_analyze_fcn_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fcnlen</name> <operator>==</operator> <name>R_ANAL_RET_END</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_core_flag_get_by_spaces</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sect"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnpfx</name> <init>= <expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcnpfx</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>fcnpfx</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>fcnpfx</name></expr></argument>, <argument><expr><literal type="string">"fcn"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fcnpfx</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.fcnprefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>fcnpfx</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>autoname_imp_trampoline</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_FUNCTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_add_function</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_next</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name> <operator>||</operator> <operator>(</operator><name>map</name> <operator>&amp;&amp;</operator> <name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nexti</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nexti</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalMetaItem</name> <modifier>*</modifier></type><name>mi</name> <init>= <expr><call><name>r_meta_find</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>R_META_TYPE_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mi</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>mi</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_meta_item_free</name> <argument_list>(<argument><expr><name>mi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>loganal</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">10000</literal> <operator>-</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>next_append</name> <argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexti</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_analyze_fcn_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>fcnlen</name> <operator>!=</operator> <name>R_ANAL_RET_END</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_next</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nexti</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_check_bp_use</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>

<label><name>error</name>:</label>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_free</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fcn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(
<argument><expr><literal type="string">"%s.%08"</literal> <name>PFMT64x</name></expr></argument>,
<argument><expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_FUNCTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_add_function</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <name>has_next</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>newaddr</name> <init>= <expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>newaddr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name> <operator>||</operator> <operator>(</operator><name>map</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>next_append</name> <argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexti</name></expr></argument>, <argument><expr><name>newaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nexti</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>next</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_check_bp_use</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_var_delete_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_title</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>RAnalOp</name><modifier>*</modifier></type> <name>r_core_anal_op</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minopsz</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>delta</name> <operator>+</operator> <name>minopsz</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&gt;=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>+</operator> <literal type="number">16</literal> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>block</name></name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>delta</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_op</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_op</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_op</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name> <operator>&amp;&amp;</operator> <name>mask</name> <operator>&amp;</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING: Implement RAnalOp.MASK_DISASM for current anal.arch. Using the sluggish RAsmOp fallback for now.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_asm_op_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_asm_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>op</name></expr>;</return>
<label><name>err_op</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>RBNode</name></type> <name>rb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>
<enum>enum <block>{
<decl><name>HINT_NODE_ADDR</name></decl>,
<decl><name>HINT_NODE_ARCH</name></decl>,
<decl><name>HINT_NODE_BITS</name></decl>
}</block> <decl><name>type</name></decl>;</enum>
<union>union <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>RVector</name> <modifier>*</modifier></type><name>addr_hints</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
}</block>;</union>
}</block></struct></type> <name>HintNode</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_hint_h_format</name><parameter_list>(<parameter><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HINT_NODE_ADDR</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalAddrHintRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
<macro><name>r_vector_foreach</name> <argument_list>(<argument>node-&gt;addr_hints</argument>, <argument>record</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_IMMBASE</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" immbase=%d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>immbase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_JUMP</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" jump=0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_FAIL</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" fail=0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_STACKFRAME</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" stackframe=0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>stackframe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_PTR</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" ptr=0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NWORD</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" nword=%d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>nword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_RET</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" ret=0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NEW_BITS</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" newbits=%d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>newbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SIZE</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" size=%"</literal><name>PFMT64u</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SYNTAX</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" syntax='%s'"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPTYPE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>optype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" type='%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPCODE</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" opcode='%s'"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" offset='%s'"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>type_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_ESIL</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" esil='%s'"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_HIGH</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" high=true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_VAL</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" val=0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>HINT_NODE_ARCH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" arch='%s'"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">" arch=RESET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>HINT_NODE_BITS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" bits=%d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">" bits=RESET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>hint_node_print</name><parameter_list>(<parameter><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HINTCMD_ADDR</name><parameter_list>(<parameter><type><name>hint</name></type></parameter>,<parameter><type><name>fmt</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_cons_printf (fmt" @ 0x%"PFMT64x"\n", x, (hint)-&gt;addr)</cpp:value></cpp:define>
<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HINT_NODE_ADDR</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalAddrHintRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
<macro><name>r_vector_foreach</name> <argument_list>(<argument>node-&gt;addr_hints</argument>, <argument>record</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_IMMBASE</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahi %d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>immbase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_JUMP</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahc 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_FAIL</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahf 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_STACKFRAME</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahF 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>stackframe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_PTR</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahp 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NWORD</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_RET</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahr 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NEW_BITS</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SIZE</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahs 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SYNTAX</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahS %s"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPTYPE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>optype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"aho %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPCODE</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahd %s"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"aht %s"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>type_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_ESIL</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahe %s"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_HIGH</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ahh @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_VAL</name></expr>:</case>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>HINT_NODE_ARCH</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"aha %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr> </then><else>: <expr><literal type="string">"0"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HINT_NODE_BITS</name></expr>:</case>
<expr_stmt><expr><call><name>HINTCMD_ADDR</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"ahb %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HINTCMD_ADDR</name></cpp:undef>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HINT_NODE_ADDR</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalAddrHintRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
<macro><name>r_vector_foreach</name> <argument_list>(<argument>node-&gt;addr_hints</argument>, <argument>record</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_IMMBASE</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"immbase"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>immbase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_JUMP</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_FAIL</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_STACKFRAME</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stackframe"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>stackframe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_PTR</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ptr"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NWORD</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nword"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>nword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_RET</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ret"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>retval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_NEW_BITS</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"newbits"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>newbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SIZE</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_SYNTAX</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"syntax"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>syntax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPTYPE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>optype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_OPCODE</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"opcode"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>opcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>type_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_ESIL</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"esil"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_HIGH</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"high"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_ADDR_HINT_TYPE_VAL</name></expr>:</case>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"val"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>HINT_NODE_ARCH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"arch"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pj_knull</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"arch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>HINT_NODE_BITS</name></expr>:</case>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"bits"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>print_hint_h_format</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>hint_node_free</name><parameter_list>(<parameter><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><call><name>container_of</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HintNode</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>hint_node_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>incoming</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RBNode</name> <modifier>*</modifier></type><name>in_tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>ia</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ut64</name> <operator>*</operator><operator>)</operator><name>incoming</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ta</name> <init>= <expr><call><name>container_of</name> <argument_list>(<argument><expr><name>in_tree</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>HintNode</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ia</name> <operator>&lt;</operator> <name>ta</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ia</name> <operator>&gt;</operator> <name>ta</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>print_addr_hint_cb</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RVector</name> <modifier>*</modifier></type><name>records</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HintNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>HINT_NODE_ADDR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>addr_hints</name></name> <operator>=</operator> <name>records</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_rbtree_insert</name> <argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>rb</name></name></expr></argument>, <argument><expr><name>hint_node_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>print_arch_hint_cb</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arch</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HintNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>HINT_NODE_ARCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>arch</name></name> <operator>=</operator> <name>arch</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_rbtree_insert</name> <argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>rb</name></name></expr></argument>, <argument><expr><name>hint_node_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>print_bits_hint_cb</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>HintNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>HINT_NODE_BITS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_rbtree_insert</name> <argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>rb</name></name></expr></argument>, <argument><expr><name>hint_node_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_hint_tree</name><parameter_list>(<parameter><decl><type><name>RBTree</name></type> <name>tree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_ADDR</name></cpp:macro> <cpp:value>if (pj) { pj_end (pj); } else if (mode != '*') { r_cons_newline (); }</cpp:value></cpp:define>





<decl_stmt><decl><type><name>RBIter</name></type> <name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HintNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>last_addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>in_addr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<macro><name>r_rbtree_foreach</name> <argument_list>(<argument>tree</argument>, <argument>it</argument>, <argument>node</argument>, <argument>HintNode</argument>, <argument>rb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_addr</name> <operator>||</operator> <name>last_addr</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>in_addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>END_ADDR</name></expr></expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>in_addr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_addr</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>!=</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" =&gt;"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hint_node_print</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>in_addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>END_ADDR</name></expr></expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BEGIN_ADDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>END_ADDR</name></cpp:undef>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_hint_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RBTree</name></type> <name>tree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_arch_hints_foreach</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>print_arch_hint_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_bits_hints_foreach</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>print_bits_hint_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_addr_hints_foreach</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>print_addr_hint_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_hint_tree</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_rbtree_free</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>hint_node_free</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_hint_print</name><parameter_list>(<parameter><decl><type><name>RAnal</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RBTree</name></type> <name>tree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>hint_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arch</name> <init>= <expr><call><name>r_anal_hint_arch_at</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>hint_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_arch_hint_cb</name> <argument_list>(<argument><expr><name>hint_addr</name></expr></argument>, <argument><expr><name>arch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>r_anal_hint_bits_at</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>hint_addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_bits_hint_cb</name> <argument_list>(<argument><expr><name>hint_addr</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RVector</name> <modifier>*</modifier></type><name>addr_hints</name> <init>= <expr><call><name>r_anal_addr_hints_at</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr_hints</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_addr_hint_cb</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr_hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>print_hint_tree</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_rbtree_free</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>hint_node_free</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>core_anal_graph_label</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>file</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cmdstr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>filestr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>oline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_GRAPHLINES</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_bin_addr2line</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>line</name> <operator>!=</operator> <name>oline</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"??"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>filestr</name> <operator>=</operator> <call><name>r_file_slurp_line</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filestr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flen</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>filestr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cmdstr</name> <operator>=</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name>cmdstr</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <name>flen</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>cmdstr</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>filestr</name></expr></argument>, <argument><expr><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>flen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>cmdstr</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>cmdstr</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><literal type="string">"&lt;br /&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>cmdstr</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><literal type="string">"\\l"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>filestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>oline</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_STAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pdb %"</literal><name>PFMT64u</name><literal type="string">" @ 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_GRAPHBODY</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scrColor</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>scrUtf8</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pD %"</literal><name>PFMT64u</name><literal type="string">" @ 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmdstr</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scrColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><name>scrUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdstr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_str_escape_dot</name> <argument_list>(<argument><expr><name>cmdstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmdstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>palColorFor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RColor</name></type> <name>rcolor</name> <init>= <expr><call><name>r_cons_pal_get</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>r_cons_rgb_tostring</name> <argument_list>(<argument><expr><name><name>rcolor</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>rcolor</name><operator>.</operator><name>g</name></name></expr></argument>, <argument><expr><name><name>rcolor</name><operator>.</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>core_anal_color_curr_node</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bbi</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>color_current</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.current"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_curr</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.current"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>current</name> <init>= <expr><call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bbi</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>current</name> <operator>&amp;&amp;</operator> <name>color_current</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\t\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\t[fillcolor=%s style=filled shape=box];\n"</literal></expr></argument>, <argument><expr><name>pal_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>core_anal_graph_construct_edges</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>DB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bbi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_keva</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_KEYVALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_star</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_STAR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_jump</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.true"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_fail</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.false"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_trfa</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.trufae"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bbi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>val</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"bb.0x%08"</literal><name>PFMT64x</name><literal type="string">".to"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">",0x%08"</literal><name>PFMT64x</name></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"&lt;div class=\"connector _0x%08"</literal><name>PFMT64x</name><literal type="string">" _0x%08"</literal><name>PFMT64x</name><literal type="string">"\"&gt;\n"</literal>
<literal type="string">" &lt;img class=\"connector-end\" src=\"img/arrow.gif\" /&gt;&lt;/div&gt;\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_keva</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[color=\"%s\"];\n"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>pal_jump</name></expr> </then><else>: <expr><name>pal_trfa</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>core_anal_color_curr_node</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"&lt;div class=\"connector _0x%08"</literal><name>PFMT64x</name><literal type="string">" _0x%08"</literal><name>PFMT64x</name><literal type="string">"\"&gt;\n"</literal>
<literal type="string">" &lt;img class=\"connector-end\" src=\"img/arrow.gif\"/&gt;&lt;/div&gt;\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_keva</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[color=\"%s\"];\n"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>pal_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>core_anal_color_curr_node</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>caseop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"&lt;div class=\"connector _0x%08"</literal><name>PFMT64x</name><literal type="string">" _0x%08"</literal><name>PFMT64x</name><literal type="string">"\"&gt;\n"</literal>
<literal type="string">" &lt;img class=\"connector-end\" src=\"img/arrow.gif\"/&gt;&lt;/div&gt;\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_keva</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%age %s %s\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[color=\"%s\"];\n"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>pal_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>core_anal_color_curr_node</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>bbi-&gt;switch_op-&gt;cases</argument>, <argument>iter</argument>, <argument>caseop</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"bb.0x%08"</literal><name>PFMT64x</name><literal type="string">".switch.%"</literal><name>PFMT64d</name></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"bb.0x%08"</literal><name>PFMT64x</name><literal type="string">".switch"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_array_add_num</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"&lt;div class=\"connector _0x%08"</literal><name>PFMT64x</name><literal type="string">" _0x%08"</literal><name>PFMT64x</name><literal type="string">"\"&gt;\n"</literal>
<literal type="string">" &lt;img class=\"connector-end\" src=\"img/arrow.gif\"/&gt;&lt;/div&gt;\n"</literal></expr></argument>,
<argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_keva</name></expr>)</condition><block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument> ,<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal> \
<literal type="string">"[color2=\"%s\"];\n"</literal></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>caseop</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>pal_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>core_anal_color_curr_node</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pal_jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pal_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pal_trfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>core_anal_graph_construct_nodes</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>DB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bbi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_keva</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_KEYVALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_star</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_STAR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><literal type="number">300</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_json_format_disasm</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON_FORMAT_DISASM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_curr</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.current"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_traced</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.traced"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_box4</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.box4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>font</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.font"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>color_current</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.current"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bbi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdb_array_push_num</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"bbs"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"bb.0x%08"</literal><name>PFMT64x</name><literal type="string">".size"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_debug_trace_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"fail"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalSwitchOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name><name>bbi</name><operator>-&gt;</operator><name>switch_op</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"switchop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"defval"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>def_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"maxval"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>max_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"minval"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>min_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>case_op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>case_iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>op-&gt;cases</argument>, <argument>case_iter</argument>, <argument>case_op</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"jump"</literal></expr></argument>, <argument><expr><name><name>case_op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"trace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"times"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>times</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"colorize"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>colorize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ops"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_json_format_disasm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_print_disasm</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_print_disasm_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot allocate %"</literal><name>PFMT64u</name><literal type="string">" byte(s)\n"</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>core_anal_graph_label</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbi</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_GRAPHDIFF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>difftype</name> <init>= <expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name></expr>?</condition><then> <expr><operator>(</operator>\
<ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then> <expr><literal type="string">"lightgray"</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then> <expr><literal type="string">"yellow"</literal></expr></then><else>: <expr><literal type="string">"red"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></then><else>: <expr><literal type="string">"orange"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>diffname</name> <init>= <expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name></expr>?</condition><then> <expr><operator>(</operator>\
<ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then> <expr><literal type="string">"match"</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name><operator>==</operator><name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then> <expr><literal type="string">"unmatch"</literal></expr></then><else>: <expr><literal type="string">"new"</literal></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></then><else>: <expr><literal type="string">"unk"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"diff"</literal></expr></argument>, <argument><expr><name>diffname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>,
<argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="string">"asm.lines.fcn"</literal></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RDiff</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_diff_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines.fcn"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_star</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name> <operator>&amp;&amp;</operator> <name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>c2</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>c2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RConfig</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>config</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pdb @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>config</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str2</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"pdb @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>diffstr</name> <init>= <expr><call><name>r_diff_buffers_to_string</name> <argument_list>(<argument><expr><name>d</name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>str2</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>diffstr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_cpy</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>, <argument><expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body_b64</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>title</name> <operator>||</operator> <operator>!</operator><name>body_b64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_diff_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>body_b64</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s %s %d\n"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body_b64</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>diffstr</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="string">"\\l"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diffstr</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name><argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" [fillcolor=\"%s\","</literal>
<literal type="string">"color=\"black\", fontname=\"Courier\","</literal>
<literal type="string">" label=\"%s\", URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\"]\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>difftype</name></expr></argument>, <argument><expr><name>diffstr</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>diffstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>config</name></name> <operator>=</operator> <name>oc</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body_b64</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>color</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>bbi</name> <operator>&amp;&amp;</operator> <name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>title</name> <operator>||</operator> <operator>!</operator><name>body_b64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_diff_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>body_b64</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s %s %d\n"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body_b64</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name><argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" [fillcolor=\"%s\","</literal>
<literal type="string">"color=\"black\", fontname=\"Courier\","</literal>
<literal type="string">" label=\"%s\", URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\"]\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>difftype</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_diff_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"&lt;p class=\"block draggable\" style=\""</literal>
<literal type="string">"top: %dpx; left: %dpx; width: 400px;\" id=\""</literal>
<literal type="string">"_0x%08"</literal><name>PFMT64x</name><literal type="string">"\"&gt;\n%s&lt;/p&gt;\n"</literal></expr></argument>,
<argument><expr><name>top</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <ternary><condition><expr><name>left</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">600</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>left</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>top</name> <operator>+=</operator> <literal type="number">250</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>current</name> <init>= <expr><call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bbi</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label_color</name> <init>= <expr><ternary><condition><expr><name><name>bbi</name><operator>-&gt;</operator><name>traced</name></name></expr>
?</condition><then> <expr><name>pal_traced</name></expr>
</then><else>: <expr><ternary><condition><expr><operator>(</operator><name>current</name> <operator>&amp;&amp;</operator> <name>color_current</name><operator>)</operator></expr>
?</condition><then> <expr><name>pal_curr</name></expr>
</then><else>: <expr><name>pal_box4</name></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fill_color</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>current</name> <operator>&amp;&amp;</operator> <name>color_current</name><operator>)</operator> <operator>||</operator> <name>label_color</name> <operator>==</operator> <name>pal_traced</name><operator>)</operator></expr>?</condition><then> <expr><name>pal_traced</name></expr></then><else>: <expr><literal type="string">"white"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nodes</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body_b64</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>color</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>bbi</name> <operator>&amp;&amp;</operator> <name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>title</name> <operator>||</operator> <operator>!</operator><name>body_b64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>body_b64</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s %s %d\n"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body_b64</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\t\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" ["</literal>
<literal type="string">"URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\", fillcolor=\"%s\","</literal>
<literal type="string">"color=\"%s\", fontname=\"%s\","</literal>
<literal type="string">"label=\"%s\"]\n"</literal></expr></argument>,
<argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
<argument><expr><name>fill_color</name></expr></argument>, <argument><expr><name>label_color</name></expr></argument>, <argument><expr><name>font</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>core_anal_graph_nodes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_keva</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_KEYVALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>DB</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_jump</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.true"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_fail</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.false"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_trfa</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.trufae"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_curr</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.current"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_traced</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.traced"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pal_box4</name> <init>= <expr><call><name>palColorFor</name> <argument_list>(<argument><expr><literal type="string">"graph.box4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name> <operator>||</operator> <operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No fcn\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>ns</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>DB</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"graph"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>ns</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>DB</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ename</name> <init>= <expr><call><name>sdb_encode</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"ename"</literal></expr></argument>, <argument><expr><name>ename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"nargs"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"pos"</literal></expr></argument>, <argument><expr><literal type="string">"0,0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcn_name_escaped</name> <init>= <expr><call><name>r_str_escape_utf8_for_json</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>fcn_name_escaped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcn_name_escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ninstr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>ninstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nargs"</literal></expr></argument>,
<argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nlocals"</literal></expr></argument>,
<argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>dsc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"signature"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>dsc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"blocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nodes</name> <operator>+=</operator> <call><name>core_anal_graph_construct_nodes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>, <argument><expr><name>DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nodes</name> <operator>+=</operator> <call><name>core_anal_graph_construct_edges</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>, <argument><expr><name>DB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_trfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_traced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pal_box4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>nodes</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>bool</name></type> <name>r_core_anal_bb_seek</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>bbaddr</name> <init>= <expr><call><name>r_anal_get_bbaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bbaddr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bbaddr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_esil_fcn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esil</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>esil</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %d %s\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_fcn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reftype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Message: Invalid address for function 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>use_esil</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.esil"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>



<expr_stmt><expr><call><name>r_core_seek_arch_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>noncode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Address not mapped or not executable at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.a2f"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".a2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>r_core_anal_esil_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>from</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>at</name><operator>)</operator> <operator>||</operator> <name>at</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid address from 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: anal depth reached\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>at</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>reftype</name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name> <operator>&amp;&amp;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_LOC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>function_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>__core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_resize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_fcn_clean</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>iter_tmp</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_delete</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_print_bb_custom</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="string">"asm.marks"</literal></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>,
<argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="string">"asm.cmt.col"</literal></expr></argument>, <argument><expr><literal type="string">"asm.lines.fcn"</literal></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.marks"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.col"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines.fcn"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pdb @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body_b64</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>title</name> <operator>||</operator> <operator>!</operator><name>body</name> <operator>||</operator> <operator>!</operator><name>body_b64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>body_b64</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s %s\n"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>bb-&gt;switch_op-&gt;cases</argument>, <argument>it</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_ID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<function><type><name>R_API</name> <name>int</name></type> <name>r_core_print_bb_gml</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HtUUOptions</name></type> <name>opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ht_uu_new_opt</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"graph\n[\n"</literal> <literal type="string">"hierarchic 1\n"</literal> <literal type="string">"label \"\"\n"</literal> <literal type="string">"directed 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><ternary><condition><expr><name>flag</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_ID</name></expr></cpp:if>
<expr_stmt><expr><call><name>ht_uu_insert</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" node [\n"</literal>
<literal type="string">" id %d\n"</literal>
<literal type="string">" label \"%s\"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name><operator>++</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" node [\n"</literal>
<literal type="string">" id %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" label \"%s\"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_ID</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %d\n"</literal>
<literal type="string">" target %d\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %d\n"</literal>
<literal type="string">" target %d\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>bb-&gt;switch_op-&gt;cases</argument>, <argument>it</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i2</name> <init>= <expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %d\n"</literal>
<literal type="string">" target %d\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" target %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" target %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>bb-&gt;switch_op-&gt;cases</argument>, <argument>it</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" target %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_uu_free</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_datarefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>binsec</name> <init>= <expr><call><name>r_bin_get_section_at</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>binsec</name> <operator>&amp;&amp;</operator> <name><name>binsec</name><operator>-&gt;</operator><name>is_data</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><ternary><condition><expr><name>item</name></expr>?</condition><then> <expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Not in a function. Use 'df' to define it.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_coderefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><ternary><condition><expr><name>item</name></expr>?</condition><then> <expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name><argument_list>(<argument><expr><literal type="string">"Not in a function. Use 'df' to define it.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_importxrefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RBinInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>r_bin_get_info</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>lit</name> <init>= <expr><ternary><condition><expr><name>info</name></expr> ?</condition><then> <expr><name><name>info</name><operator>-&gt;</operator><name>has_lit</name></name></expr></then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>va</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name> <operator>||</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinImport</name> <modifier>*</modifier></type><name>imp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>obj</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;imports</argument>, <argument>iter</argument>, <argument>imp</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name>lit</name></expr> ?</condition><then> <expr><call><name>r_core_bin_impaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name><name>imp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_anal_codexrefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name><name>imp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_codexrefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>f</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name>addr</name><operator>)</operator></expr>
?</condition><then> <expr><call><name>r_str_new</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><ternary><condition><expr><name>item</name></expr>?</condition><then> <expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>RAnalRef_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnalRef</name><modifier>*</modifier></type> <name>ref1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RAnalRef</name><modifier>*</modifier></type> <name>ref2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>ref1</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name><name>ref2</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_callgraph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>font</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.font"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>refgraph</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.refs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>first2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>usenames</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.json.usenames"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>fcnr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.from"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fmt</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>R_GRAPH_FORMAT_JSON</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_GML</name></expr>:</case>
<case>case <expr><name>R_GRAPH_FORMAT_GMLFCN</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"graph\n[\n"</literal>
<literal type="string">"hierarchic 1\n"</literal>
<literal type="string">"label \"\"\n"</literal>
<literal type="string">"directed 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_DOT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_html</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_edge</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.edge"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_node</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.node"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_grph</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.graph"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_spline</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.spline"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_edge</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_edge</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_edge</name> <operator>=</operator> <literal type="string">"arrowhead=\"normal\" style=bold weight=2"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_node</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_node</name> <operator>=</operator> <literal type="string">"penwidth=4 fillcolor=white style=filled fontname=\"Courier New Bold\" fontsize=14 shape=box"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_grph</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_grph</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_grph</name> <operator>=</operator> <literal type="string">"bgcolor=azure"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_spline</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_spline</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gv_spline</name> <operator>=</operator> <literal type="string">"splines=\"curved\""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"digraph code {\n"</literal>
<literal type="string">"rankdir=LR;\n"</literal>
<literal type="string">"outputorder=edgesfirst;\n"</literal>
<literal type="string">"graph [%s fontname=\"%s\" %s];\n"</literal>
<literal type="string">"node [%s];\n"</literal>
<literal type="string">"edge [%s];\n"</literal></expr></argument>, <argument><expr><name>gv_grph</name></expr></argument>, <argument><expr><name>font</name></expr></argument>, <argument><expr><name>gv_spline</name></expr></argument>,
<argument><expr><name>gv_node</name></expr></argument>, <argument><expr><name>gv_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>base</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iteration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<label><name>repeat</name>:</label>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>from</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>calls</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter2</argument>, <argument>fcnr</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fcnr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'C'</literal> <operator>&amp;&amp;</operator> <call><name>r_list_find</name><argument_list>(<argument><expr><name>calls</name></expr></argument>, <argument><expr><name>fcnr</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>RAnalRef_cmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>, <argument><expr><name>fcnr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name><argument_list>(<argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_GRAPH_FORMAT_NO</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_GML</name></expr>:</case>
<case>case <expr><name>R_GRAPH_FORMAT_GMLFCN</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><ternary><condition><expr><name>flag</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" node [\n"</literal>
<literal type="string">" id %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" label \"%s\"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>base</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>R_GRAPH_FORMAT_JSON</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>usenames</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s{\"name\":\"%s\", "</literal>
<literal type="string">"\"size\":%d,\"imports\":["</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s{\"name\":\"0x%08"</literal> <name>PFMT64x</name>
<literal type="string">"\", \"size\":%d,\"imports\":["</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
<argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_DOT</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[label=\"%s\""</literal>
<literal type="string">" URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\"];\n"</literal></expr></argument>,
<argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>first2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>calls</argument>, <argument>iter2</argument>, <argument>fcnr</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnr_name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flag</name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"unk.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>fmt</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>R_GRAPH_FORMAT_GMLFCN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" node [\n"</literal>
<literal type="string">" id %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" label \"%s\"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>base</name></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" target %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<case>case <expr><name>R_GRAPH_FORMAT_GML</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" edge [\n"</literal>
<literal type="string">" source %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" target %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal>
<literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base</name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name><operator>-</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_DOT</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" -&gt; \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[color=\"%s\" URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\"];\n"</literal></expr></argument>,

<argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, 
<argument><expr><literal type="string">"#61afef"</literal></expr></argument>,
<argument><expr><name>fcnr_name</name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" \"0x%08"</literal><name>PFMT64x</name><literal type="string">"\" "</literal>
<literal type="string">"[label=\"%s\""</literal>
<literal type="string">" URL=\"%s/0x%08"</literal><name>PFMT64x</name><literal type="string">"\"];\n"</literal></expr></argument>,
<argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>,
<argument><expr><name>fcnr_name</name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_JSON</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>usenames</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\"%s\""</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>first2</name></expr>?</condition><then><expr><literal type="string">","</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\""</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>first2</name></expr>?</condition><then><expr><literal type="string">","</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>refgraph</name> <operator>||</operator> <name><name>fcnr</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#- 0x%08"</literal><name>PFMT64x</name><literal type="string">" (%c)\n"</literal></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcnr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flag</name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fcnr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>first2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>R_GRAPH_FORMAT_JSON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fmt</name> <operator>==</operator> <name>R_GRAPH_FORMAT_GML</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>iteration</name><operator>++</operator></expr>;</expr_stmt>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>iteration</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fmt</name> <operator>==</operator> <name>R_GRAPH_FORMAT_GMLFCN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>iteration</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch<condition>(<expr><name>fmt</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>R_GRAPH_FORMAT_GML</name></expr>:</case>
<case>case <expr><name>R_GRAPH_FORMAT_GMLFCN</name></expr>:</case>
<case>case <expr><name>R_GRAPH_FORMAT_JSON</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_GRAPH_FORMAT_DOT</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fcn_list_bbs</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bbi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bbi</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afb+ 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" 0x%08"</literal> <name>PFMT64x</name> <literal type="string">" %d "</literal></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>bbi</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>bbi</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" u"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>ut64</name></type> <name>r_core_anal_fcn_list_size</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>total</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>fcnlist_gather_metadata</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>callrefiter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numcallrefs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>callrefiter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>numcallrefs</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numcallrefs</name></name> <operator>=</operator> <name>numcallrefs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xrefs</name> <operator>=</operator> <call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numrefs</name></name> <operator>=</operator> <ternary><condition><expr><name>xrefs</name></expr>?</condition><then> <expr><name><name>xrefs</name><operator>-&gt;</operator><name>length</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_anal_fcn_name</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>demangle</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.demangle"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lang</name> <init>= <expr><ternary><condition><expr><name>demangle</name></expr> ?</condition><then> <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.lang"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>keep_lib</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.demangle.libs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>demangle</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_bin_demangle</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>keep_lib</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FCN_LIST_VERBOSE_ENTRY</name></cpp:macro> <cpp:value>"%s0x%0*"PFMT64x" %4d %5d %5d %5d %4d 0x%0*"PFMT64x" %5d 0x%0*"PFMT64x" %5d %4d %6d %4d %5d %s%s\n"</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_print_verbose</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_color</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ebbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addrwidth</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>color_end</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>color_end</name> <operator>=</operator> <name>Color_RESET</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"sym.imp."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>color</name> <operator>=</operator> <name>Color_YELLOW</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>color</name> <operator>=</operator> <name>Color_GREEN</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"sub."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>color</name> <operator>=</operator> <name>Color_MAGENTA</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addrwidth</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><name>FCN_LIST_VERBOSE_ENTRY</name></expr></argument>, <argument><expr><name>color</name></expr></argument>,
<argument><expr><name>addrwidth</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
<argument><expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebbs</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_anal_function_cost</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>addrwidth</name></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>addrwidth</name></expr></argument>, <argument><expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numcallrefs</name></name></expr></argument>,
<argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>numrefs</name></name></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>,
<argument><expr><name>color_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_verbose</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sortby</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>use_color</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>headeraddr_width</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>headeraddr</name> <init>= <expr><literal type="string">"=========="</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>headeraddr_width</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>headeraddr</name> <operator>=</operator> <literal type="string">"=================="</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sortby</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpfcncc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"edges"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"calls"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpcalls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"frame"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpframe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpxrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sortby</name></expr></argument>, <argument><expr><literal type="string">"nbbs"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpnbbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%-*s %4s %5s %5s %5s %4s %*s range %-*s %s %s %s %s %s %s\n"</literal></expr></argument>,
<argument><expr><name>headeraddr_width</name></expr></argument>, <argument><expr><literal type="string">"address"</literal></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="string">"nbbs"</literal></expr></argument>, <argument><expr><literal type="string">"edges"</literal></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>, <argument><expr><literal type="string">"cost"</literal></expr></argument>,
<argument><expr><name>headeraddr_width</name></expr></argument>, <argument><expr><literal type="string">"min bound"</literal></expr></argument>, <argument><expr><name>headeraddr_width</name></expr></argument>, <argument><expr><literal type="string">"max bound"</literal></expr></argument>, <argument><expr><literal type="string">"calls"</literal></expr></argument>,
<argument><expr><literal type="string">"locals"</literal></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><literal type="string">"xref"</literal></expr></argument>, <argument><expr><literal type="string">"frame"</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s ==== ===== ===== ===== ==== %s ===== %s ===== ====== ==== ==== ===== ====\n"</literal></expr></argument>,
<argument><expr><name>headeraddr</name></expr></argument>, <argument><expr><name>headeraddr</name></expr></argument>, <argument><expr><name>headeraddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_print_verbose</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>use_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__fcn_print_default</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>realsize</name> <init>= <expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>realsize</name> <operator>==</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%-12"</literal><name>PFMT64u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%-4"</literal><name>PFMT64u</name><literal type="string">" -&gt; %-4"</literal><name>PFMT64u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>realsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %4d %4s %s\n"</literal></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_default</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>__fcn_print_default</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>RList</name> <modifier>*</modifier></type><name>r_core_anal_fcn_get_calls</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_delete</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>refs</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_print_makestyle</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>refiter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>fcniter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>fcniter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>r_core_anal_fcn_get_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>r_list_uniq</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>RAnalRef_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"calls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">":\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" -&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>refiter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>f</name></expr>?</condition><then> <expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_print_json</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xrefs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ebbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"is-pure"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><call><name>r_anal_function_purity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realsz"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"noreturn"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>is_noreturn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"stackframe"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"calltype"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cost"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_cost</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"bits"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nbbs"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"edges"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebbs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ebbs"</literal></expr></argument>, <argument><expr><name>ebbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcf @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"signature"</literal></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"minbound"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"maxbound"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>outdegree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"callrefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>outdegree</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>||</operator>
<name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"at"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"datarefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>indegree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>xrefs</name> <operator>=</operator> <call><name>r_anal_function_get_xrefs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"codexrefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>||</operator>
<name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>indegree</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"at"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"dataxrefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"indegree"</literal></expr></argument>, <argument><expr><name>indegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"outdegree"</literal></expr></argument>, <argument><expr><name>outdegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>||</operator> <name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nlocals"</literal></expr></argument>, <argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"nargs"</literal></expr></argument>, <argument><expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"bpvars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"spvars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"regvars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"difftype"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then><expr><literal type="string">"match"</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then><expr><literal type="string">"unmatch"</literal></expr></then><else>:<expr><literal type="string">"new"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"diffaddr"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"diffname"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_json</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fcn_print_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_verbose_json</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>fcn_list_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_print_detail</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defaultCC</name> <init>= <expr><call><name>r_anal_cc_default</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"f %s %"</literal><name>PFMT64u</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"af+ 0x%08"</literal><name>PFMT64x</name><literal type="string">" %s %c %c\"\n"</literal></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, 
<argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_LOC</name></expr>?</condition><then><expr><literal type="char">'l'</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>?</condition><then><expr><literal type="char">'s'</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_IMP</name></expr>?</condition><then><expr><literal type="char">'i'</literal></expr></then><else>:<expr><literal type="char">'f'</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then><expr><literal type="char">'m'</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then><expr><literal type="char">'u'</literal></expr></then><else>:<expr><literal type="char">'n'</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fcn_list_bbs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afB %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name> <operator>||</operator> <name>defaultCC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afc %s @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr>?</condition><then><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></then><else>: <expr><name>defaultCC</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>folded</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afF @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvb* @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvr* @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afvs* @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>refiter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>refiter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_REF_TYPE_CALL</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"axC 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_DATA</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"axd 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_CODE</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"axc 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_STRING</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"axs 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_NULL</name></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ax 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"afS %"</literal><name>PFMT64d</name><literal type="string">" @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_fcn_traced</name><parameter_list>(<parameter><decl><type><name>RDebugTrace</name> <modifier>*</modifier></type><name>traced</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tag</name> <init>= <expr><name><name>traced</name><operator>-&gt;</operator><name>tag</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>traced-&gt;traces</argument>, <argument>iter</argument>, <argument>trace</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trace</name><operator>-&gt;</operator><name>tag</name></name> <operator>||</operator> <operator>(</operator><name>tag</name> <operator>&amp;</operator> <name><name>trace</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ntraced: %d\n"</literal></expr></argument>, <argument><expr><name><name>trace</name><operator>-&gt;</operator><name>times</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_print_legacy</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xrefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ebbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#\noffset: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\nname: %s\nsize: %"</literal><name>PFMT64u</name></expr></argument>,
<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nis-pure: %s"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><call><name>r_anal_function_purity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nrealsz: %d"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nstackframe: %d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ncall-convention: %s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ncyclomatic-cost : %d"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_cost</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ncyclomatic-complexity: %d"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nbits: %d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ntype: %s"</literal></expr></argument>, <argument><expr><call><name>r_anal_fcntype_tostring</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>||</operator> <name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" [%s]"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then><expr><literal type="string">"MATCH"</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then><expr><literal type="string">"UNMATCH"</literal></expr></then><else>:<expr><literal type="string">"NEW"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nnum-bbs: %d"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nedges: %d"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ebbs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nend-bbs: %d"</literal></expr></argument>, <argument><expr><name>ebbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ncall-refs:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>outdegree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>outdegree</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>||</operator> <name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %c"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>?</condition><then><expr><literal type="char">'C'</literal></expr></then><else>:<expr><literal type="char">'J'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ndata-refs:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>indegree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ncode-xrefs:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xrefs</name> <operator>=</operator> <call><name>r_anal_function_get_xrefs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>||</operator> <name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>indegree</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">" %c"</literal></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>?</condition><then><expr><literal type="char">'C'</literal></expr></then><else>:<expr><literal type="char">'J'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nnoreturn: %s"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>is_noreturn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nin-degree: %d"</literal></expr></argument>, <argument><expr><name>indegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nout-degree: %d"</literal></expr></argument>, <argument><expr><name>outdegree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\ndata-xrefs:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>||</operator> <name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>args_count</name> <init>= <expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>args_count</name> <operator>+=</operator> <call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>args_count</name> <operator>+=</operator> <call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>var_count</name> <init>= <expr><call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>var_count</name> <operator>+=</operator> <call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>var_count</name> <operator>+=</operator> <call><name>r_anal_var_count</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\nlocals: %d\nargs: %d\n"</literal></expr></argument>, <argument><expr><name>var_count</name></expr></argument>, <argument><expr><name>args_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_var_list_show</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"diff: type: %s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_MATCH</name></expr>?</condition><then><expr><literal type="string">"match"</literal></expr></then><else>:
<expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then><expr><literal type="string">"unmatch"</literal></expr></then><else>:<expr><literal type="string">"new"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"addr: 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"function: %s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>is_fcn_traced</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>trace</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_detail</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_print_detail</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_table</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeString</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeNumber</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"nbbs"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"xref"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"calls"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnAddr</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnSize</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64u</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nbbs</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name> <init>= <expr><call><name>r_anal_function_get_xrefs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>xref</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>ccstr</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>xref</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>xref</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type> <name>calls</name> <init>= <expr><call><name>r_core_anal_fcn_get_calls</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>calls</name> <operator>=</operator> <call><name>r_list_uniq</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>RAnalRef_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>callstr</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>ccstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ccstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_row</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>fcnAddr</name></expr></argument>, <argument><expr><name>fcnSize</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>nbbs</name></expr></argument>, <argument><expr><name>xref</name></expr></argument>, <argument><expr><name>callstr</name></expr></argument>, <argument><expr><name>ccstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>fmt</name><operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr>
?</condition><then> <expr><call><name>r_table_tojson</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>r_table_tofancystring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_list_legacy</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_print_legacy</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_fcn_list</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rad</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>temp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rad</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>__fcn_print_default</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>rad</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <operator>*</operator><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcnlist_gather_metadata</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcns</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>input</name> <operator>||</operator> <call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rad</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_default</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>rad</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_anal_fcn_list_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'='</literal></expr>:</case> <block>{<block_content> 
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>flist</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>r_listinfo_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<macro><name>ls_foreach</name> <argument_list>(<argument>fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RInterval</name></type> <name>inter</name> <init>= <expr><block>{<expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>, <macro><name>r_anal_function_linear_size</name> <argument_list>(<argument>fcn</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>r_listinfo_new</name> <argument_list>(<argument><expr><call><name>r_core_anal_fcn_name</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>info</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>flist</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_table_visual_list</name> <argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>flist</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,
<argument><expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n%s\n"</literal></expr></argument>, <argument><expr><call><name>r_table_tostring</name> <argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>flist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>rad</name><operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>rad</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_verbose_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>rad</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fcn_list_verbose</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><ternary><condition><expr><name>sp</name></expr>?</condition><then><expr><name>sp</name><operator>+</operator><literal type="number">1</literal></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fcn_list_default</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>fcn_list_json</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<expr_stmt><expr><call><name>fcn_list_detail</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>mode</name> <init>= <expr><literal type="char">'m'</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="char">'j'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>rad</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="char">'q'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fcn_print_makestyle</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>fcn_list_legacy</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>fcn_list_default</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcns</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>recurse_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>recurse</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>recurse_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>recurse_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>recurse_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bb</name> <operator>==</operator> <name>dest</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"path found!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>recurse</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>void</name></type> <name>r_core_recover_vars</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>argonly</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>reg_set</name><index>[<expr><name>R_ANAL_CC_MAXARG</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_bb_size</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>tmp</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>max_bb_size</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saved_stack</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>parent_stackptr</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>pos</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>

<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_extract_rarg</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>reg_set</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argonly</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>==</operator> <name>R_ANAL_STACK_INC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>==</operator> <name>R_ANAL_STACK_RESET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_extract_vars</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opsize</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opsize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>opsize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>saved_stack</name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>anal_path_exists</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>bbs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>avoid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>refi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"going too deep\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bb</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ht_up_update</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>(</operator><operator>!</operator><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>avoid</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>anal_path_exists</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><operator>!</operator><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>avoid</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>anal_path_exists</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_prepend</name> <argument_list>(<argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>cur_fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>cur_fcn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>cur_fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>refs</name></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>refi</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>refi</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>refi</name><operator>-&gt;</operator><name>at</name></name> <operator>!=</operator> <name><name>refi</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>anal_path_exists</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>refi</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_prepend</name> <argument_list>(<argument><expr><name>bbs</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>anal_graph_to</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>avoid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>cur_fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name> <operator>||</operator> <operator>!</operator><name>state</name> <operator>||</operator> <operator>!</operator><name>cur_fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>anal_path_exists</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>cur_fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xrefs</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>xref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>xref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>xref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>xref</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>anal_graph_to</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name><modifier>*</modifier></type> <name>r_core_anal_graph_to</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.graph_depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>paths</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>avoid</name> <init>= <expr><call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>anal_graph_to</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>avoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ht_up_update</name> <argument_list>(<argument><expr><name>avoid</name></expr></argument>, <argument><expr><name><name>last</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>avoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>paths</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_graph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.from"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>font</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.font"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_json</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_json_format_disasm</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_JSON_FORMAT_DISASM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_keva</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_KEYVALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_star</name> <init>= <expr><name>opts</name> <operator>&amp;</operator> <name>R_CORE_ANAL_STAR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hc</name> <operator>=</operator> <call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hc</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><literal type="string">"asm.dwarf"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.dwarf"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_json_format_disasm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_html</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_keva</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_edge</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.edge"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_node</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.node"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>gv_spline</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.gv.spline"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_edge</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_edge</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_edge</name> <operator>=</operator> <literal type="string">"arrowhead=\"normal\""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_node</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_node</name> <operator>=</operator> <literal type="string">"fillcolor=gray style=filled shape=box"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gv_spline</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>gv_spline</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gv_spline</name> <operator>=</operator> <literal type="string">"splines=\"ortho\""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"digraph code {\n"</literal>
<literal type="string">"\tgraph [bgcolor=azure fontsize=8 fontname=\"%s\" %s];\n"</literal>
<literal type="string">"\tnode [%s];\n"</literal>
<literal type="string">"\tedge [%s];\n"</literal></expr></argument>, <argument><expr><name>font</name></expr></argument>, <argument><expr><name>gv_spline</name></expr></argument>, <argument><expr><name>gv_node</name></expr></argument>, <argument><expr><name>gv_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcni</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <operator>(</operator><name>R_ANAL_FCN_TYPE_SYM</name> <operator>|</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>|</operator>
<name>R_ANAL_FCN_TYPE_LOC</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>addr</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>fcni</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>from</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>from</name> <operator>||</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nodes</name> <operator>+=</operator> <call><name>core_anal_graph_nodes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodes</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_html</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_keva</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_star</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>get_title</name><argument_list>(<argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></then><else>: <expr><name>addr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s;"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if><else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\t\"0x%08"</literal><name>PFMT64x</name><literal type="string">"\";\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></then><else>: <expr><name>addr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_keva</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_html</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_star</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_json_format_disasm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>core_anal_followptr</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>ptr</name> <operator>==</operator> <name>ref</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalRefType</name></type> <name>t</name> <init>= <expr><ternary><condition><expr><name>code</name></expr>?</condition><then> <expr><ternary><condition><expr><name>type</name></expr>?</condition><then> <expr><name>type</name></expr></then><else>: <expr><name>R_ANAL_REF_TYPE_CODE</name></expr></else></ternary></expr></then><else>: <expr><name>R_ANAL_REF_TYPE_DATA</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordsize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>dataptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_read_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataptr</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>core_anal_followptr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>dataptr</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>opiscall</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>aop</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>arch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R2_ARCH_ARM64</name></expr>:</case>
<expr_stmt><expr><name><name>aop</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>%</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>diff</name> <init>= <expr><name>addr</name> <operator>%</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>addr</name> <operator>-</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>buf</name> <operator>-</operator> <name>diff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x94</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name><name>aop</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPSZ</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>malloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ptrdepth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ptrdepth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>bckwrds</name></decl>, <decl><type ref="prev"/><name>do_bckwrd_srch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arch</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arch</name> <operator>=</operator> <name>R2_ARCH_ARM64</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>do_bckwrd_srch</name> <operator>=</operator> <name>bckwrds</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_use_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Null reference search is not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&gt;</operator> <name>OPSZ</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bckwrds</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><name>do_bckwrd_srch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name>to</name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><operator>(</operator><operator>!</operator><name>bckwrds</name> <operator>&amp;&amp;</operator> <name>at</name> <operator>&lt;</operator> <name>to</name><operator>)</operator> <operator>||</operator> <name>bckwrds</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\r[0x%08"</literal><name>PFMT64x</name><literal type="string">"-0x%08"</literal><name>PFMT64x</name><literal type="string">"] "</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to read at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>bckwrds</name></expr> ?</condition><then> <expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>OPSZ</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</init>
<condition><expr><operator>(</operator><operator>!</operator><name>bckwrds</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>OPSZ</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>bckwrds</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition>
<incr><expr><ternary><condition><expr><name>bckwrds</name></expr> ?</condition><then> <expr><name>i</name><operator>--</operator></expr> </then><else>: <expr><name>i</name><operator>++</operator></expr></else></ternary></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>opiscall</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><name>mode</name><operator>==</operator><literal type="char">'r'</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><name>mode</name> <operator>==</operator> <literal type="char">'w'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><ternary><condition><expr><name>mode</name> <operator>==</operator> <literal type="char">'x'</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>direction</name></name> <operator>==</operator> <name>mask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator>
<call><name>core_anal_followptr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UCJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MJMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator>
<call><name>core_anal_followptr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>true</name></expr></argument> ,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCCALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator>
<call><name>core_anal_followptr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>true</name></expr></argument> ,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator>
<call><name>core_anal_followptr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ptrdepth</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>bckwrds</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_bckwrd_srch</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&gt;</operator> <name>from</name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>OPSZ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>-=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>do_bckwrd_srch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>OPSZ</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: block size too small\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>found_xref</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>xref_to</name></decl></parameter>, <parameter><decl><type><name>RAnalRefType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cfg_debug</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cfg_anal_strings</name></decl></parameter>)</parameter_list> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_REF_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_debug</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_debug_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rad</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_string</name> <init>= <expr><call><name>is_string_at</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str_string</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_name_filter</name> <argument_list>(<argument><expr><name>str_string</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_flagname</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"str.%s"</literal></expr></argument>, <argument><expr><name>str_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_STRINGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>str_flagname</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_meta_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_STRING</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>,
<argument><expr><name>xref_to</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>str_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xref_to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rad</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"0x%"</literal><name>PFMT64x</name><literal type="string">"\":\"0x%"</literal><name>PFMT64x</name><literal type="string">"\""</literal></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_REF_TYPE_CODE</name></expr>:</case> <expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"axc"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_CALL</name></expr>:</case> <expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"axC"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>R_ANAL_REF_TYPE_DATA</name></expr>:</case> <expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"axd"</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"ax"</literal></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_flagname</name> <init>= <expr><call><name>is_string_at</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str_flagname</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>str_addr</name> <init>= <expr><name>xref_to</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_name_filter</name> <argument_list>(<argument><expr><name>str_flagname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f str.%s=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>str_flagname</name></expr></argument>, <argument><expr><name>str_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Cs %d @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>str_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_search_xrefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rad</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cfg_debug</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cfg_anal_strings</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.strings"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bsz</name> <init>= <expr><literal type="number">8096</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid range (0x%"</literal><name>PFMT64x</name>
<literal type="string">" &gt;= 0x%"</literal><name>PFMT64x</name><literal type="string">")\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&lt;=</operator> <name>OPSZ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: block size too small\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: cannot allocate a block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: cannot allocate a temp block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>st64</name></type> <name>asm_var_submin</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.var.submin"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>at</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><name>bsz</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>bsz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bsz</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsz</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ret</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;</operator> <name>bsz</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>st64</name><operator>)</operator><name><name>op</name><operator>.</operator><name>val</name></name> <operator>&gt;</operator> <name>asm_var_submin</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>&gt;</operator> <literal type="number">512</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>disp</name></name> <operator>&gt;</operator> <literal type="number">512</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>disp</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>disp</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>disp</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CODE</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCJMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CODE</name></expr></argument>, <argument><expr><name>count</name><operator>++</operator></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCCALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>found_xref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><name>cfg_debug</name></expr></argument>, <argument><expr><name>cfg_anal_strings</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>bsz</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isValidSymbol</name><parameter_list>(<parameter><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>symbol</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>symbol</name> <operator>&amp;&amp;</operator> <name><name>symbol</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name><name>symbol</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name><name>symbol</name><operator>-&gt;</operator><name>paddr</name></name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>R_BIN_TYPE_FUNC_STR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>R_BIN_TYPE_HIOS_STR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>R_BIN_TYPE_LOOS_STR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>R_BIN_TYPE_METH_STR</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument> , <argument><expr><name>R_BIN_TYPE_STATIC_STR</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isSkippable</name><parameter_list>(<parameter><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>bind</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"radr://"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"__mh_execute_header"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bind</name></name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_imported</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>libname</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>libname</name></name></expr></argument>, <argument><expr><literal type="string">".dll"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_all</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinAddr</name> <modifier>*</modifier></type><name>binmain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinAddr</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>depth</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>anal_vars</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.vars"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"entry0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afn entry0 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>r_bin_get_symbols</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>symbol</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isSkippable</name> <argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isValidSymbol</name> <argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_bin_get_vaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>paddr</name></name></expr></argument>,
<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>binmain</name> <operator>=</operator> <call><name>r_bin_get_sym</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>R_BIN_SYM_MAIN</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>binmain</name><operator>-&gt;</operator><name>paddr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_bin_get_vaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>binmain</name><operator>-&gt;</operator><name>paddr</name></name></expr></argument>, <argument><expr><name><name>binmain</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>r_bin_get_entries</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>entry</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>paddr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_bin_get_vaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>paddr</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>anal_vars</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_recover_vars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcni</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_anal_data</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wordsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalData</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>dstaddr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>word</name> <init>= <expr><ternary><condition><expr><name>wordsize</name></expr> ?</condition><then> <expr><name>wordsize</name></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RConsPrintablePalette</name> <modifier>*</modifier></type><name>pal</name> <init>= <expr><ternary><condition><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><operator>&amp;</operator><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>context</name><operator>-&gt;</operator><name>pal</name></name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>r_anal_data</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_anal_data_to_string</name> <argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_DATA_TYPE_POINTER</name></expr>:</case>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"`- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dstaddr</name> <operator>=</operator> <call><name>r_mem_get_num</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_anal_data</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>dstaddr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>wordsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>word</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_DATA_TYPE_STRING</name></expr>:</case>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></then><else>: <expr><name>word</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>word</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_data_free</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>block_flags_stat_t</name> <block>{
<decl_stmt><decl><type><name>ut64</name></type> <name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCoreAnalStats</name> <modifier>*</modifier></type><name>as</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>block_flags_stat</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block_flags_stat_t</name></name> <modifier>*</modifier></type><name>u</name> <init>= <expr><operator>(</operator>struct <name>block_flags_stat_t</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>piece</name> <init>= <expr><operator>(</operator><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>u</name><operator>-&gt;</operator><name>from</name></name><operator>)</operator> <operator>/</operator> <name><name>u</name><operator>-&gt;</operator><name>step</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>flags</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>RCoreAnalStats</name><modifier>*</modifier></type> <name>r_core_anal_get_stats</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>step</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>F</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>B</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCoreAnalStats</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>piece</name></decl>, <decl><type ref="prev"/><name>as_size</name></decl>, <decl><type ref="prev"/><name>blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name> <operator>||</operator> <name>from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot alloc for this range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>as</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RCoreAnalStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>as</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>step</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>blocks</name> <operator>=</operator> <operator>(</operator><name>to</name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name>as_size</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>blocks</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RCoreAnalStatsItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>as_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>as</name><operator>-&gt;</operator><name>block</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>as</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>as_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>piece</name> <operator>=</operator> <operator>(</operator><name>at</name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>perm</name> <operator>=</operator> <ternary><condition><expr><name>map</name></expr> ?</condition><then> <expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>perm</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><name><name>struct</name> <name>block_flags_stat_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>step</name> <operator>=</operator> <name>step</name></expr>, <expr><operator>.</operator><name>from</name> <operator>=</operator> <name>from</name></expr>, <expr><operator>.</operator><name>as</name> <operator>=</operator> <name>as</name></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_foreach_range</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>block_flags_stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>F</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>F</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>from</name> <operator>||</operator> <name><name>F</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>piece</name> <operator>=</operator> <operator>(</operator><name><name>F</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>functions</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>last_piece</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><operator>(</operator><name><name>F</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>step</name></expr></argument>, <argument><expr><name>blocks</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>piece</name> <operator>&lt;=</operator> <name>last_piece</name></expr>;</condition> <incr><expr><name>piece</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>in_functions</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<macro><name>r_list_foreach</name> <argument_list>(<argument>F-&gt;bbs</argument>, <argument>iter2</argument>, <argument>B</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>B</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>from</name> <operator>||</operator> <name><name>B</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>piece</name> <operator>=</operator> <operator>(</operator><name><name>B</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>blocks</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>r_bin_get_symbols (core-&gt;bin)</argument>, <argument>iter</argument>, <argument>S</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>S</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&lt;</operator> <name>from</name> <operator>||</operator> <name><name>S</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>piece</name> <operator>=</operator> <operator>(</operator><name><name>S</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>symbols</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>metas</name> <init>= <expr><call><name>r_meta_enumerate</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalMetaItem</name> <modifier>*</modifier></type><name>M</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>metas</argument>, <argument>iter</argument>, <argument>M</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>M</name><operator>-&gt;</operator><name>from</name></name> <operator>&lt;</operator> <name>from</name> <operator>||</operator> <name><name>M</name><operator>-&gt;</operator><name>to</name></name> <operator>&gt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>piece</name> <operator>=</operator> <operator>(</operator><name><name>M</name><operator>-&gt;</operator><name>from</name></name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>/</operator> <name>step</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>M</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_META_TYPE_STRING</name></expr>:</case>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>strings</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_META_TYPE_COMMENT</name></expr>:</case>
<expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>block</name><index>[<expr><name>piece</name></expr>]</index></name><operator>.</operator><name>comments</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>metas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><name>as</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_stats_free</name><parameter_list>(<parameter><decl><type><name>RCoreAnalStats</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name><modifier>*</modifier></type> <name>r_core_anal_cycles</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ccl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalCycleFrame</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalCycleHook</name> <modifier>*</modifier></type><name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hooks</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hooks</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>r_anal_cycle_frame_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cf</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>=</operator> <call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>cycles</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>ccl</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%i -- "</literal></expr></argument>, <argument><expr><name>ccl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>loganal</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" &gt; ?\r"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>ch</name> <operator>&amp;&amp;</operator> <name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_cycle_frame_free</name> <argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>cf</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>failcycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>loganal</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UCJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCCALL</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>failcycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" &gt; ?\r"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>failcycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>cf</name><operator>-&gt;</operator><name>naddr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>r_anal_cycle_frame_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cf</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>loganal</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>naddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" &lt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>naddr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"? &lt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>ch</name> <operator>&amp;&amp;</operator> <name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_cycle_frame_free</name> <argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>cf</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CRET</name></expr>:</case>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>naddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" &lt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>naddr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"? &lt; 0x%08"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>failcycles</name></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ccl</name> <operator>-=</operator> <name><name>op</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\r"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalCycleHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_cycle_frame_free</name> <argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name>ccl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>ch</name> <operator>&amp;&amp;</operator> <name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccl</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_cycle_frame_free</name> <argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>cf</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>cf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>cf</name><operator>-&gt;</operator><name>hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>cf</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_cycle_frame_free</name> <argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cf</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hooks</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_undefine</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"fcn."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_flag_unset_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_meta_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_ANY</name></expr></argument>, <argument><expr><call><name>r_anal_function_min_addr</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_fcn_del_locs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_fcn_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_fcn_merge</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f1</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f2</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f1</name> <operator>||</operator> <operator>!</operator><name>f2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>f1</name> <operator>==</operator> <name>f2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot merge the same function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Merge 0x%08"</literal><name>PFMT64x</name><literal type="string">" into 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>f1-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>min</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<macro><name>r_list_foreach</name> <argument_list>(<argument>f2-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>min</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_function_add_block</name> <argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>r_anal_function_delete</name> <argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_function_relocate</name> <argument_list>(<argument><expr><name>f2</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>esil_anal_stop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cccb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>esil_anal_stop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"^C\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_string_ref</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>xref_from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>xref_to</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xref_to</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <operator>!</operator><name>xref_to</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xref_from</name> <operator>||</operator> <name>xref_from</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>xref_from</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_flagname</name> <init>= <expr><call><name>is_string_at</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str_flagname</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>xref_from</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_name_filter</name> <argument_list>(<argument><expr><name>str_flagname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flagname</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"str.%s"</literal></expr></argument>, <argument><expr><name>str_flagname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_STRINGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagname</name></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_meta_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><name>xref_to</name></expr></argument>, <argument><expr><name>xref_to</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>str_flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str_flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>myvalid</name><parameter_list>(<parameter><decl><type><name>RIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <literal type="number">0x100</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT32_MAX</name> <operator>||</operator> <name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content> 
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>esilbreak_mem_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>esilbreak_last_read</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>esilbreak_last_data</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>ntarget</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type> <name>esilbreak_mem_read</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>str</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>esilbreak_last_read</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>refptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>trace</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>esilbreak_last_data</name> <operator>=</operator> <name>refptr</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_ble16</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>esilbreak_last_data</name> <operator>=</operator> <name>refptr</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>esilbreak_last_data</name> <operator>=</operator> <name>refptr</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<decl_stmt><decl><type><name>bool</name></type> <name>validRef</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trace</name> <operator>&amp;&amp;</operator> <call><name>myvalid</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>refptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ntarget</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>ntarget</name> <operator>==</operator> <name>refptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>refptr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>validRef</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name>refptr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>mycore</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name>refptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>esilbreak_last_data</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>validRef</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ntarget</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>ntarget</name> <operator>==</operator> <name>addr</name> <operator>||</operator> <operator>(</operator><name>ntarget</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>validRef</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>esilbreak_reg_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><operator>*</operator><name>val</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>anal</name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>armthumb</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&lt;</operator> <literal type="number">33</literal> <operator>&amp;&amp;</operator>
<call><name>strstr</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pc"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>op</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case> 
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>val</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>*</operator><name>val</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>snv</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"pc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>snv</name> <operator>!=</operator> <name>UT32_MAX</name> <operator>&amp;&amp;</operator> <name>snv</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><operator>*</operator><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>*</operator><name>val</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><name>at</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>getpcfromstack</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalEsil</name></type> <name>esil_cpy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_esil_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmp_esil_str_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxaddrlen</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><name>esil</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>esil_cpy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>cur</name> <operator>=</operator> <name><name>esil_cpy</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_MOV</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_CMOV</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>esilstr</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>spname</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>spname</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>spname</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp_esil_str_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>esilstr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>spname</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>maxaddrlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_esil_str</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>tmp_esil_str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_esil_str</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tmp_esil_str</name><index>[<expr><name>tmp_esil_str_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>, <argument><expr><name>tmp_esil_str_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s,["</literal></expr></argument>, <argument><expr><name>spname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>esilstr</name> <operator>||</operator> <operator>(</operator><call><name>strncmp</name> <argument_list>( <argument><expr><name>esilstr</name></expr></argument>, <argument><expr><name>tmp_esil_str</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>, <argument><expr><name>tmp_esil_str_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%20"</literal> <name>PFMT64u</name> <literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>esil_cpy</name><operator>.</operator><name>old</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>esilstr</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>spname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><name>tmp_esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_esil_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RET</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_CRET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>esilstr</name> <operator>=</operator> <call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esilstr</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_anal_op</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>esil_cpy</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>esil_cpy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err_anal_op</name>:</label>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_esil</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>cfg_anal_strings</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.strings"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>emu_lazy</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"emu.lazy"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>gp_fixed</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.gpfixed"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>ESIL</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>refptr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pcname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>end_address_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minopsize</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>archIsArm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>cur</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mycore</name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" aae $SS @ $S - analyze the whole section\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" aae $SS str.Hello @ $S - find references for str.Hellow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" aaef - analyze functions discovered with esil\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKREF</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((refptr &amp;&amp; (x) == refptr) || !refptr)</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>expr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>refptr</name> <operator>=</operator> <name>ntarget</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ntarget</name> <operator>=</operator> <name>refptr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ntarget</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>refptr</name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ntarget</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>refptr</name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>r_anal_function_max_addr</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end_address_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end_address_set</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>iend</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>addr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>iend</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>iend</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>esilbreak_last_read</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>iend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ESIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ESIL</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ESIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ESIL not initialized\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_write</name></name> <operator>=</operator> <operator>&amp;</operator><name>esilbreak_reg_write</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ESIL</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <operator>&amp;</operator><name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name> <operator>=</operator> <operator>&amp;</operator><name>esilbreak_mem_read</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_write</name></name> <operator>=</operator> <operator>&amp;</operator><name>esilbreak_mem_write</name></expr>;</expr_stmt>


<expr_stmt><expr><name>pcname</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pcname</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>pcname</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find program counter register in the current profile.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>esil_anal_stop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>cccb</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arch</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">64</literal></expr>:</case> <expr_stmt><expr><name>arch</name> <operator>=</operator> <name>R2_ARCH_ARM64</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case> <expr_stmt><expr><name>arch</name> <operator>=</operator> <name>R2_ARCH_ARM32</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>arch</name> <operator>=</operator> <name>R2_ARCH_THUMB</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>archIsArm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>gp</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.gp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gp_reg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"mips"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gp_reg</name> <operator>=</operator> <literal type="string">"gp"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>arch</name> <operator>=</operator> <name>R2_ARCH_MIPS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: No SN reg alias for current architecture.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iend</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<label><name>repeat</name>:</label>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>mininstrsz</name> <operator>&gt;=</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>esil_anal_stop</name> <operator>||</operator> <call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_meta_find_list_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalMetaItem</name> <modifier>*</modifier></type><name>meta</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>meta</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_META_TYPE_DATA</name></expr>:</case>
<case>case <expr><name>R_META_TYPE_STRING</name></expr>:</case>
<case>case <expr><name>R_META_TYPE_FORMAT</name></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></switch>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>


<expr_stmt><expr><call><name>r_core_seek_arch_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opalign</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>pcalign</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>opalign</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cur</name> <operator>-=</operator> <operator>(</operator><name>cur</name> <operator>%</operator> <name>opalign</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>iend</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>minopsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_ILL</name> <operator>||</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_UNK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>iend</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>minopsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>emu_lazy</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_REP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ILL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_NOP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IO</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_LEAVE</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CRYPTO</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CPL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SYNC</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SWI</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ACMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_NULL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CSWI</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_TRAP</name></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>

<case>case <expr><name>R_ANAL_OP_TYPE_PUSH</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_POP</name></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sn</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_SWI</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_flag_space_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_SYSCALLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>snv</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>arch</name> <operator>==</operator> <name>R2_ARCH_THUMB</name><operator>)</operator></expr>?</condition><then> <expr><name><name>op</name><operator>.</operator><name>val</name></name></expr></then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RSyscallItem</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>snv</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_set_next</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"syscall.%s"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><call><name>r_flag_set_next</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"syscall.%d"</literal></expr></argument>, <argument><expr><name>snv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_flag_space_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esilstr</name> <init>= <expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esilstr</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>esilstr</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name>ESIL</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pcname</name></expr></argument>, <argument><expr><name>cur</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gp_fixed</name> <operator>&amp;&amp;</operator> <name>gp_reg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_reg_setv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>gp_reg</name></expr></argument>, <argument><expr><name>gp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>ESIL</name></expr></argument>, <argument><expr><name>esilstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name>arch</name> <operator>==</operator> <name>R2_ARCH_ARM64</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>target</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>ntarget</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>target</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>noncode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_ADD</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name>archIsArm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>target</name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>ntarget</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>target</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name>arch</name> <operator>==</operator> <name>R2_ARCH_MIPS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name><name>ESIL</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>reg</name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"zero"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>target</name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>ntarget</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>target</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&gt;</operator> <literal type="number">0xffff</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dst</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>imm</name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>myvalid</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CHECKREF</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name>r_core_flag_get_by_spaces</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>is_string_at</name> <argument_list>(<argument><expr><name>mycore</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str2</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"esilref: '%s'"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>r_str_replace_char</name> <argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_LOAD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name>esilbreak_last_read</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>esilbreak_last_data</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>mycore</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg_anal_strings</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ESIL</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>cur</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getpcfromstack</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MJMP</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>jump_target</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>dst</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHECKREF</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myvalid</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalRefType</name></type> <name>ref</name> <init>=
<expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name><operator>)</operator> <operator>==</operator> <name>R_ANAL_OP_TYPE_UCALL</name></expr>
?</condition><then> <expr><name>R_ANAL_REF_TYPE_CALL</name></expr>
</then><else>: <expr><name>R_ANAL_REF_TYPE_CODE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {
eprintf ("0x%08"PFMT64x" RCALL TO %llx\n", cur, dst);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isValidAddress</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name><modifier>*</modifier></type> <name>map</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>st64</name></type> <name>fdsz</name> <init>= <expr><operator>(</operator><name>st64</name><operator>)</operator><call><name>r_io_fd_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fdsz</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>map</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <name>fdsz</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>r_io_desc_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"null://"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stringAt</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>is_string</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_search_value_in_range</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>search_itv</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>vmin</name></decl></parameter>,
<parameter><decl><type><name>ut64</name></type> <name>vmax</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vsize</name></decl></parameter>, <parameter><decl><type><name>inRangeCb</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>align</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name></expr></init></decl>, <decl><type ref="prev"/><name>hitctr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>vinfun</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.vinfun"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>vinfunr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.vinfunrange"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>analStrings</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.strings"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mycore</name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>v64</name></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>search_itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>v32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut16</name></type> <name>v16</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: from must be lower than to\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>maybeThumb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>!=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maybeThumb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vmin</name> <operator>&gt;=</operator> <name>vmax</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: vmin must be lower than vmax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Invalid destination boundary\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>to</name> <operator>-</operator> <name>from</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>r_io_read_at_mapped</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\xff\xff\xff\xff"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x00\x00\x00\x00"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isValidAddress</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>next</name> <init>= <expr><call><name>r_io_map_next_address</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <operator>(</operator><name>next</name> <operator>-</operator> <name>from</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <operator>(</operator><name>size</name> <operator>-</operator> <name>vsize</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>buf</name> <operator>+</operator> <name>i</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>from</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name><operator>)</operator> <operator>%</operator> <name>align</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><name>size</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>vsize</name> <operator>&gt;</operator> <name>left</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>vsize</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt> <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>vmin</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>vmax</name><operator>)</operator></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>v16</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uut16</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt> <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><name>v16</name> <operator>&gt;=</operator> <name>vmin</name> <operator>&amp;&amp;</operator> <name>v16</name> <operator>&lt;=</operator> <name>vmax</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>value</name> <operator>=</operator> <name>v16</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>v32</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uut32</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt> <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><name>v32</name> <operator>&gt;=</operator> <name>vmin</name> <operator>&amp;&amp;</operator> <name>v32</name> <operator>&lt;=</operator> <name>vmax</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>value</name> <operator>=</operator> <name>v32</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>v64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uut64</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt> <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><name>v64</name> <operator>&gt;=</operator> <name>vmin</name> <operator>&amp;&amp;</operator> <name>v64</name> <operator>&lt;=</operator> <name>vmax</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>value</name> <operator>=</operator> <name>v64</name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown vsize %d\n"</literal></expr></argument>, <argument><expr><name>vsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>match</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>vinfun</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vinfunr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_get_fcn_in_bounds</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>match</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>isValidMatch</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>value</name> <operator>%</operator> <name>align</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isValidMatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>maybeThumb</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>value</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isValidMatch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isValidMatch</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>hitctr</name></expr></argument>, <argument><expr><name>cb_user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>analStrings</name> <operator>&amp;&amp;</operator> <call><name>stringAt</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_string_ref</name> <argument_list>(<argument><expr><name>mycore</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hitctr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name>to</name><operator>-</operator><name>from</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <name>size</name><operator>-</operator><name>vsize</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hitctr</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>dict</name></type> <name>visited</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>fromBB</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>toBB</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>followCalls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>followDepth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt> 
}</block></struct></type> <name>RCoreAnalPaths</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>printAnalPaths</name><parameter_list>(<parameter><decl><type><name>RCoreAnalPaths</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"pdb @@= "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>p-&gt;path</argument>, <argument>iter</argument>, <argument>path</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_n</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>

<if_stmt><if>if<condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>analPaths</name><parameter_list>(<parameter><decl><type><name>RCoreAnalPaths</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>analPathFollow</name><parameter_list>(<parameter><decl><type><name>RCoreAnalPaths</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dict_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>analPaths</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>analPaths</name><parameter_list>(<parameter><decl><type><name>RCoreAnalPaths</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dict_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>followDepth</name></name> <operator>&amp;&amp;</operator> <operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>followDepth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>toBB</name></name> <operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>toBB</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>printAnalPaths</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>cur</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>j</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>jump</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>f</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>fail</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>analPathFollow</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>analPathFollow</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>followCalls</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cur</name><operator>-&gt;</operator><name>op_pos_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>op_pos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>analPathFollow</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dict_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>followDepth</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>followDepth</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_paths</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>followCalls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>followDepth</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_json</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b0</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b0</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find basic block for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find basic block for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RCoreAnalPaths</name></type> <name>rcap</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dict_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>rcap</name><operator>.</operator><name>visited</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>core</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>fromBB</name></name> <operator>=</operator> <name>b0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>toBB</name></name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>cur</name></name> <operator>=</operator> <name>b0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>count</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.maxhits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>followCalls</name></name> <operator>=</operator> <name>followCalls</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rcap</name><operator>.</operator><name>followDepth</name></name> <operator>=</operator> <name>followDepth</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>analPaths</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rcap</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dict_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>rcap</name><operator>.</operator><name>visited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>rcap</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__cb</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__addrs_cmp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>a</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_inflags</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>a2f</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.a2f"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>anal_in</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>simple</name> <init>= <expr><operator>(</operator><operator>!</operator><name>glob</name> <operator>||</operator> <operator>*</operator><name>glob</name> <operator>!=</operator> <literal type="char">'a'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>__cb</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>addrs</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>__addrs_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>addrs</argument>, <argument>iter</argument>, <argument>addr</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>n</name></name> <operator>||</operator> <call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr2</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>n</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>||</operator> <operator>!</operator><name>addr2</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>a0</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>a1</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a0</name> <operator>==</operator> <name>a1</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a0</name> <operator>&gt;</operator> <name>a1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: unsorted flag list 0x%llx 0x%llx\n"</literal></expr></argument>, <argument><expr><name>a0</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>st64</name></type> <name>sz</name> <init>= <expr><name>a1</name> <operator>-</operator> <name>a0</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sz</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>sz</name></expr></argument> &gt;</argument_list></name> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: invalid flag range from 0x%08"</literal><name>PFMT64x</name><literal type="string">" to 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>a0</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af+ %s fcn.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fi</name></expr>?</condition><then> <expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><name>addr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afb+ %s %s %d"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aab@%s!%s-%s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %"</literal><name>PFMT64d</name><literal type="string">" #%s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="string">"af"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a2f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"a2f@%s!%s-%s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af@%s!%s-%s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %.4"</literal><name>PFMT64d</name><literal type="string">" #%s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="string">"aab"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr>?</condition><then><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>, <argument><expr><name>anal_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>anal_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>analyze_noreturn_function</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>f-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>opaddr</name> <init>= <expr><call><name>r_anal_bb_opaddr_i</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>opaddr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_op_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>opaddr</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot analyze opcode at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>opaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_ILL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_propagate_noreturn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>todo</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>todo</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>done</name> <init>= <expr><call><name>ht_uu_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>is_noreturn</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<while>while <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>paddr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>*</operator><operator>)</operator><call><name>r_list_pop</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>noret_addr</name> <init>= <expr><operator>*</operator><name>paddr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>paddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>noret_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>xref</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>xrefs</argument>, <argument>iter</argument>, <argument>xref</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>xrefop</name> <init>= <expr><call><name>r_core_op_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>xref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xrefop</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot analyze opcode at 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>xref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>xrefop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>xref</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_REF_TYPE_CALL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>xref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>xref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name> <operator>||</operator> <operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_FCN_TYPE_SYM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_del_locs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name> <operator>||</operator> <operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_FCN_TYPE_FCN</name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_FCN_TYPE_SYM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>done</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <call><name>analyze_noreturn_function</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_noreturn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_noreturn_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_uu_insert</name> <argument_list>(<argument><expr><name>done</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>todo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_uu_free</name> <argument_list>(<argument><expr><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_anal_esil_graph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalEsilDFG</name> <modifier>*</modifier></type> <name>edf</name> <init>= <expr><call><name>r_anal_esil_dfg_expr</name><argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>edon</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ag-\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>r_graph_get_nodes (edf-&gt;flow)</argument>, <argument>iter</argument>, <argument>node</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalEsilDFGNode</name> <modifier>*</modifier></type><name>enode</name> <init>= <expr><operator>(</operator><name>RAnalEsilDFGNode</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esc_str</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name><name>enode</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>esc_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>enode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_ESIL_DFG_BLOCK_GENERATIVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_prepend</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"generative:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b64_buf</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %d base64:%s\n"</literal></expr></argument>, <argument><expr><name><name>enode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>b64_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b64_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esc_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_strbuf_free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>r_graph_get_nodes (edf-&gt;flow)</argument>, <argument>iter</argument>, <argument>node</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalEsilDFGNode</name> <modifier>*</modifier></type><name>enode</name> <init>= <expr><operator>(</operator><name>RAnalEsilDFGNode</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>r_graph_get_neighbours (edf-&gt;flow, node)</argument>, <argument>ator</argument>, <argument>edon</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalEsilDFGNode</name> <modifier>*</modifier></type><name>edone</name> <init>= <expr><operator>(</operator><name>RAnalEsilDFGNode</name> <operator>*</operator><operator>)</operator><name><name>edon</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %d %d\n"</literal></expr></argument>, <argument><expr><name><name>enode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>edone</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block>

<expr_stmt><expr><call><name>r_anal_esil_dfg_free</name> <argument_list>(<argument><expr><name>edf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
