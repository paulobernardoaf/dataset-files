<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\core\cmd.c">
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
* Use RList
* Support callback for null command (why?)
* Show help of commands
- long commands not yet tested at all
- added interface to export command list into an autocompletable
argc, argv for dietline
* r_cmd must provide a nesting char table indexing for commands
- this is already partially done
- this is pretty similar to r_db
- every module can register their own commands
- commands can be listed like in a tree
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERACTIVE_MAX_REP</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cons.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cmd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__UNIX__</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SPECIAL_CHARS_REGULAR</name> <init>= <expr><literal type="string">"@;~$#|`\"'()&lt;&gt;"</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TREESITTER</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tree_sitter/api.h&gt;</cpp:file></cpp:include>
<function_decl><type><name>TSLanguage</name> <modifier>*</modifier></type><name>tree_sitter_r2cmd</name> <parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SPECIAL_CHARS_DOUBLE_QUOTED</name> <init>= <expr><literal type="string">"\""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SPECIAL_CHARS_SINGLE_QUOTED</name> <init>= <expr><literal type="string">"'"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>R_API</name> <name>void</name></type> <name>r_save_panels_layout</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>R_API</name> <name>bool</name></type> <name>r_load_panels_layout</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_name</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CMD_DESCRIPTOR</name><parameter_list>(<parameter><type><name>core</name></type></parameter>, <parameter><type><name>cmd_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ RCmdDescriptor *d = R_NEW0 (RCmdDescriptor); if (d) { d-&gt;cmd = #cmd_; d-&gt;help_msg = help_msg_##cmd_; r_list_append ((core)-&gt;cmd_descriptors, d); } }</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CMD_DESCRIPTOR_WITH_DETAIL</name><parameter_list>(<parameter><type><name>core</name></type></parameter>, <parameter><type><name>cmd_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ RCmdDescriptor *d = R_NEW0 (RCmdDescriptor); if (d) { d-&gt;cmd = #cmd_; d-&gt;help_msg = help_msg_##cmd_; d-&gt;help_detail = help_detail_##cmd_; r_list_append ((core)-&gt;cmd_descriptors, d); } }</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CMD_DESCRIPTOR_WITH_DETAIL2</name><parameter_list>(<parameter><type><name>core</name></type></parameter>, <parameter><type><name>cmd_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ RCmdDescriptor *d = R_NEW0 (RCmdDescriptor); if (d) { d-&gt;cmd = #cmd_; d-&gt;help_msg = help_msg_##cmd_; d-&gt;help_detail = help_detail_##cmd_; d-&gt;help_detail2 = help_detail2_##cmd_; r_list_append ((core)-&gt;cmd_descriptors, d); } }</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name><parameter_list>(<parameter><type><name>core</name></type></parameter>, <parameter><type><name>cmd_</name></type></parameter>, <parameter><type><name>named_cmd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ RCmdDescriptor *d = R_NEW0 (RCmdDescriptor); if (d) { d-&gt;cmd = #cmd_; d-&gt;help_msg = help_msg_##named_cmd; r_list_append ((core)-&gt;cmd_descriptors, d); } }</cpp:value></cpp:define>









<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>r_core_cmd_subst_i</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>colon</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tmpseek</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bb_cmpaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cmd_debug_reg</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_quit.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_hash.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_debug.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_log.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_flag.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_zign.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_project.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_write.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_cmp.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_eval.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_anal.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_open.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_meta.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_type.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_egg.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_info.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_macro.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_magic.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_mount.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_seek.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_search.c"</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_print.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_help.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_colon.c"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dollar</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"$alias[=cmd] [args...]"</literal></expr>, <expr><literal type="string">"Alias commands and strings (See ?$? for help on $variables)"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all defined aliases"</literal></expr>,
<expr><literal type="string">"$*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all the aliases as r2 commands in base64"</literal></expr>,
<expr><literal type="string">"$**"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"same as above, but using plain text"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"foo:=123"</literal></expr>, <expr><literal type="string">"alias for 'f foo=123'"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"foo-=4"</literal></expr>, <expr><literal type="string">"alias for 'f foo-=4'"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"foo+=4"</literal></expr>, <expr><literal type="string">"alias for 'f foo+=4'"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"alias for 's foo' (note that command aliases can override flag resolution)"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis=base64:AAA=="</literal></expr>, <expr><literal type="string">"alias this base64 encoded text to be printed when $dis is called"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis=$hello world"</literal></expr>, <expr><literal type="string">"alias this text to be printed when $dis is called"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis=-"</literal></expr>, <expr><literal type="string">"open cfg.editor to set the new value for dis alias"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis=af;pdf"</literal></expr>, <expr><literal type="string">"create command - analyze to show function"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"test=#!pipe node /tmp/test.js"</literal></expr>, <expr><literal type="string">"create command - rlangpipe script"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis="</literal></expr>, <expr><literal type="string">"undefine alias"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis"</literal></expr>, <expr><literal type="string">"execute the previously defined alias"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis?"</literal></expr>, <expr><literal type="string">"show commands aliased by $dis"</literal></expr>,
<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"dis?n"</literal></expr>, <expr><literal type="string">"show commands aliased by $dis, without a new line"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_star</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"*&lt;addr&gt;[=[0x]value]"</literal></expr>, <expr><literal type="string">"Pointer read/write data/values"</literal></expr>,
<expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"entry0=cc"</literal></expr>, <expr><literal type="string">"write trap in entrypoint"</literal></expr>,
<expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"entry0+10=0x804800"</literal></expr>, <expr><literal type="string">"write value in delta address"</literal></expr>,
<expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"entry0"</literal></expr>, <expr><literal type="string">"read byte at given address"</literal></expr>,
<expr><literal type="string">"TODO: last command should honor asm.bits"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_dot</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">".[r2cmd] | [file] | [!command] | [(macro)]"</literal></expr>, <expr><literal type="string">"#define macro or interpret r2, r_lang,\n"</literal>
<literal type="string">" cparse, d, es6, exe, go, js, lsp, pl, py, rb, sh, vala or zig file"</literal></expr>,
<expr><literal type="string">"."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"repeat last command backward"</literal></expr>,
<expr><literal type="string">"."</literal></expr>, <expr><literal type="string">"r2cmd"</literal></expr>, <expr><literal type="string">"interpret the output of the command as r2 commands"</literal></expr>,
<expr><literal type="string">".."</literal></expr>, <expr><literal type="string">" [file]"</literal></expr>, <expr><literal type="string">"run the output of the execution of a script as r2 commands"</literal></expr>,
<expr><literal type="string">"..."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"repeat last command forward (same as \\n)"</literal></expr>,
<expr><literal type="string">".:"</literal></expr>, <expr><literal type="string">"8080"</literal></expr>, <expr><literal type="string">"listen for commands on given tcp port"</literal></expr>,
<expr><literal type="string">".--"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"terminate tcp server for remote commands"</literal></expr>,
<expr><literal type="string">"."</literal></expr>, <expr><literal type="string">" foo.r2"</literal></expr>, <expr><literal type="string">"interpret script"</literal></expr>,
<expr><literal type="string">".-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"open cfg.editor and interpret tmp file"</literal></expr>,
<expr><literal type="string">".*"</literal></expr>, <expr><literal type="string">" file ..."</literal></expr>, <expr><literal type="string">"same as #!pipe open cfg.editor and interpret tmp file"</literal></expr>,
<expr><literal type="string">".!"</literal></expr>, <expr><literal type="string">"rabin -ri $FILE"</literal></expr>, <expr><literal type="string">"interpret output of command"</literal></expr>,
<expr><literal type="string">"."</literal></expr>, <expr><literal type="string">"(foo 1 2 3)"</literal></expr>, <expr><literal type="string">"run macro 'foo' with args 1, 2, 3"</literal></expr>,
<expr><literal type="string">"./"</literal></expr>, <expr><literal type="string">" ELF"</literal></expr>, <expr><literal type="string">"interpret output of command /m ELF as r. commands"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_equal</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">" =[:!+-=ghH] [...]"</literal></expr>, <expr><literal type="string">" #connect with other instances of r2"</literal></expr>,
<expr><literal type="string">"\nremote commands:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all open connections"</literal></expr>,
<expr><literal type="string">"=&lt;"</literal></expr>, <expr><literal type="string">"[fd] cmd"</literal></expr>, <expr><literal type="string">"send output of local command to remote fd"</literal></expr>, 
<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"[fd] cmd"</literal></expr>, <expr><literal type="string">"exec cmd at remote 'fd' (last open is default one)"</literal></expr>,
<expr><literal type="string">"=!"</literal></expr>, <expr><literal type="string">" cmd"</literal></expr>, <expr><literal type="string">"run command via r_io_system"</literal></expr>,
<expr><literal type="string">"=+"</literal></expr>, <expr><literal type="string">" [proto://]host:port"</literal></expr>, <expr><literal type="string">"connect to remote host:port (*rap://, raps://, tcp://, udp://, http://)"</literal></expr>,
<expr><literal type="string">"=-"</literal></expr>, <expr><literal type="string">"[fd]"</literal></expr>, <expr><literal type="string">"remove all hosts or host 'fd'"</literal></expr>,
<expr><literal type="string">"=="</literal></expr>, <expr><literal type="string">"[fd]"</literal></expr>, <expr><literal type="string">"open remote session with host 'fd', 'q' to quit"</literal></expr>,
<expr><literal type="string">"=!="</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"disable remote cmd mode"</literal></expr>,
<expr><literal type="string">"!=!"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"enable remote cmd mode"</literal></expr>,
<expr><literal type="string">"\nservers:"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">".:"</literal></expr>, <expr><literal type="string">"9000"</literal></expr>, <expr><literal type="string">"start the tcp server (echo x|nc ::1 9090 or curl ::1:9090/cmd/x)"</literal></expr>,
<expr><literal type="string">"=:"</literal></expr>, <expr><literal type="string">"port"</literal></expr>, <expr><literal type="string">"start the rap server (o rap://9999)"</literal></expr>,
<expr><literal type="string">"=g"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"start the gdbserver"</literal></expr>,
<expr><literal type="string">"=h"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"start the http webserver"</literal></expr>,
<expr><literal type="string">"=H"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"start the http webserver (and launch the web browser)"</literal></expr>,
<expr><literal type="string">"\nother:"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"=&amp;"</literal></expr>, <expr><literal type="string">":port"</literal></expr>, <expr><literal type="string">"start rap server in background (same as '&amp;_=h')"</literal></expr>,
<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">":host:port cmd"</literal></expr>, <expr><literal type="string">"run 'cmd' command on remote server"</literal></expr>,
<expr><literal type="string">"\nexamples:"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"=+"</literal></expr>, <expr><literal type="string">"tcp://localhost:9090/"</literal></expr>, <expr><literal type="string">"connect to: r2 -c.:9090 ./bin"</literal></expr>,

<expr><literal type="string">"=+"</literal></expr>, <expr><literal type="string">"rap://localhost:9090/"</literal></expr>, <expr><literal type="string">"connect to: r2 rap://:9090"</literal></expr>,
<expr><literal type="string">"=+"</literal></expr>, <expr><literal type="string">"http://localhost:9090/cmd/"</literal></expr>, <expr><literal type="string">"connect to: r2 -c'=h 9090' bin"</literal></expr>,
<expr><literal type="string">"o "</literal></expr>, <expr><literal type="string">"rap://:9090/"</literal></expr>, <expr><literal type="string">"start the rap server on tcp port 9090"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static const char *help_msg_equalh[] = {
"Usage:", "=h[---*&amp;] [port]", " #manage http connections",
"=h", " port", "listen for http connections (r2 -qc=H /bin/ls)",
"=h-", "", "stop background webserver",
"=h--", "", "stop foreground webserver",
"=h*", "", "restart current webserver",
"=h&amp;", " port", "start http server in background",
NULL
};
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_equalh</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">" =[hH] [...]"</literal></expr>, <expr><literal type="string">" #http server"</literal></expr>,
<expr><literal type="string">"http server:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"=h"</literal></expr>, <expr><literal type="string">" port"</literal></expr>, <expr><literal type="string">"listen for http connections (r2 -qc=H /bin/ls)"</literal></expr>,
<expr><literal type="string">"=h-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"stop background webserver"</literal></expr>,
<expr><literal type="string">"=h--"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"stop foreground webserver"</literal></expr>,
<expr><literal type="string">"=h*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"restart current webserver"</literal></expr>,
<expr><literal type="string">"=h&amp;"</literal></expr>, <expr><literal type="string">" port"</literal></expr>, <expr><literal type="string">"start http server in background"</literal></expr>,
<expr><literal type="string">"=H"</literal></expr>, <expr><literal type="string">" port"</literal></expr>, <expr><literal type="string">"launch browser and listen for http"</literal></expr>,
<expr><literal type="string">"=H&amp;"</literal></expr>, <expr><literal type="string">" port"</literal></expr>, <expr><literal type="string">"launch browser and listen for http in background"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_equalg</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">" =[g] [...]"</literal></expr>, <expr><literal type="string">" #gdb server"</literal></expr>,
<expr><literal type="string">"gdbserver:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"=g"</literal></expr>, <expr><literal type="string">" port file [args]"</literal></expr>, <expr><literal type="string">"listen on 'port' debugging 'file' using gdbserver"</literal></expr>,
<expr><literal type="string">"=g!"</literal></expr>, <expr><literal type="string">" port file [args]"</literal></expr>, <expr><literal type="string">"same as above, but debug protocol messages (like gdbserver --remote-debug)"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_b</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"b[f] [arg]\n"</literal></expr>, <expr><literal type="string">"Get/Set block size"</literal></expr>,
<expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">" 33"</literal></expr>, <expr><literal type="string">"set block size to 33"</literal></expr>,
<expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">" eip+4"</literal></expr>, <expr><literal type="string">"numeric argument can be an expression"</literal></expr>,
<expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display current block size"</literal></expr>,
<expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">"+3"</literal></expr>, <expr><literal type="string">"increase blocksize by 3"</literal></expr>,
<expr><literal type="string">"b"</literal></expr>, <expr><literal type="string">"-16"</literal></expr>, <expr><literal type="string">"decrease blocksize by 16"</literal></expr>,
<expr><literal type="string">"b*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display current block size in r2 command"</literal></expr>,
<expr><literal type="string">"bf"</literal></expr>, <expr><literal type="string">" foo"</literal></expr>, <expr><literal type="string">"set block size to flag size"</literal></expr>,
<expr><literal type="string">"bj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display block size information in JSON"</literal></expr>,
<expr><literal type="string">"bm"</literal></expr>, <expr><literal type="string">" 1M"</literal></expr>, <expr><literal type="string">"set max block size"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_k</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"k[s] [key[=value]]"</literal></expr>, <expr><literal type="string">"Sdb Query"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">" anal/**"</literal></expr>, <expr><literal type="string">"list namespaces under anal"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">" anal/meta/*"</literal></expr>, <expr><literal type="string">"list kv from anal &gt; meta namespaces"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">" anal/meta/meta.0x80404"</literal></expr>, <expr><literal type="string">"get value for meta.0x80404 key"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">" foo"</literal></expr>, <expr><literal type="string">"show value"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">" foo=bar"</literal></expr>, <expr><literal type="string">"set value"</literal></expr>,
<expr><literal type="string">"k"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list keys"</literal></expr>,
<expr><literal type="string">"kd"</literal></expr>, <expr><literal type="string">" [file.sdb] [ns]"</literal></expr>, <expr><literal type="string">"dump namespace to disk"</literal></expr>,
<expr><literal type="string">"kj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all namespaces and sdb databases in JSON format"</literal></expr>,
<expr><literal type="string">"ko"</literal></expr>, <expr><literal type="string">" [file.sdb] [ns]"</literal></expr>, <expr><literal type="string">"open file into namespace"</literal></expr>,
<expr><literal type="string">"ks"</literal></expr>, <expr><literal type="string">" [ns]"</literal></expr>, <expr><literal type="string">"enter the sdb query shell"</literal></expr>,


<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_r</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"r[+-][ size]"</literal></expr>, <expr><literal type="string">"Resize file"</literal></expr>,
<expr><literal type="string">"r"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display file size"</literal></expr>,
<expr><literal type="string">"r"</literal></expr>, <expr><literal type="string">" size"</literal></expr>, <expr><literal type="string">"expand or truncate file to given size"</literal></expr>,
<expr><literal type="string">"r-"</literal></expr>, <expr><literal type="string">"num"</literal></expr>, <expr><literal type="string">"remove num bytes, move following data down"</literal></expr>,
<expr><literal type="string">"r+"</literal></expr>, <expr><literal type="string">"num"</literal></expr>, <expr><literal type="string">"insert num bytes, move following data up"</literal></expr>,
<expr><literal type="string">"rb"</literal></expr>, <expr><literal type="string">"oldbase @ newbase"</literal></expr>, <expr><literal type="string">"rebase all flags, bin.info, breakpoints and analysis"</literal></expr>,
<expr><literal type="string">"rm"</literal></expr> ,<expr><literal type="string">" [file]"</literal></expr>, <expr><literal type="string">"remove file"</literal></expr>,
<expr><literal type="string">"rh"</literal></expr> ,<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show size in human format"</literal></expr>,
<expr><literal type="string">"r2"</literal></expr> ,<expr><literal type="string">" [file]"</literal></expr>, <expr><literal type="string">"launch r2 (same for rax2, rasm2, ...)"</literal></expr>,
<expr><literal type="string">"reset"</literal></expr> ,<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"reset console settings (clear --hard)"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_u</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"u"</literal></expr>, <expr><literal type="string">"uname or undo write/seek"</literal></expr>,
<expr><literal type="string">"u"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show system uname"</literal></expr>,
<expr><literal type="string">"uw"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"alias for wc (requires: e io.cache=true)"</literal></expr>,
<expr><literal type="string">"us"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"alias for s- (seek history)"</literal></expr>,
<expr><literal type="string">"uc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"undo core commands (uc?, ucl, uc*, ..)"</literal></expr>,
<expr><literal type="string">"uniq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"filter rows to avoid duplicates"</literal></expr>,
<expr><literal type="string">"uname"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"uname - show system information"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_y</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"y[ptxy] [len] [[@]addr]"</literal></expr>, <expr><literal type="string">" #See wd? for memcpy, same as 'yf'."</literal></expr>,
<expr><literal type="string">"y!"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"open cfg.editor to edit the clipboard"</literal></expr>,
<expr><literal type="string">"y"</literal></expr>, <expr><literal type="string">" 16 0x200"</literal></expr>, <expr><literal type="string">"copy 16 bytes into clipboard from 0x200"</literal></expr>,
<expr><literal type="string">"y"</literal></expr>, <expr><literal type="string">" 16 @ 0x200"</literal></expr>, <expr><literal type="string">"copy 16 bytes into clipboard from 0x200"</literal></expr>,
<expr><literal type="string">"y"</literal></expr>, <expr><literal type="string">" 16"</literal></expr>, <expr><literal type="string">"copy 16 bytes into clipboard"</literal></expr>,
<expr><literal type="string">"y"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show yank buffer information (srcoff len bytes)"</literal></expr>,
<expr><literal type="string">"y*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print in r2 commands what's been yanked"</literal></expr>,
<expr><literal type="string">"yf"</literal></expr>, <expr><literal type="string">" 64 0x200"</literal></expr>, <expr><literal type="string">"copy file 64 bytes from 0x200 from file"</literal></expr>,
<expr><literal type="string">"yfa"</literal></expr>, <expr><literal type="string">" file copy"</literal></expr>, <expr><literal type="string">"copy all bytes from file (opens w/ io)"</literal></expr>,
<expr><literal type="string">"yfx"</literal></expr>, <expr><literal type="string">" 10203040"</literal></expr>, <expr><literal type="string">"yank from hexpairs (same as ywx)"</literal></expr>,
<expr><literal type="string">"yj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print in JSON commands what's been yanked"</literal></expr>,
<expr><literal type="string">"yp"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print contents of clipboard"</literal></expr>,
<expr><literal type="string">"yq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print contents of clipboard in hexpairs"</literal></expr>,
<expr><literal type="string">"ys"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print contents of clipboard as string"</literal></expr>,
<expr><literal type="string">"yt"</literal></expr>, <expr><literal type="string">" 64 0x200"</literal></expr>, <expr><literal type="string">"copy 64 bytes from current seek to 0x200"</literal></expr>,
<expr><literal type="string">"ytf"</literal></expr>, <expr><literal type="string">" file"</literal></expr>, <expr><literal type="string">"dump the clipboard to given file"</literal></expr>,
<expr><literal type="string">"yw"</literal></expr>, <expr><literal type="string">" hello world"</literal></expr>, <expr><literal type="string">"yank from string"</literal></expr>,
<expr><literal type="string">"ywx"</literal></expr>, <expr><literal type="string">" 10203040"</literal></expr>, <expr><literal type="string">"yank from hexpairs (same as yfx)"</literal></expr>,
<expr><literal type="string">"yx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"print contents of clipboard in hexadecimal"</literal></expr>,
<expr><literal type="string">"yy"</literal></expr>, <expr><literal type="string">" 0x3344"</literal></expr>, <expr><literal type="string">"paste clipboard"</literal></expr>,
<expr><literal type="string">"yz"</literal></expr>, <expr><literal type="string">" [len]"</literal></expr>, <expr><literal type="string">"copy nul-terminated string (up to blocksize) into clipboard"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_triple_exclamation</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"!!![-*][cmd] [arg|$type...]"</literal></expr>, <expr><literal type="string">" #user-defined autocompletion for commands"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all autocompletions"</literal></expr>,
<expr><literal type="string">"!!!?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">"-*"</literal></expr>, <expr><literal type="string">"remove all user-defined autocompletions"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">"-\\*"</literal></expr>, <expr><literal type="string">"remove autocompletions matching this glob expression"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">"-foo"</literal></expr>, <expr><literal type="string">"remove autocompletion named 'foo'"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"add 'foo' for autocompletion"</literal></expr>,
<expr><literal type="string">"!!!"</literal></expr>, <expr><literal type="string">"bar $flag"</literal></expr>, <expr><literal type="string">"add 'bar' for autocompletion with $flag as argument"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_vertical_bar</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"[cmd] | [program|H|T|.|]"</literal></expr>, <expr><literal type="string">""</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] |?"</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] |"</literal></expr>, <expr><literal type="string">"disable scr.html and scr.color"</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] |H"</literal></expr>, <expr><literal type="string">"enable scr.html, respect scr.color"</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] |T"</literal></expr>, <expr><literal type="string">"use scr.tts to speak out the stdout"</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] | [program]"</literal></expr>, <expr><literal type="string">"pipe output of command to program"</literal></expr>,
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"[cmd] |."</literal></expr>, <expr><literal type="string">"alias for .[cmd]"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_cmd_help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_cmd_help</name> <argument_list>(<argument><expr><name>help</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>R_PRINT_FLAGS_COLOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>duplicate_flag_t</name> <block>{
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>duplicate_flag</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>duplicate_flag_t</name></name> <modifier>*</modifier></type><name>user</name> <init>= <expr><operator>(</operator>struct <name>duplicate_flag_t</name> <operator>*</operator><operator>)</operator><name>u</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_glob</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>word</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>cloned_item</name> <init>= <expr><call><name>r_flag_item_clone</name> <argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cloned_item</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>ret</name></name></expr></argument>, <argument><expr><name>cloned_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>recursive_help_go</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>detail</name></decl></parameter>, <parameter><decl><type><name>RCmdDescriptor</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>help_msg</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>help_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>detail</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>help_detail</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>help_detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>detail</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>help_detail2</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>help_detail2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">32</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>sub</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>sub</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>recursive_help_go</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>sub</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>recursive_help</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>detail</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCmdDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>root_cmd_descriptor</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><name>cmd_prefix</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;</operator> <call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>sub</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>desc</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>sub</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>recursive_help_go</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>lastcmd_repeat</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>next</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>||</operator> <name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>cmd_depth</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case> 
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"sr PC;pd 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case> 
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>, <argument><expr><literal type="string">"pd"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so %s"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so `pi~?`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&gt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>res</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_core_cmd_nullcallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>breaked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>breaked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>cmdrepeat</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_uname</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RSysInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>r_sys_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>si</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>sysname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"-r"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>release</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sys_info_free</name> <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_uniq</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: uniq #uniq to list unique strings in file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"md %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_syscmd_uniq</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_head</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_input</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lines</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>_input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>count</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: head [file] #to list first n lines in file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"md %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_syscmd_head</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_undo</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>help_msg_u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'c'</literal></expr>:</case> 
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rcmd</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rcmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rcmd</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RCoreUndo</name> <modifier>*</modifier></type><name>undo</name> <init>= <expr><call><name>r_core_undo_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>rcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_undo_push</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>undo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: uc [cmd] [revert-cmd]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: uc [cmd],[revert-cmd]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" uc. - list all reverts in current\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" uc* - list all core undos\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" uc - list all core undos\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" uc- - undo last action\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>RCoreUndoCondition</name></type> <name>cond</name> <init>= <expr><block>{
<expr><operator>.</operator><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>,
<expr><operator>.</operator><name>minstamp</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>glob</name> <operator>=</operator> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_undo_print</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_undo_print</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_undo_pop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_core_undo_print</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'s'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"s-%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'w'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"wc%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'n'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmd_uname</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cmd_uniq</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__UNIX__</name></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>un</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>uname</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>un</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %s %s\n"</literal></expr></argument>, <argument><expr><name><name>un</name><operator>.</operator><name>sysname</name></name></expr></argument>,
<argument><expr><name><name>un</name><operator>.</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>un</name><operator>.</operator><name>release</name></name></expr></argument>, <argument><expr><name><name>un</name><operator>.</operator><name>machine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:elif>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"windows\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"unknown\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_alias</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dollar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nonl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>defmode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>def</name> <operator>&amp;&amp;</operator> <name>def</name> <operator>&gt;</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>def</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>prev</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<expr_stmt><expr><name>defmode</name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><name>defmode</name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name>defmode</name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>def</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>def</name> <operator>&lt;</operator> <name>q</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>def</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>q</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>def</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>defmode</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>defmode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>at</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>at</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>def</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>def</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>def</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>def</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name> <operator>||</operator> <operator>(</operator><name>q</name> <operator>&amp;&amp;</operator> <name>q</name> <operator>&gt;</operator> <name>def</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>def</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>def</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>r_cons_editor</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desc</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>desc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nonl</name> <operator>==</operator> <name>desc</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"unknown key '%s'\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>r_cmd_alias_keys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>r_base64_encode_dyn</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s=%s\n"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s=base64:%s\n"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>r_cmd_alias_keys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>v</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>v</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>at</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown alias '%s'\n"</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getArg</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>def</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<return>return <expr><name>ch</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>def</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>aliascmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: =$[-][remotecmd] #remote command alias\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" =$dr #makes 'dr' alias for =!dr\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" =$-dr #unset 'dr' alias\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_rap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_rtr_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: list connections in json\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmdremote</name></name> <operator>=</operator> <ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmdremote</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_io_system</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'$'</literal></expr>:</case> 

<expr_stmt><expr><call><name>aliascmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_rtr_add</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_rtr_remove</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_rtr_pushout</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'='</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_rtr_session</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'g'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_equalg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_rtr_gdb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>getArg</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'g'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_equalh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_rtr_http</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>getArg</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_equalh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_rtr_http</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>getArg</name> <argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_core_rtr_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_rap_run</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_io_system</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_yank</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case> 
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>yank_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'y'</literal></expr>:</case> 
<while>while <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_yank_paste</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_hexdump</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'z'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_string</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case> 
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_yank_set</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_yank_set</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ywx [hexpairs]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ywx [hexpairs]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_cat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_cat_string</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>tmpsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_buf_data</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>yank_buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_file_dump</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmpsz</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot dump to '%s'\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_yank_to</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: wt[f] [arg] ..\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> 
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_file_ex</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_hexpair</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_file_all</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: yf[xa] [arg]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"yf [file] - copy blocksize from file into the clipboard\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"yfa [path] - yank the whole file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"yfx [hexpair] - yank from hexpair string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"y*"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sig</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>sig</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"wx 10203040"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"y%s"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case> 
<case>case <expr><literal type="char">'j'</literal></expr>:</case> 
<case>case <expr><literal type="char">'q'</literal></expr>:</case> 
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_yank_dump</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lang_run_file</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RLang</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_sysenv_begin</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_lang_run_file</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>langFromHashbang</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>r_sandbox_open</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>firstLine</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_sandbox_read</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>firstLine</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>firstLine</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>firstLine</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>firstLine</name></expr></argument>, <argument><expr><literal type="string">"#!/"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>firstLine</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>firstLine</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>firstLine</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sandbox_close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>nl</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_sandbox_close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_core_run_script</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RLangPlugin</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;scriptstack</argument>, <argument>iter</argument>, <argument>name</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING: ignored nested source: %s\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>scriptstack</name></name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_lines</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_endswith</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".html"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>httpSandbox</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.sandbox"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>httpIndex</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.sandbox"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>absfile</name> <init>= <expr><call><name>r_file_abspath</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.index"</literal></expr></argument>, <argument><expr><name>absfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>absfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"=H"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.sandbox"</literal></expr></argument>, <argument><expr><name>httpSandbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"http.index"</literal></expr></argument>, <argument><expr><name>httpIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>httpIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_endswith</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".c"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"#!c %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_file_is_c</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dir.types"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_file</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_query_lines</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>out</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>r_lang_get_by_extension</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cmdstr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_str_newf (x" %s", file);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cmdstr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_str_newf (x" '%s'", file);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>r_str_lchr</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"js"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"node"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"exe"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"wine"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"zig"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"zig run"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"dmd -run"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"lsp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"newlisp -n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"go"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"go run"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"es6"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"babel-node"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"ruby"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"vala"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"vala"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"sh"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shell</name> <init>= <expr><call><name>r_sys_getenv</name> <argument_list>(<argument><expr><literal type="string">"SHELL"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shell</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>shell</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"sh"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>shell</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s '%s'"</literal></expr></argument>, <argument><expr><name>shell</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"pl"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"perl"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"py"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>cmdstr</name> <argument_list>(<argument><expr><literal type="string">"python"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>abspath</name> <init>= <expr><call><name>r_file_path</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lang</name> <init>= <expr><call><name>langFromHashbang</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lang</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_lang_use</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><literal type="string">"pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s '%s'"</literal></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lang_run_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>lang</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>abspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_file</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><call><name>r_list_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>scriptstack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_ls</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: l[es] #ls to list files, le[ss] to less a file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"cat %s~.."</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: less [file]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"md %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_syscmd_ls</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_join</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg1</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg1</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><name>end</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg2</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<goto>goto <name>beach</name>;</goto>
<default>default:</default> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg2</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_syscmd_join</name> <argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: join [file1] [file2] #join the contents of the two files\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_stdin</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: '-' '.-' '. -' do the same\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_core_run_script</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_interpret</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eol</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rbuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>filter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>port</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<expr_stmt><expr><call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">':'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eol</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>host</name> <operator>=</operator> <name>input</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>port</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>host</name> <operator>=</operator> <literal type="string">"localhost"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>port</name> <operator>=</operator> <name>input</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>r_core_rtr_cmds_query</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rbuf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_rtr_cmds</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'.'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_core_cmd_str_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: .. ([file])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>R_STR_ISNOTEMPTY</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_run_script</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: '-' '.-' '. -' do the same\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_run_script</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>script_file</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>script_file</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>script_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_run_script</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>script_file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find script '%s'\n"</literal></expr></argument>, <argument><expr><name>script_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_command</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'('</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_cmd_macro_call</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_dot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>&lt;=</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|ERROR| No .[0..9] to avoid infinite loops\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>inp</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filter</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><literal type="char">'~'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>filter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmp_html</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>is_html</name> <operator>=</operator> <name>tmp_html</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>filter</name> <operator>=</operator> <literal type="char">'~'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>eol</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eol</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eol</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>r_str_append</name> <argument_list>(<argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eol</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>callback_foreach_kv</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s=%s\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_line_hist_sdb_up</name><parameter_list>(<parameter><decl><type><name>RLine</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name></name> <operator>||</operator> <operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>R_LINE_BUFSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_line_hist_sdb_down</name><parameter_list>(<parameter><decl><type><name>RLine</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name></name> <operator>||</operator> <operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>p</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>R_LINE_BUFSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_kuery</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="string">"[sdb]&gt; "</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_pos</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur_cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_pos</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp_cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp_storage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"anal/**"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"No Output from sdb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"anal\":{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cur_pos</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur_pos</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cur_cmd</name> <operator>=</operator> <call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>cur_pos</name> <operator>-</operator> <name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\n\n\"%s\" : ["</literal></expr></argument>, <argument><expr><name>cur_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next_cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"anal/%s/*"</literal></expr></argument>, <argument><expr><name>cur_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_storage</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>next_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_storage</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"\nEMPTY\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"],\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>+=</operator> <name>cur_pos</name> <operator>-</operator> <name>out</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>temp_storage</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp_pos</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>temp_storage</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_pos</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>temp_cmd</name> <operator>=</operator> <call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>temp_storage</name></expr></argument>, <argument><expr><name>temp_pos</name> <operator>-</operator> <name>temp_storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"%s\","</literal></expr></argument>, <argument><expr><name>temp_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_storage</name> <operator>+=</operator> <name>temp_pos</name> <operator>-</operator> <name>temp_storage</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"],\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>+=</operator> <name>cur_pos</name> <operator>-</operator> <name>out</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>next_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>temp_storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>


<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>callback_foreach_kv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>http_up</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>o</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><name>n</name></expr>;</condition> <incr><expr><name>o</name> <operator>=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>n</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RLine</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist</name></name></expr></argument>, <argument><expr><call><name>r_str_new</name> <argument_list>(<argument><expr><literal type="string">"\0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>sdb_hist</name> <init>= <expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_line_set_hist_callback</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_sdb_up</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_sdb_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_line_set_prompt</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_fgets</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sdb_hist</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name>sdb_hist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name>sdb_hist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>sdb_hist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_insert</name> <argument_list>(<argument><expr><name>sdb_hist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>line</name><operator>-&gt;</operator><name>sdbshell_hist_iter</name></name> <operator>=</operator> <name><name>sdb_hist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_line_set_hist_callback</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_cmd_up</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_cmd_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ns</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ns</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_file_exists</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sdb_ns_path</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>newdb</name> <init>= <expr><call><name>sdb_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newdb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_drain</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>newdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open sdb '%s'\n"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find sdb '%s'\n"</literal></expr></argument>, <argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing sdb namespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ko [file] [namespace]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ns</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ns</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sdb_ns_path</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_file</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_sync</name> <argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find sdb '%s'\n"</literal></expr></argument>, <argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing sdb namespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: kd [file] [namespace]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>inp</name> <index>[<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>sp</name> <operator>-</operator> <name>input</name><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>inp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_bsize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> 
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize_max</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%x\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case> 
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"bf: cannot find flag named '%s'\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: bf [flagname]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"blocksize\":%d,\"blocksize_limit\":%d}\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"b 0x%x\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%x\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__runMain</name><parameter_list>(<parameter><decl><type><name>RMainCallback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_str_argv</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>cb</name> <argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>cmd_r2cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"r%s"</literal></expr></argument>, <argument><expr><name>_input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"rax2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>__runMain</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>r_main_rax2</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"r2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"radare2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"rasm2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"rabin2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"ragg2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"r2pm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"radiff2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>__runMain</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>r_main_radiff2</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>r2cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"rax2"</literal></expr>, <expr><literal type="string">"r2pm"</literal></expr>, <expr><literal type="string">"rasm2"</literal></expr>, <expr><literal type="string">"rabin2"</literal></expr>, <expr><literal type="string">"rahash2"</literal></expr>, <expr><literal type="string">"rafind2"</literal></expr>, <expr><literal type="string">"rarun2"</literal></expr>, <expr><literal type="string">"ragg2"</literal></expr>, <expr><literal type="string">"radare2"</literal></expr>, <expr><literal type="string">"r2"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>r2cmds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>r2cmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_rebase</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: rb oldbase @ newbase\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>r_debug_bp_rebase</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_bin_set_baddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_flag_move</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".is*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".iM*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ii*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".iz*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_resize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>newsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st64</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>grow</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cmd_r2cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>oldsize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>file</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>r_io_fd_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"adare2"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__runMain</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>r_main_radare2</name></name></expr></argument>, <argument><expr><name>input</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> 
<return>return <expr><call><name>cmd_rebase</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> 


<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"radare%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>file</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: rm [file] #removes a file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64d</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>humansz</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_num_units</name> <argument_list>(<argument><expr><name>humansz</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>humansz</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>humansz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'+'</literal></expr>:</case> 
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>st64</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>oldsize</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case> 
<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><call><name>write</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Color_RESET_TERMINAL</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>Color_RESET_TERMINAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<default>default:</default>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name>grow</name> <operator>=</operator> <operator>(</operator><name>newsize</name> <operator>&gt;</operator> <name>oldsize</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>grow</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_io_resize</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_io_resize: cannot resize\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name>newsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_shift</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>grow</name></expr>?</condition><then><expr><name>newsize</name></expr></then><else>:<expr><name>oldsize</name></expr></else></ternary></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>grow</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_io_resize</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_io_resize: cannot resize\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name><operator>+</operator><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>||</operator> <name>oldsize</name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_panels</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>vmode</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: v[*i]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"v.test #save current layout with name test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"v test #load saved layout with name test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"vi ... #launch 'cfg.editor'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>panels</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_load_panels_layout</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.layout"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_save_panels_layout</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.layout"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open file (%s)\n"</literal></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_visual_panels_root</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>panels_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_visual</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>http_up</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_core_visual</name> <argument_list>(<argument><expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_pipein</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_str_unescape</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_readpush</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_tasks</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case> 
<case>case <expr><literal type="char">'j'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_task_list</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>*</operator><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_task_break</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_task_join</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>tasks</name><operator>.</operator><name>current_task</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>tid</name></expr> ?</condition><then> <expr><name>tid</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'='</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tid</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RCoreTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>r_core_task_get_incref</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>task</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>res</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>res</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_task_decref</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find task\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_task_del_all_done</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_task_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<default>default:</default>
<expr_stmt><expr><call><name>helpCmdTasks</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case> 
<case>case <expr><literal type="char">'_'</literal></expr>:</case> 
<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RCoreTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>r_core_task_new</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>transient</name></name> <operator>=</operator> <name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_enqueue</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_pointer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eq</name></decl>;</decl_stmt>
<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>input</name> <operator>||</operator> <operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eq</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eq</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>eq</name></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wv %s@%s"</literal></expr></argument>, <argument><expr><name>eq</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wx %s@%s"</literal></expr></argument>, <argument><expr><name>eq</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"?v [%s]"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_env</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>cmd_help_percent</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"env %s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <name>autocomplete_flag_map_t</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block> <decl><name><name>autocomplete_flags</name> <index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"$dflt"</literal></expr>, <expr><literal type="string">"default autocomplete flag"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_DFLT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$flag"</literal></expr>, <expr><literal type="string">"shows known flag hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_FLAG</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$flsp"</literal></expr>, <expr><literal type="string">"shows known flag-spaces hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_FLSP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$zign"</literal></expr>, <expr><literal type="string">"shows known zignatures hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_ZIGN</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$eval"</literal></expr>, <expr><literal type="string">"shows known evals hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_EVAL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$prjt"</literal></expr>, <expr><literal type="string">"shows known projects hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_PRJT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$mins"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>R_CORE_AUTOCMPLT_MINS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$brkp"</literal></expr>, <expr><literal type="string">"shows known breakpoints hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_BRKP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$macro"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>R_CORE_AUTOCMPLT_MACR</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$file"</literal></expr>, <expr><literal type="string">"hints file paths"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_FILE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$thme"</literal></expr>, <expr><literal type="string">"shows known themes hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_THME</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$optn"</literal></expr>, <expr><literal type="string">"allows the selection for multiple options"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_OPTN</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"$ms"</literal></expr>, <expr><literal type="string">"shows mount hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_MS</name></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"$sdb"</literal></expr>, <expr><literal type="string">"shows sdb hints"</literal></expr>, <expr><name>R_CORE_AUTOCMPLT_SDB</name></expr>}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>print_dict</name><parameter_list>(<parameter><decl><type><name>RCoreAutocomplete</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sub</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>n_subcmds</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RCoreAutocomplete</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>locked</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>R_CORE_AUTOCMPLT_END</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>autocomplete_flags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>autocomplete_flags</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[%3d] %s: '%s'\n"</literal></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_dict</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sub</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>autocomplete_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>strflag</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_CORE_AUTOCMPLT_END</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>strflag</name></expr></argument>, <argument><expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid flag '%s'\n"</literal></expr></argument>, <argument><expr><name>strflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_CORE_AUTOCMPLT_END</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_autocomplete</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCoreAutocomplete</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>autocomplete</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>arg</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_dict</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>autocomplete</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_triple_exclamation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"|Types:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_CORE_AUTOCMPLT_END</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"| %s %s\n"</literal></expr></argument>,
<argument><expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
<argument><expr><name><name>autocomplete_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Use !!!-* or !!!-&lt;cmd&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_autocomplete_remove</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>b</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>end</name> <init>= <expr><call><name>r_str_trim_head_wp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>end</name> <operator>-</operator> <name>input</name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Exceeded the max arg length (255).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>input</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><index>[<expr><name>end</name> <operator>-</operator> <name>input</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RCoreAutocomplete</name><modifier>*</modifier></type> <name>a</name> <init>= <expr><call><name>r_core_autocomplete_find</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_CORE_AUTOCMPLT_DFLT</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>b</name> <operator>=</operator> <call><name>r_core_autocomplete_add</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>R_CORE_AUTOCMPLT_DFLT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ENOMEM\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_CORE_AUTOCMPLT_DFLT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot add autocomplete to '%s'. type not $dflt\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>input</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>input</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>autocomplete_type</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>R_CORE_AUTOCMPLT_END</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>locked</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>n_subcmds</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>locked</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>n_subcmds</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Changing type of '%s' is forbidden.\n"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_autocomplete_add</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>R_CORE_AUTOCMPLT_DFLT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ENOMEM\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>input</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>input</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>a</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid usage of !!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_last</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><call><name>r_cons_last</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: _ print last output\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_system</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'-'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_line_hist_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_line_hist_save</name> <argument_list>(<argument><expr><name>R2_HOME_HISTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_line_hist_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'='</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: !=[!] - enable/disable remote commands\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmdremote</name></name> <operator>=</operator> <ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmdremote</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>cmd_autocomplete</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cmd_help_exclamation</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"\"#!pipe %s\""</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>olen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_core_sysenv_begin</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>bed</name> <init>= <expr><call><name>r_cons_sleep_begin</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_sys_cmd_str_full</name> <argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_sleep_end</name> <argument_list>(<argument><expr><name>bed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_sysenv_end</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_memcat</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"History saved to "</literal><name>R2_HOME_HISTORY</name><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_line_hist_save</name> <argument_list>(<argument><expr><name>R2_HOME_HISTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_line_hist_list</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>cmd_help_exclamation</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="string">"\\ "</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"\\ "</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"\"#!pipe %s\""</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>||</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_line_hist_get</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_core_sysenv_begin</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>bed</name> <init>= <expr><call><name>r_cons_sleep_begin</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_sys_cmd</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_sleep_end</name> <argument_list>(<argument><expr><name>bed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_sysenv_end</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error setting up system environment\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unescape_special_chars</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>special_chars</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>R_NEWS</name> <argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator> <operator>!</operator><call><name>strchr</name> <argument_list>(<argument><expr><name>special_chars</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tchar.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__CLOSE_DUPPED_PIPES</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>close (1); close (fd_out); fd_out = -1;</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <name>void</name></type> <name>r_w32_cmd_pipe</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>radare_cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shell_cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name><name>pipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd_out</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>cons_out</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>_shell_cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LPTSTR</name></type> <name>_shell_cmd_</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCHAR</name> <modifier>*</modifier></type><name>systemdir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetConsoleMode</name> <argument_list>(<argument><expr><call><name>GetStdHandle</name> <argument_list>(<argument><expr><name>STD_OUTPUT_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>lpSecurityDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreatePipe</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"r_w32_cmd_pipe/CreatePipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetHandleInformation</name> <argument_list>(<argument><expr><name><name>pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>HANDLE_FLAG_INHERIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"r_w32_cmd_pipe/SetHandleInformation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdError</name></name> <operator>=</operator> <call><name>GetStdHandle</name> <argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdOutput</name></name> <operator>=</operator> <call><name>GetStdHandle</name> <argument_list>(<argument><expr><name>STD_OUTPUT_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdInput</name></name> <operator>=</operator> <name><name>pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>.</operator><name>dwFlags</name></name> <operator>|=</operator> <name>STARTF_USESTDHANDLES</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>_shell_cmd</name> <operator>=</operator> <name>shell_cmd</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>_shell_cmd</name> <operator>&amp;&amp;</operator> <call><name>isspace</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>_shell_cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>_shell_cmd</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"/Q /c \"%s\""</literal></expr></argument>, <argument><expr><name>_shell_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>_shell_cmd</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_shell_cmd_</name> <operator>=</operator> <call><name>r_sys_conv_utf8_to_win</name> <argument_list>(<argument><expr><name>_shell_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>_shell_cmd_</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>systemdir</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>MAX_PATH</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>TCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>systemdir</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>GetSystemDirectory</name> <argument_list>(<argument><expr><name>systemdir</name></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"r_w32_cmd_pipe/systemdir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>_tcscat_s</name> <argument_list>(<argument><expr><name>systemdir</name></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>, <argument><expr><call><name>TEXT</name><argument_list>(<argument><expr><literal type="string">"\\cmd.exe"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateProcess</name> <argument_list>(<argument><expr><name>systemdir</name></expr></argument>, <argument><expr><name>_shell_cmd_</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_perror</name> <argument_list>(<argument><expr><literal type="string">"r_w32_cmd_pipe/CreateProcess"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fd_out</name> <operator>=</operator> <call><name>_open_osfhandle</name> <argument_list>(<argument><expr><operator>(</operator><name>intptr_t</name><operator>)</operator><name><name>pipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>_O_WRONLY</name><operator>|</operator><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd_out</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"_open_osfhandle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cons_out</name> <operator>=</operator> <call><name>dup</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name>fd_out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>radare_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>th</name> <init>= <expr><call><name>CreateThread</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>(</operator><name>LPTHREAD_START_ROUTINE</name><operator>)</operator> <name>r_cons_flush</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__CLOSE_DUPPED_PIPES</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_r_w32_cmd_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>WaitForSingleObject</name> <argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__CLOSE_DUPPED_PIPES</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>WaitForSingleObject</name> <argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>WaitForSingleObject</name> <argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>DWORD</name></type> <name>exit</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GetExitCodeThread</name> <argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>exit</name> <operator>==</operator> <name>STILL_ACTIVE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CancelSynchronousIo</name> <argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>WaitForSingleObject</name> <argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__CLOSE_DUPPED_PIPES</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err_r_w32_cmd_pipe</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CloseHandle</name> <argument_list>(<argument><expr><name><name>pipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fd_out</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fd_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cons_out</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name>cons_out</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>cons_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>systemdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>_shell_cmd_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetConsoleMode</name> <argument_list>(<argument><expr><call><name>GetStdHandle</name> <argument_list>(<argument><expr><name>STD_OUTPUT_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>__CLOSE_DUPPED_PIPES</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_pipe</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>radare_cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shell_cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__UNIX__</name></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>stdout_fd</name></decl>, <decl><type ref="prev"/><name><name>fds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>child</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>si</name></decl>, <decl><type ref="prev"/><name>olen</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>pipecolor</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Pipes are not allowed in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color.pipe"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pipecolor</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>shell_cmd</name><operator>==</operator><literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_grep_parsecmd</name> <argument_list>(<argument><expr><name>shell_cmd</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>olen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>radare_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sys_cmd_str_full</name> <argument_list>(<argument><expr><name>shell_cmd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_memcat</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__UNIX__</name></expr></cpp:if>
<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>radare_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>shell_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sys_signal</name> <argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stdout_fd</name> <operator>=</operator> <call><name>dup</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>stdout_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pipe</name> <argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>r_sys_fork</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot fork\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>stdout_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>radare_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wait</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name>stdout_fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>stdout_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dup2</name> <argument_list>(<argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sandbox_system</name> <argument_list>(<argument><expr><name>shell_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>stdout_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_core_cmd_pipe: Could not pipe\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__WINDOWS__</name></expr></cpp:elif>
<expr_stmt><expr><call><name>r_w32_cmd_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>radare_cmd</name></expr></argument>, <argument><expr><name>shell_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>message</name> <name>(</name><cpp:literal>"r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM"</cpp:literal><name>)</name></cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:warning>#<cpp:directive>warning</cpp:directive> r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM</cpp:warning>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_core_cmd_pipe: unimplemented for this platform\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>pipecolor</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>pipecolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_tmp_evals</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><call><name>r_str_split</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>kv</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kv</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>eq</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ov</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ov</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"e %s=%s;"</literal></expr></argument>, <argument><expr><name>kv</name></expr></argument>, <argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>kv</name></expr></argument>, <argument><expr><name>eq</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eq</name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing '=' in e: expression (%s)\n"</literal></expr></argument>, <argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_macro_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'('</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_ch_after_macro</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>ch</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_core_cmd_subst</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>rep</name> <init>= <expr><call><name>strtoull</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>orep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>colon</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>icmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>tmpseek</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>original_tmpseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"GET /cmd/"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>cmd</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>http</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"HTTP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>http</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>http</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>http</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>http</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>http</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"HTTP/1.0 %d %s\r\n%s"</literal>
<literal type="string">"Connection: close\r\nContent-Length: %d\r\n\r\n"</literal></expr></argument>,
<argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><literal type="string">"OK"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>icmd</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>icmd</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>max_cmd_depth</name></name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>cmd_depth</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>prompt_offset</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>icmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_trim_tail</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cmdrepeat</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_nullcallback</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>icmd</name> <operator>||</operator> <operator>(</operator><name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmt</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>icmd</name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_firstbut</name> <argument_list>(<argument><expr><name>icmd</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>cmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cmt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><call><name>is_macro_command</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>colon</name> <operator>=</operator> <call><name>find_ch_after_macro</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>colon</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>colon</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>colon</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>colon</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Command repeat sugar disabled in sandbox mode (%s)\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&gt;</operator> <name>INTERACTIVE_MAX_REP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_yesno</name> <argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><literal type="string">"Are you sure to repeat this %"</literal><name>PFMT64d</name><literal type="string">" times? (y/N)"</literal></expr></argument>, <argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdrep</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>cmdtimes</name></name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>cmdtimes</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>orep</name> <operator>=</operator> <name>rep</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ocur_enabled</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>rep</name><operator>--</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ocur_enabled</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>seltab</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>seltab</name></name> <operator>==</operator> <name><name>core</name><operator>-&gt;</operator><name>curtab</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cr</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>cmdrep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_subst_i</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>colon</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>rep</name> <operator>==</operator> <name>orep</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>tmpseek</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>break_loop</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cr</name> <operator>&amp;&amp;</operator> <name>orep</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpseek</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>original_tmpseek</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <name>ocur_enabled</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>colon</name> <operator>&amp;&amp;</operator> <name><name>colon</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><operator>++</operator><name>colon</name></expr>;</init> <condition><expr><operator>*</operator><name>colon</name> <operator>==</operator> <literal type="char">';'</literal></expr>;</condition> <incr><expr><name>colon</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>colon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>icmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_nullcallback</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>icmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_eoq</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>findSeparator</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>q</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tmpenvs_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_setenv</name> <argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>set_tmp_arch</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arch</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmparch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>tmparch</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tmparch</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>, <argument><expr><name>arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>set_tmp_bits</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmpbits</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cmd_ignbithints</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>tmpbits</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tmpbits</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>cmd_ignbithints</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ignbithints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ignbithints"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_core_cmd_subst_i</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colon</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tmpseek</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>tmpenvs</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>tmpenvs_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotestr</name> <init>= <expr><literal type="string">"`"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tick</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arroba</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>grep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>tmpdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pamode</name> <init>= <expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pipefd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>usemyblock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_html</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_color</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>eos</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>haveQuote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oldfixedarch</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oldfixedbits</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cmd_tmpseek</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>tmpbsz</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmd_ignbithints</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>$0</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"$("</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>$0</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>$1</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>$0</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>$1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>$0</name> <operator>=</operator> <literal type="char">'`'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>$1</name> <operator>=</operator> <literal type="char">'`'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>$0</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>$0</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>$0</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unterminated $() block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<switch>switch <condition>(<expr><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cmd</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pipefd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>oseek</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>haveQuote</name> <operator>=</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>haveQuote</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>cmd</name></expr> ?</condition><then> <expr><call><name>find_eoq</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing \" in (%s)."</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eos</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sc</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>sc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>op0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <call><name>IS_WHITESPACE</name> <argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op0</name> <operator>=</operator> <operator>*</operator><name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>haveQuote</name> <operator>=</operator> <name>q</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>append</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pipefd</name> <operator>=</operator> <call><name>r_cons_pipe_open</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>IS_WHITESPACE</name> <argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_core_cmd_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oseek</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oseek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pipefd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pipe_close</name> <argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eos</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>haveQuote</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>op0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">")()"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_greater_sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_firstbut</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><literal type="string">"`\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_macro_command</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>find_ch_after_macro</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_lastbut</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>, <argument><expr><name>quotestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>colon</name> <operator>&amp;&amp;</operator> <name>ptr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl> ;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_lastbut</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>, <argument><expr><name>quotestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>escape_pipe</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr2</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr2</name> <operator>||</operator> <operator>(</operator><name>ptr2</name> <operator>&amp;&amp;</operator> <name>ptr2</name> <operator>&gt;</operator> <name>ptr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tick</name> <operator>||</operator> <operator>(</operator><name>tick</name> <operator>&amp;&amp;</operator> <name>tick</name> <operator>&gt;</operator> <name>ptr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_trim_nc</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_vertical_bar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"H"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>scr_html</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"T"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>scr_color</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>use_tts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>cmd</name></expr> ?</condition><then> <expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_io_system</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>scr_html</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scr_color</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>escape_pipe</name>:</label>



<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_lastbut</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>, <argument><expr><name>quotestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"command error(%s)\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>cmd</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"?*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ptr</name> <operator>==</operator> <name>cmd</name> <operator>||</operator> <name><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'~'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>detail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&lt;</operator> <name>ptr</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>detail</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&lt;</operator> <name>ptr</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>detail</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>recursive_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_grep_parsecmd</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_firstbut</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>escape_redir</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_greater_sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fdn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pipecolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color.pipe"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_editor</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ocolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No output?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next2</name>;</goto>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <operator>(</operator><name>cmd</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>IS_WHITECHAR</name> <argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fdnum</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fdnum</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>scr_html</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipecolor</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fdnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>fdnum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fdn</name> <operator>=</operator> <operator>*</operator><name>fdnum</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>fdnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_set_interactive</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_editor</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_file_temp</name> <argument_list>(<argument><expr><literal type="string">"dumpedit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>appendResult</name> <init>= <expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>appendResult</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldText</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>oldText</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>two</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>oldText</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>two</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>two</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"$%s"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"$%s"</literal></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fdn</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pipefd</name> <operator>=</operator> <call><name>r_cons_pipe_open</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fdn</name></expr></argument>, <argument><expr><name>appendResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pipefd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipecolor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pipe_close</name> <argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_set_last_interactive</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipecolor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>ocolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_editor</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>editor</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.editor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>editor</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>editor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_cmdf</name> <argument_list>(<argument><expr><literal type="string">"%s '%s'"</literal></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No cfg.editor configured\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>ocolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>use_tts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<label><name>escape_redir</name>:</label>
<label><name>next2</name>:</label>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>escape_backtick</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oneline</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oneline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>ptr2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"parse: Missing backtick in expression.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_core_cmd_str_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ocolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_in_backticks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_in_backticks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>ocolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_core_cmd_subst_i: invalid backticked command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>oneline</name> <operator>&amp;&amp;</operator> <name>str</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>escape_backtick</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"~?"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>showHelp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>s</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>showHelp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"~??"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>showHelp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>showHelp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_grep_help</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>grep</name> <operator>=</operator> <call><name>r_cons_grep_strip</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>quotestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>cmd</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>cmd_tmpseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>f</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>addr_is_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpbits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>offstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_bits_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_arch_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpeval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpasm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>flgspc_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmpfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<label><name>repeat_arroba</name>:</label>
<expr_stmt><expr><name>arroba</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>?</condition><then>
<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arroba</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>arroba</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_str_trim_tail</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>v</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sys_setenv</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><operator>(</operator><name>st64</name><operator>)</operator><name>addr</name> <operator>-</operator> <operator>(</operator><name>st64</name><operator>)</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fuji</name>;</goto>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_tail</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd_tmpseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>fuji</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: what do you expect for @. import offset from file maybe?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'F'</literal></expr>:</case> 
<expr_stmt><expr><name>flgspc_changed</name> <operator>=</operator> <call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name> <operator>+</operator> <name>index</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut16</name></type> <name>inst_off</name> <init>= <expr><call><name>r_anal_bb_offset_inst</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>inst_off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd_tmpseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"The current basic block has %d instructions\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't find a basic block for 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> 
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<block>{<block_content>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_bytes</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_io_open_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>R_PERM_RWX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot open '%s'\n"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>regval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mander</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><call><name>findSeparator</name> <argument_list>(<argument><expr><name>mander</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>sep</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>sep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>mander</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sep</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>numexpr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>regval</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>numexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>numexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>regval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd_tmpseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mander</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> 
<expr_stmt><expr><name>is_bits_set</name> <operator>=</operator> <call><name>set_tmp_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so %s"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd_tmpseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>parse_tmp_evals</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpeval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpeval</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tmpeval</name> <operator>=</operator> <call><name>r_str_prepend</name> <argument_list>(<argument><expr><name>tmpeval</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>v</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>be</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.bigendian"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bi</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_write_ble64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_write_ble32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_bytes</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_io_open_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>R_PERM_RWX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid @v: syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_bytes</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_io_open_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>R_PERM_RWX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Invalid hexpairs for @x:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot allocate\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid @x: syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>usemyblock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmpfd</name> <operator>=</operator> <ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_io_use_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>is_bits_set</name> <operator>=</operator> <call><name>set_tmp_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>is_arch_set</name> <operator>=</operator> <call><name>set_tmp_arch</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpasm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: pd 10 @a:arm:32\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case> 
<block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_bytes</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_io_open_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>R_PERM_RWX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<default>default:</default>
<goto>goto <name>ignore</name>;</goto>
</block_content>}</block></switch>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trim</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>trim</name> <operator>&gt;</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_WHITESPACE</name> <argument_list>(<argument><expr><operator>*</operator><name>trim</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>trim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>trim</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<goto>goto <name>next_arroba</name>;</goto>
</block_content>}</block></if></if_stmt>
<label><name>ignore</name>:</label>
<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_trim_nc</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">13</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>ptr2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>ptr2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>ptr2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ptr2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(
<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offstr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>offstr</name> <operator>==</operator> <literal type="char">'{'</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></then><else>: <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>offstr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>addr_is_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid address (%s)\n"</literal></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>offstr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>tmpdesc</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>r_io_desc_size</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>next_arroba</name>:</label>
<if_stmt><if>if <condition>(<expr><name>arroba</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>arroba</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>arroba</name> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>arroba</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>repeat_arroba</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedblock</name></name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>tmpdesc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>fixedblock</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rule</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>rule</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>rule</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rule</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_foreach3</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_foreach</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>tmpseek</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>fromvars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"anal.from"</literal></expr>, <expr><literal type="string">"diff.from"</literal></expr>, <expr><literal type="string">"graph.from"</literal></expr>, <expr><literal type="string">"search.from"</literal></expr>, <expr><literal type="string">"zoom.from"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>tovars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"anal.to"</literal></expr>, <expr><literal type="string">"diff.to"</literal></expr>, <expr><literal type="string">"graph.to"</literal></expr>, <expr><literal type="string">"search.to"</literal></expr>, <expr><literal type="string">"zoom.to"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name><name>curfrom</name><index>[<expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name>fromvars</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>curto</name><index>[<expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name>tovars</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: / ABCD @{0x1000 0x3000}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Run command and define the following vars:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" (anal|diff|graph|search|zoom).{from,to}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmpeval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmpasm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arg_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>arg_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><index>[<expr><name>arg_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\x00'</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>curfrom</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>curto</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>tmpseek</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>usemyblock</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr_is_set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr_is_set</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpseek</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>curfrom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>curto</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr2</name> <operator>=</operator> <literal type="char">'!'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tmpbsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arch_set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name> <operator>=</operator> <name>oldfixedarch</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>, <argument><expr><name>tmpasm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmpasm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_use_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_bits_set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>, <argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name> <operator>=</operator> <name>oldfixedbits</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpbsz</name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tmpbsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpeval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tmpeval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmpeval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flgspc_changed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<label><name>fuji</name>:</label>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_trim_head</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>beach</name>:</label>
<if_stmt><if>if <condition>(<expr><name>grep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>grep</name> <operator>=</operator> <call><name>unescape_special_chars</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>, <argument><expr><name>SPECIAL_CHARS_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_grep_process</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>tmpenvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>tmpdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpdesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name> <operator>=</operator> <name>oldfixedarch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name> <operator>=</operator> <name>oldfixedbits</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpseek</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tmpseek</name> <operator>=</operator> <name>cmd_tmpseek</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd_ignbithints</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ignbithints"</literal></expr></argument>, <argument><expr><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>rc</name></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>foreach_comment</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalMetaUserItem</name> <modifier>*</modifier></type><name>ui</name> <init>= <expr><name>user</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>ui</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>ui</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"meta.C."</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmt</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>sdb_decode</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"s %s"</literal></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>exec_command_t</name> <block>{
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>exec_command_on_flag</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>exec_command_t</name></name> <modifier>*</modifier></type><name>user</name> <init>= <expr><operator>(</operator>struct <name>exec_command_t</name> <operator>*</operator><operator>)</operator><name>u</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name><name>flg</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name><name>flg</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>foreach_pairs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>each</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pair</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name>each</name></expr> ;</init> <condition>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pair</name><operator>%</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>pair</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>next</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_foreach3</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>each</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>filter</name> <operator>=</operator> <name>each</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'='</literal></expr>:</case>
<expr_stmt><expr><call><name>foreach_pairs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>each</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_at_at_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>foreach_pairs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: @@@c:command #same as @@@=`command`\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_meta_list_cb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>foreach_comment</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>cmd</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>r_io_fd_get_current</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>maps</name> <init>= <expr><call><name>r_io_map_get_for_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>maps</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>maps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>dbg</name> <operator>&amp;&amp;</operator> <name><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <name><name>dbg</name><operator>-&gt;</operator><name>maps</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>dbg</name> <operator>&amp;&amp;</operator> <name><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <name><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>threads</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>origpid</name> <init>= <expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugPid</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>threads</name></name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dp %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"PID %d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dp %d"</literal></expr></argument>, <argument><expr><name>origpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>R_REG_TYPE_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>r_reg_get_list</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>head</argument>, <argument>iter</argument>, <argument>item</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>i</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>RBinImport</name> <modifier>*</modifier></type><name>imp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_bin_get_imports</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>imp</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>impflag</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"sym.imp.%s"</literal></expr></argument>, <argument><expr><name><name>imp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>impflag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>impflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bszorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>sec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>sec</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>sec</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>sec</name><operator>-&gt;</operator><name>vsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bszorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ATTIC</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>sec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cbsz</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>it</argument>, <argument>sec</argument>)</argument_list></macro><block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>sec</name><operator>-&gt;</operator><name>vaddr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><name><name>sec</name><operator>-&gt;</operator><name>vsize</name></name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><call><name>r_core_seek_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cbsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_bin_get_strings</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RBinString</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_bin_get_symbols</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>sym</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> 
<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><ternary><condition><expr><name>filter</name></expr>?</condition><then> <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>exec_command_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>core</name> <operator>=</operator> <name>core</name></expr>, <expr><operator>.</operator><name>cmd</name> <operator>=</operator> <name>cmd</name></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>exec_command_on_flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filter</name> <operator>||</operator> <call><name>r_str_glob</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offorig</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>obs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>offorig</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>foreachOffset</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>each</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nextLine</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>each</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>each</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>each</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>each</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>each</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nextLine</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>nextLine</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>each</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>each</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>each</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>each</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>each</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>each</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>each</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>each</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>each</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>each</name> <operator>=</operator> <name>nextLine</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_foreach</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>each</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ostr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>oseek</name></decl>, <decl><type ref="prev"/><name>addr</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>oseek</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ostr</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<switch>switch <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'/'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdhit</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>, <argument><expr><name>cmdhit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmdhit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="char">'?'</literal></expr>:</case> 
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_at_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>each</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>r_str_split</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>step</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>cur</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: cmd @@s:from to step\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>op_pos_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>op_pos</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>each</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RConsGrep</name></type> <name>grep</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>grep</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_cons_get_buffer</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>grep</name></name> <operator>=</operator> <name>grep</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>RDebugPid</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#PID %d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out_finish</name>;</goto>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>each</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>foreachOffset</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'='</literal></expr>:</case> 
<expr_stmt><expr><call><name>foreachOffset</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <name><name>each</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>oseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oseek</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name><argument_list>(<argument><expr><literal type="string">"Invalid for-each statement. Use @@=dbt[abs]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>each</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>each</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>each</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>each</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>each</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>each</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><literal type="char">'.'</literal></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name><name>each</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>cmd2</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">999</literal></expr>;</condition> <incr><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cmd_macro_call</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name></name></expr></argument>, <argument><expr><name>each</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>brk_value</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>_brk_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>cmd2</name></expr></argument>, <argument><expr><literal type="string">"%s @ 0x%08"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" (%s)\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>cmd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>cmd2</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>r_sandbox_fopen</name> <argument_list>(<argument><expr><name>each</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>feof</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">": %s\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>cmd2</name></expr></argument>, <argument><expr><literal type="string">"%s @ 0x%08"</literal><name>PFMT64x</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fclose</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot open file '%s' to read offsets\n"</literal></expr></argument>, <argument><expr><name>each</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>each</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>each</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<empty_stmt>;</empty_stmt> 
</block_content>}</block></for>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>word</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RSpace</name> <modifier>*</modifier></type><name>flagspace</name> <init>= <expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>match_flag_items</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>r_flag_item_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_flag_items</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>





<decl_stmt><decl><type><name><name>struct</name> <name>duplicate_flag_t</name></name></type> <name>u</name> <init>= <expr><block>{
<expr><operator>.</operator><name>ret</name> <operator>=</operator> <name>match_flag_items</name></expr>,
<expr><operator>.</operator><name>word</name> <operator>=</operator> <name>word</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_foreach_space</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagspace</name></expr></argument>, <argument><expr><name>duplicate_flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<macro><name>r_list_foreach</name> <argument_list>(<argument>match_flag_items</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_cons_get_buffer</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <ternary><condition><expr><name>tmp</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>match_flag_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name><operator>++</operator></expr> ;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></while>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>oseek</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<label><name>out_finish</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>run_cmd_depth</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TREESITTER</name></expr></cpp:if>

<struct>struct <name>tsr2cmd_state</name> <block>{
<decl_stmt><decl><type><name>TSParser</name> <modifier>*</modifier></type><name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>saved_input</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSTree</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSTree</name> <modifier>*</modifier></type><name>saved_tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>log</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>split_lines</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_last_cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>substitute_cmd</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>tsr2cmd_edit</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSPoint</name></type> <name>start_point</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSPoint</name></type> <name>end_point</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>parsed_args</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argv_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>ts_handler</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>ts_data_symbol_map</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TS_START_END</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { start = ts_node_start_byte (node); end = ts_node_end_byte (node); } while (0)</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ts_node_sub_string</name><parameter_list>(<parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TS_START_END</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>cstr</name> <operator>+</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ts_node_sub_parent_string</name><parameter_list>(<parameter><decl><type><name>TSNode</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TS_START_END</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>parent_start</name> <init>= <expr><call><name>ts_node_start_byte</name> <argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> <operator>-=</operator> <name>parent_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>-=</operator> <name>parent_start</name></expr>;</expr_stmt>
<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>cstr</name> <operator>+</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_IS_TS_FCN</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TSSymbol ts_##name##_symbol; static inline bool is_ts_##name(TSNode node) { return ts_node_symbol (node) == ts_##name##_symbol; }</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_HANDLE_TS_FCN</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DEFINE_IS_TS_FCN (name) static bool handle_ts_##name##_internal(struct tsr2cmd_state *state, TSNode node, char *node_string); static bool handle_ts_##name(struct tsr2cmd_state *state, TSNode node) { char *node_string = ts_node_sub_string (node, state-&gt;input); R_LOG_DEBUG (#name ": '%s'\n", node_string); bool res = handle_ts_##name##_internal (state, node, node_string); free (node_string); return res; } static bool handle_ts_##name##_internal(struct tsr2cmd_state *state, TSNode node, char *node_string)</cpp:value></cpp:define>











<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handle_ts_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>core_cmd_tsr2cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>split_lines</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>log</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>fdn_redirect_operator</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>fdn_append_operator</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>html_redirect_operator</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>html_append_operator</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>cmd_substitution_arg</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>args</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>arg</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>arg_identifier</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>double_quoted_arg</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>single_quoted_arg</argument>)</argument_list></macro>
<macro><name>DEFINE_IS_TS_FCN</name><argument_list>(<argument>concatenation</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>create_cmd_edit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>new_text</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>tsr2cmd_edit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>command_start</name> <init>= <expr><call><name>ts_node_start_byte</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSPoint</name></type> <name>command_point</name> <init>= <expr><call><name>ts_node_start_point</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>new_text</name></name> <operator>=</operator> <name>new_text</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>old_text</name></name> <operator>=</operator> <call><name>ts_node_sub_parent_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <call><name>ts_node_start_byte</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>command_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <call><name>ts_node_end_byte</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>command_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>start_point</name></name> <operator>=</operator> <call><name>ts_node_start_point</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>end_point</name></name> <operator>=</operator> <call><name>ts_node_end_point</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>start_point</name><operator>.</operator><name>row</name></name> <operator>==</operator> <name><name>command_point</name><operator>.</operator><name>row</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>start_point</name><operator>.</operator><name>column</name></name> <operator>-=</operator> <name><name>command_point</name><operator>.</operator><name>column</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>end_point</name><operator>.</operator><name>row</name></name> <operator>==</operator> <name><name>command_point</name><operator>.</operator><name>row</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>end_point</name><operator>.</operator><name>column</name></name> <operator>-=</operator> <name><name>command_point</name><operator>.</operator><name>column</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>start_point</name><operator>.</operator><name>row</name></name> <operator>-=</operator> <name><name>command_point</name><operator>.</operator><name>row</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>end_point</name><operator>.</operator><name>row</name></name> <operator>-=</operator> <name><name>command_point</name><operator>.</operator><name>row</name></name></expr>;</expr_stmt>
<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>replace_whitespaces</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isspace</name> <argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>escape_special_chars</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>special_chars</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>R_NEWS</name> <argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>s_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>s_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>special_chars</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>d</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>d</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>d</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_tsr2cmd_edit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>edit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>edit</name><operator>-&gt;</operator><name>new_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>edit</name><operator>-&gt;</operator><name>old_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>edit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parsed_args_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>do_handle_substitution_cmd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>inn_cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inn_str</name> <init>= <expr><call><name>ts_node_sub_parent_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name></expr></argument>, <argument><expr><name>inn_cmd</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>ocolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_in_backticks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o_out</name> <init>= <expr><ternary><condition><expr><name><name>inn_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>?</condition><then>
<expr><call><name>r_core_cmd_str_pipe</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>inn_str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>:
<expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>inn_str</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_in_backticks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>ocolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inn_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>o_out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"output of inner command: '%s'\n"</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>o_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>replace_whitespaces</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_cmd_substitution_arg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>inn_cmd</name> <init>= <expr><call><name>ts_node_child</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>inn_cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>do_handle_substitution_cmd</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>inn_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>special_chars</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_ts_double_quoted_arg</name> <argument_list>(<argument><expr><call><name>ts_node_parent</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>special_chars</name> <operator>=</operator> <name>SPECIAL_CHARS_DOUBLE_QUOTED</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>special_chars</name> <operator>=</operator> <name>SPECIAL_CHARS_REGULAR</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>escape_special_chars</name> <argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>special_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>create_cmd_edit</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_substitution_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_ts_args</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ts_concatenation</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ts_double_quoted_arg</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>n_children</name> <init>= <expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_children</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>handle_substitution_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_cmd_substitution_arg</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>handle_cmd_substitution_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_arg</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>handle_substitution_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>unescape_arg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>special_chars</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>unescaped_arg</name> <init>= <expr><call><name>unescape_special_chars</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>special_chars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"original arg = '%s', unescaped arg = '%s'\n"</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>unescaped_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>unescaped_arg</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>do_handle_ts_unescape_arg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_ts_arg</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>do_handle_ts_unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_arg_identifier</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>SPECIAL_CHARS_REGULAR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_single_quoted_arg</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ts_double_quoted_arg</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>special</name> <init>= <expr><ternary><condition><expr><call><name>is_ts_single_quoted_arg</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><name>SPECIAL_CHARS_SINGLE_QUOTED</name></expr></then><else>: <expr><name>SPECIAL_CHARS_DOUBLE_QUOTED</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>special</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_concatenation</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_children</name> <init>= <expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_children</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>sub_arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>do_handle_ts_unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>sub_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>create_argv_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>handle_ts_unescape_arg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>parsed_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>R_NEWS</name> <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>do_handle_ts_unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv_str</name></name> <operator>=</operator> <call><name>create_argv_str</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>parse_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_ts_args</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>n_children</name> <init>= <expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>parsed_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>n_children</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name></name> <operator>=</operator> <call><name>R_NEWS</name> <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_children</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>do_handle_ts_unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>argv_str</name></name> <operator>=</operator> <call><name>create_argv_str</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>handle_ts_unescape_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TSTree</name> <modifier>*</modifier></type><name>apply_edits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>edit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"old input = '%s'\n"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>edits</argument>, <argument>it</argument>, <argument>edit</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"apply_edits: about to replace '%s' with '%s'\n"</literal></expr></argument>, <argument><expr><name><name>edit</name><operator>-&gt;</operator><name>old_text</name></name></expr></argument>, <argument><expr><name><name>edit</name><operator>-&gt;</operator><name>new_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>, <argument><expr><name><name>edit</name><operator>-&gt;</operator><name>old_text</name></name></expr></argument>, <argument><expr><name><name>edit</name><operator>-&gt;</operator><name>new_text</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"new input = '%s'\n"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ts_parser_parse_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>substitute_args_fini</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tree</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>saved_tree</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ts_tree_delete</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>saved_tree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>saved_tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>saved_input</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>saved_input</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>saved_input</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>substitute_args_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>command</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>saved_input</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>saved_tree</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name> <operator>=</operator> <call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>substitute_cmd</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"Shrinking input to '%s'\n"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>substitute_args_do</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name></decl></parameter>, <parameter><decl><type><name>TSNode</name> <modifier>*</modifier></type><name>new_command</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TSTree</name> <modifier>*</modifier></type><name>new_tree</name> <init>= <expr><call><name>apply_edits</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_tree</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>root</name> <init>= <expr><call><name>ts_tree_root_node</name> <argument_list>(<argument><expr><name>new_tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ts_node_has_error</name> <argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ts_tree_delete</name> <argument_list>(<argument><expr><name>new_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>new_command</name> <operator>=</operator> <call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>new_tree</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>substitute_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>TSNode</name> <modifier>*</modifier></type><name>new_command</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free_tsr2cmd_edit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_ts_args</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ts_arg</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>handle_substitution_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>substitute_args_do</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>, <argument><expr><name>new_command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ts_node_handle_arg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>command</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>child_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>new_command</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>substitute_args_init</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>substitute_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Error while substituting arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>new_command</name></expr></argument>, <argument><expr><name>child_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>parse_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse arg\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv_str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>parsed_args_free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>create_exec_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd_str</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>pr_args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>command_arg_space</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pr_args</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>command_arg_space</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>pr_args</name><operator>-&gt;</operator><name>argv_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>arged_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"arged_command command: '%s'\n"</literal></expr></argument>, <argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>args</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>, <argument><expr><literal type="string">"|."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exec_string</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>exec_string</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>exec_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>pr_args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>new_command</name></decl>, <decl><type ref="prev"/><name>new_args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>substitute_args_init</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>substitute_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Error while substituting arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_args</name> <operator>=</operator> <call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>new_command</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pr_args</name> <operator>=</operator> <call><name>parse_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>new_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pr_args</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pr_args</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"parsed_arg %d: '%s'\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pr_args</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>command_arg_space</name> <init>= <expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ts_node_end_byte</name> <argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ts_node_start_byte</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exec_string</name> <init>= <expr><call><name>create_exec_string</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>, <argument><expr><name>pr_args</name></expr></argument>, <argument><expr><name>command_arg_space</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"arged_command exec_string = '%s'\n"</literal></expr></argument>, <argument><expr><name>exec_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>exec_string</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>exec_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><call><name>parsed_args_free</name> <argument_list>(<argument><expr><name>pr_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>legacy_quoted_command</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>run_cmd_depth</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>node_string</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>repeat_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>number</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>number_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rep</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>number_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>number_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Command repeat sugar disabled in sandbox mode (%s)\n"</literal></expr></argument>, <argument><expr><name>node_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>&gt;</operator> <name>INTERACTIVE_MAX_REP</name> <operator>&amp;&amp;</operator> <call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_yesno</name> <argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><literal type="string">"Are you sure to repeat this %"</literal> <name>PFMT64d</name> <literal type="string">" times? (y/N)"</literal></expr></argument>, <argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rep</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>redirect_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pipecolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color.pipe"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ocolor</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_html</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>is_append</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>is_html</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fdn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>redirect_op</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"redirect_operator"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"redirect_operator"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_ts_fdn_redirect_operator</name> <argument_list>(<argument><expr><name>redirect_op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_fdn_append_operator</name> <argument_list>(<argument><expr><name>redirect_op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_html_redirect_operator</name> <argument_list>(<argument><expr><name>redirect_op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_html</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_ts_html_append_operator</name> <argument_list>(<argument><expr><name>redirect_op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_html</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"This should never happen, redirect_operator is no known type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_html</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scr_html</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipecolor</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>fd_desc</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>redirect_op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>fd_desc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fd_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>fd_desc</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fdn</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>fd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fd_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_set_interactive</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arg_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"redirect_command: alias = '%s'\n"</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_alias_value</name> <init>= <expr><call><name>r_cmd_alias_get</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_alias_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start_char</name> <init>= <expr><literal type="string">"$"</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_append</name> <operator>&amp;&amp;</operator> <name>old_alias_value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>start_char</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>old_alias_value</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>new_alias_value</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>start_char</name></expr></argument>, <argument><expr><name>old_alias_value</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cmd_alias_set</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>new_alias_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>new_alias_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"redirect_command: fdn = %d, is_append = %d\n"</literal></expr></argument>, <argument><expr><name>fdn</name></expr></argument>, <argument><expr><name>is_append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pipefd</name> <init>= <expr><call><name>r_cons_pipe_open</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>fdn</name></expr></argument>, <argument><expr><name>is_append</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pipefd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipecolor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pipe_close</name> <argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_WARN</name> <argument_list>(<argument><expr><literal type="string">"Could not open pipe to %d"</literal></expr></argument>, <argument><expr><name>fdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_set_last_interactive</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipecolor</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>ocolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>use_tts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>help_command</argument>)</argument_list></macro> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>, <argument><expr><literal type="string">"@?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>help_msg_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>, <argument><expr><literal type="string">"@@?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>help_msg_at_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>, <argument><expr><literal type="string">"@@@?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>help_msg_at_at_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>, <argument><expr><literal type="string">"|?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>help_msg_vertical_bar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>, <argument><expr><literal type="string">"~?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_grep_help</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>node_string</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"?*"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>node_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>node_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>detail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>node_len</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>node_string</name><index>[<expr><name>node_len</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>detail</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>node_len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>node_string</name><index>[<expr><name>node_len</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>detail</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node_string</name><index>[<expr><name>node_len</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <name>detail</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>recursive_help</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>node_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>r_cmd_call</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>node_string</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_seek_command</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>offset</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>offset_string</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"tmp_seek_command, changing offset to %s\n"</literal></expr></argument>, <argument><expr><name>offset_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>offset_string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>offset_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_blksz_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>blksz</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>blksz_string</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>blksz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_blksz</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"tmp_blksz_command, changing blksz to %s\n"</literal></expr></argument>, <argument><expr><name>blksz_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>blksz_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>orig_blksz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>blksz_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_fromto_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>from</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>to</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"tmp_fromto_command, changing fromto to (%s, %s)\n"</literal></expr></argument>, <argument><expr><name>from_str</name></expr></argument>, <argument><expr><name>to_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>fromvars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"anal.from"</literal></expr>, <expr><literal type="string">"diff.from"</literal></expr>, <expr><literal type="string">"graph.from"</literal></expr>,
<expr><literal type="string">"io.buffer.from"</literal></expr>, <expr><literal type="string">"lines.from"</literal></expr>, <expr><literal type="string">"search.from"</literal></expr>, <expr><literal type="string">"zoom.from"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>tovars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"anal.to"</literal></expr>, <expr><literal type="string">"diff.to"</literal></expr>, <expr><literal type="string">"graph.to"</literal></expr>,
<expr><literal type="string">"io.buffer.to"</literal></expr>, <expr><literal type="string">"lines.to"</literal></expr>, <expr><literal type="string">"search.to"</literal></expr>, <expr><literal type="string">"zoom.to"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from_val</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>from_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to_val</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>to_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>fromvars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>from_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name><name>tovars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>from_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>to_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_arch_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmparch</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmpbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_arch_set</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>is_bits_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oldfixedarch</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name></expr></init></decl>, <decl><type ref="prev"/><name>oldfixedbits</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmd_ignbithints</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>is_bits_set</name> <operator>=</operator> <call><name>set_tmp_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>is_arch_set</name> <operator>=</operator> <call><name>set_tmp_arch</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmparch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>is_arch_set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedarch</name></name> <operator>=</operator> <name>oldfixedarch</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>, <argument><expr><name>tmparch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmparch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_bits_set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>, <argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name> <operator>=</operator> <name>oldfixedbits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd_ignbithints</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ignbithints"</literal></expr></argument>, <argument><expr><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_bits_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oldfixedbits</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmd_ignbithints</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_tmp_bits</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>, <argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedbits</name></name> <operator>=</operator> <name>oldfixedbits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.ignbithints"</literal></expr></argument>, <argument><expr><name>cmd_ignbithints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmpbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_nthi_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name> <operator>+</operator> <name>index</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut16</name></type> <name>inst_off</name> <init>= <expr><call><name>r_anal_bb_offset_inst</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>inst_off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"The current basic block has just %d instructions\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't find a basic block for 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_eval_command</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>args</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_args</name> <init>= <expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_args</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_s</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>eq</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing '=' in e: expression (%s)\n"</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_fs_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_reli_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so %d"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_kuery_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_fd_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmpfd</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name></name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_use_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_io_use_fd</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_reg_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>regval</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>regval</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>handle_tmp_desc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pamode</name> <init>= <expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>o_fixedblock</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>fixedblock</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_bytes</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>r_io_open_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>R_PERM_RWX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open io buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out_buf</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_map_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedblock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_read</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>fixedblock</name></name> <operator>=</operator> <name>o_fixedblock</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pamode</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.va"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_io_desc_close</name> <argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out_buf</name>:</label>
<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_file_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open '%s'\n"</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_tmp_desc</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_string_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><name>arg_str</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_tmp_desc</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>tmp_hex_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>R_NEWS</name> <argument_list>(<argument><expr><name>ut8</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_tmp_desc</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_flags_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RSpace</name> <modifier>*</modifier></type><name>flagspace</name> <init>= <expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>match_flag_items</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>r_flag_item_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_flag_items</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<decl_stmt><decl><type><name><name>struct</name> <name>duplicate_flag_t</name></name></type> <name>u</name> <init>= <expr><block>{
<expr><operator>.</operator><name>ret</name> <operator>=</operator> <name>match_flag_items</name></expr>,
<expr><operator>.</operator><name>word</name> <operator>=</operator> <name>arg_str</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_flag_foreach_space</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagspace</name></expr></argument>, <argument><expr><name>duplicate_flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<macro><name>r_list_foreach</name> <argument_list>(<argument>match_flag_items</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"iter_flags_command: seek to %"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_cons_get_buffer</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <ternary><condition><expr><name>tmp</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>match_flag_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block>

<enum>enum <name>dbt_commands_mode</name> <block>{
<decl><name>DBT_COMMANDS_MODE_ADDR</name></decl>,
<decl><name>DBT_COMMANDS_MODE_BP</name></decl>,
<decl><name>DBT_COMMANDS_MODE_SP</name></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>iter_dbt_commands</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>dbt_commands_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_debug_frames</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugFrame</name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>frame</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DBT_COMMANDS_MODE_ADDR</name></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DBT_COMMANDS_MODE_SP</name></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DBT_COMMANDS_MODE_BP</name></expr>:</case>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_dbta_command</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>iter_dbt_commands</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>DBT_COMMANDS_MODE_ADDR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_dbtb_command</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>iter_dbt_commands</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>DBT_COMMANDS_MODE_BP</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_dbts_command</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>iter_dbt_commands</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>DBT_COMMANDS_MODE_SP</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_file_lines_command</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><call><name>r_sandbox_fopen</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>arg_out</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>feof</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>counter</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>arg_out</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_offsets_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>args</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>new_command</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>substitute_args_init</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>substitute_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Error while substituting arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>new_command</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>parse_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_ERROR</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse args\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"iter_offsets_command: seek to %"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parsed_args_free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_sdbquery_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>each</name> <init>= <expr><name>out</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>each</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>each</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>each</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>each</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>each</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_threads_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name></name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>pids</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugPid</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"#PID %d\n"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_debug_select</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_bbs_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No function at current address\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_instrs_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No function at current address\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <call><name>r_anal_bb_offset_inst</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>r_anal_bb_size_i</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_functions_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg_str</name> <operator>=</operator> <call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>arg_str</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_cons_get_buffer</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_step_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>from_n</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>to_n</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>step_n</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bs</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>from_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>from_n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>to_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>to_n</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>step_str</name> <init>= <expr><call><name>ts_node_handle_arg</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>step_n</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>from_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>to_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>step</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>step_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>from_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>to_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>step_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>cur</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>cur</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>r_core_block_size</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_interpret_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>in_cmd</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>substitute_args_init</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>edits</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free_tsr2cmd_edit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>in_cmd_out</name> <init>= <expr><call><name>do_handle_substitution_cmd</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>in_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>in_cmd_out</name> <operator>=</operator> <call><name>escape_special_chars</name> <argument_list>(<argument><expr><name>in_cmd_out</name></expr></argument>, <argument><expr><name>SPECIAL_CHARS_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tsr2cmd_edit</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>create_cmd_edit</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>in_cmd</name></expr></argument>, <argument><expr><name>in_cmd_out</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>op</name> <init>= <expr><call><name>ts_node_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>create_cmd_edit</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"@@="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TSNode</name></type> <name>new_command</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>substitute_args_do</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>edits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>args</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>new_command</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>parsed_args</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>parse_args</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>edits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>substitute_args_fini</name> <argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>orig_offset</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"iter_interpret_command: seek to %"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>orig_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parsed_args_free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>iter_hit_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>search_cmd</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdhit</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>, <argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>search_cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>, <argument><expr><name>cmdhit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>last_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>is_last_cmd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>grep_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>arg</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"specifier"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"specifier"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"grep_command specifier: '%s'\n"</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_strbuf_prepend</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>specifier_str</name> <init>= <expr><call><name>r_cons_grep_strip</name> <argument_list>(<argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"`"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_strbuf_free</name> <argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>specifier_str</name> <operator>=</operator> <call><name>unescape_special_chars</name> <argument_list>(<argument><expr><name>specifier_str</name></expr></argument>, <argument><expr><name>SPECIAL_CHARS_REGULAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"grep_command processed specifier: '%s'\n"</literal></expr></argument>, <argument><expr><name>specifier_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_grep_process</name> <argument_list>(<argument><expr><name>specifier_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>html_disable_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_html</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_color</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>html_enable_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_html</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_html</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>scr_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>pipe_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>first_cmd</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>first_cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>second_cmd</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ts_node_is_null</name> <argument_list>(<argument><expr><name>second_cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>first_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>first_cmd</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>second_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>second_cmd</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>r_core_cmd_pipe</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>first_str</name></expr></argument>, <argument><expr><name>second_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>first_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>second_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>scr_tts_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_child_by_field_name</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scr_color</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>COLOR_MODE_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>use_tts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>scr_color</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>scr_color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>task_command</argument>)</argument_list></macro> <block>{<block_content>


<return>return <expr><call><name>handle_ts_arged_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>number_command</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>node_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>handle_ts_command</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TSNode</name></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TSSymbol</name></type> <name>node_symbol</name> <init>= <expr><call><name>ts_node_symbol</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ts_handler</name></type> <name>handler</name> <init>= <expr><call><name>ht_up_find</name> <argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>ts_symbols_ht</name></name></expr></argument>, <argument><expr><name>node_symbol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>is_last_cmd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>handler</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>handler</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_LOG_WARN</name> <argument_list>(<argument><expr><literal type="string">"No handler for this kind of command `%s`\n"</literal></expr></argument>, <argument><expr><call><name>ts_node_type</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>log</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_last_cmd</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>=</operator> <call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>DEFINE_HANDLE_TS_FCN</name><argument_list>(<argument>commands</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>child_count</name> <init>= <expr><call><name>ts_node_named_child_count</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"commands with %d childs\n"</literal></expr></argument>, <argument><expr><name>child_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>child_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>breaked</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>breaked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>cmdrepeat</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>lastcmd_repeat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>split_lines</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>child_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>split_lines</name></name> <operator>&amp;&amp;</operator> <call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>command</name> <init>= <expr><call><name>ts_node_named_child</name> <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>&amp;=</operator> <call><name>handle_ts_command</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command_str</name> <init>= <expr><call><name>ts_node_sub_string</name> <argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>input</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error while executing command: %s\n"</literal></expr></argument>, <argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>command_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>split_lines</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>split_lines</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HANDLER_RULE_OP</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #name, handle_ts_##name },</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULE_OP</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<decl_stmt><decl><type><name><name>struct</name> <name>ts_data_symbol_map</name></name></type> <name><name>map</name><index>[]</index></name> <init>= <expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r2-shell-parser-cmds.inc"</cpp:file></cpp:include>
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULE_OP</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #name, &amp;ts_##name##_symbol },</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HANDLER_RULE_OP</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RULE_OP(name)</cpp:value></cpp:define>

<decl_stmt><decl><type><name><name>struct</name> <name>ts_data_symbol_map</name></name></type> <name><name>map_symbols</name><index>[]</index></name> <init>= <expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r2-shell-parser-cmds.inc"</cpp:file></cpp:include>
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ts_symbols_init</name><parameter_list>(<parameter><decl><type><name>RCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>language</name></name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>TSLanguage</name> <modifier>*</modifier></type><name>lang</name> <init>= <expr><call><name>tree_sitter_r2cmd</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>language</name></name> <operator>=</operator> <name>lang</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>ts_symbols_ht</name></name> <operator>=</operator> <call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ts_data_symbol_map</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>map</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TSSymbol</name></type> <name>symbol</name> <init>= <expr><call><name>ts_language_symbol_for_name</name> <argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ht_up_insert</name> <argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>ts_symbols_ht</name></name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>map_symbols</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TSSymbol</name> <modifier>*</modifier></type><name>sym_ptr</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>sym_ptr</name> <operator>=</operator> <call><name>ts_language_symbol_for_name</name> <argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entry</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>core_cmd_tsr2cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>split_lines</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>log</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ts_symbols_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TSParser</name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><call><name>ts_parser_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ts_parser_set_language</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>TSLanguage</name> <operator>*</operator><operator>)</operator><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>language</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TSTree</name> <modifier>*</modifier></type><name>tree</name> <init>= <expr><call><name>ts_parser_parse_string</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TSNode</name></type> <name>root</name> <init>= <expr><call><name>ts_tree_root_node</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tsr2cmd_state</name></name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>core</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>input</name></name> <operator>=</operator> <name>input</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>tree</name></name> <operator>=</operator> <name>tree</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>log</name></name> <operator>=</operator> <name>log</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>split_lines</name></name> <operator>=</operator> <name>split_lines</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>log</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_line_hist_add</name> <argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_ts_commands</name> <argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ts_node_has_error</name> <argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_ts_commands</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error while parsing command: `%s`\n"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ts_tree_delete</name> <argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ts_parser_delete</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>run_cmd_depth</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rcmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>cmd_depth</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_core_cmd: That was too deep (%s)...\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>cmd_depth</name></name><operator>--</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>rcmd</name> <operator>=</operator> <name>cmd</name></expr>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>rcmd</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>rcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|ERROR| Invalid command '%s' (0x%02x)\n"</literal></expr></argument>, <argument><expr><name>rcmd</name></expr></argument>, <argument><expr><operator>*</operator><name>rcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rcmd</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>cmd_depth</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>use_tree_sitter_r2cmd</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>USE_TREESITTER</name></expr></condition></ternary></expr></cpp:if>
<return>return <expr><ternary><condition><expr><call><name>core_cmd_tsr2cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>R_LOG_WARN</name> <argument_list>(<argument><expr><literal type="string">"No compilation support for radare2-shell-parser\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cmdfilter</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_chars</name> <init>= <expr><literal type="string">";|&gt;`@"</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>invalid_chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><name><name>invalid_chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmdfilter</name></name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmdfilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cmdremote</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cstr</name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cstr</name> <operator>!=</operator> <literal type="char">'q'</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"!="</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_io_system</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>beach</name>;</goto> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cstr</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cstr</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>&amp;&amp;</operator> <name><name>cstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"/*"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This command is disabled in sandbox mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>incomment</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"*/"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>incomment</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>incomment</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>log</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cstr</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cstr</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">".("</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>lastcmd</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_str_cpy</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_line_hist_add</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>run_cmd_depth</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>beach</name>:</label>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_lines</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lines</name></decl></parameter>)</parameter_list> <block>{<block_content>





<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>odata</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lines</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>lines</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>odata</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>odata</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>odata</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"'q': quit ignored. Use 'q!'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>nl</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>data</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_task_yield</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_file</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>r_file_abspath</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>odata</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>odata</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_cmd_lines</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to run script '%s'\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>odata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_command</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rcmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_core_sysenv_begin</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rcmd</name> <operator>=</operator> <name>ptr</name> <operator>=</operator> <name>buf</name> <operator>=</operator> <call><name>r_sys_cmd_str</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>rcmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_sysenv_end</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_disassemble_instr</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"pd %i @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_disassemble_bytes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"pD %i @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_buffer</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>optr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>optr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>optr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmdf</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>string</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name> <argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd0</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_flush</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_cmd_str_pipe</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'"'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
char *p = (*cmd != '"')? strchr (cmd, '|'): NULL;
if (p) {



char *c = strdup (cmd);
c[p - cmd] = 0;
if (!strcmp (p + 1, "H")) {
char *res = r_core_cmd_str (core, c);
free (c);
char *hres = r_cons_html_filter (res, NULL);
free (res);
return hres;
} else {
int sh = r_config_get_i (core-&gt;config, "scr.color");
r_config_set_i (core-&gt;config, "scr.color", 0);
char *ret = r_core_cmd_str (core, c);
r_config_set_i (core-&gt;config, "scr.color", sh);
free (c);
return ret;
}
}
return r_core_cmd_str (core, cmd);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>r_cons_reset</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sandbox_disable</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_file_mkstemp</name> <argument_list>(<argument><expr><literal type="string">"cmd"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pipefd</name> <init>= <expr><call><name>r_cons_pipe_open</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pipefd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sandbox_disable</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>_cmd</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_core_cmd_subst</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pipe_close</name> <argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_file_exists</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sandbox_disable</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>s</name></expr>?</condition><then> <expr><name>s</name></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"slurp %s fails\n"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_file_rm</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_sandbox_disable</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_sandbox_disable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_cmd_strf</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>string</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name> <argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_core_cmd_str</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>static_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>retstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cons_push</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_cons_filter</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>static_str</name> <operator>=</operator> <call><name>r_cons_get_buffer</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retstr</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name>static_str</name></expr>?</condition><then> <expr><name>static_str</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cons_echo</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retstr</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>int</name></type> <name>r_core_cmd_task_sync</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>log</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RCoreTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>tasks</name><operator>.</operator><name>main_task</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cmd_log</name></name> <operator>=</operator> <name>log</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>R_CORE_TASK_STATE_BEFORE_START</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>r_core_task_run_sync</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_ox</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><operator>(</operator><name>RCore</name><operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><literal type="string">"s 0%s"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_cmd_descriptor_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>strcmp</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RCmdDescriptor</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>cmd</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>RCmdDescriptor</name> <operator>*</operator><operator>)</operator><name>b</name><operator>)</operator><operator>-&gt;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_descriptor_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RCmdDescriptor</name> <modifier>*</modifier></type><name>x</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>cmd_descriptors</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_descriptors</name></name></expr></argument>, <argument><expr><name>compare_cmd_descriptor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;cmd_descriptors</argument>, <argument>iter</argument>, <argument>y</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>root_cmd_descriptor</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><name><name>y</name><operator>-&gt;</operator><name>cmd</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>x</name><operator>-&gt;</operator><name>sub</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RCmdDescriptor</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RCmdDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_descriptors</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>sub</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>sub</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Command '%s' is duplicated, please check\n"</literal></expr></argument>, <argument><expr><name><name>y</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>sub</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>core_cmd0_wrapper</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_cmd_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_cmd_callback</name> <argument_list>(<argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>descriptor_init</name>)<parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name><name>cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"!"</literal></expr>, <expr><literal type="string">"run system command"</literal></expr>, <expr><name>cmd_system</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"_"</literal></expr>, <expr><literal type="string">"print last output"</literal></expr>, <expr><name>cmd_last</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"#"</literal></expr>, <expr><literal type="string">"calculate hash"</literal></expr>, <expr><name>cmd_hash</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"alias"</literal></expr>, <expr><name>cmd_alias</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"%"</literal></expr>, <expr><literal type="string">"short version of 'env' command"</literal></expr>, <expr><name>cmd_env</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&amp;"</literal></expr>, <expr><literal type="string">"tasks"</literal></expr>, <expr><name>cmd_tasks</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"("</literal></expr>, <expr><literal type="string">"macro"</literal></expr>, <expr><name>cmd_macro</name></expr>, <expr><name>cmd_macro_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"pointer read/write"</literal></expr>, <expr><name>cmd_pointer</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"-"</literal></expr>, <expr><literal type="string">"open cfg.editor and run script"</literal></expr>, <expr><name>cmd_stdin</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"."</literal></expr>, <expr><literal type="string">"interpret"</literal></expr>, <expr><name>cmd_interpret</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"/"</literal></expr>, <expr><literal type="string">"search kw, pattern aes"</literal></expr>, <expr><name>cmd_search</name></expr>, <expr><name>cmd_search_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"="</literal></expr>, <expr><literal type="string">"io pipe"</literal></expr>, <expr><name>cmd_rap</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"help message"</literal></expr>, <expr><name>cmd_help</name></expr>, <expr><name>cmd_help_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"\\"</literal></expr>, <expr><literal type="string">"alias for =!"</literal></expr>, <expr><name>cmd_rap_run</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"'"</literal></expr>, <expr><literal type="string">"alias for =!"</literal></expr>, <expr><name>cmd_rap_run</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"0x"</literal></expr>, <expr><literal type="string">"alias for s 0x"</literal></expr>, <expr><name>cmd_ox</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"analysis"</literal></expr>, <expr><literal type="string">"analysis"</literal></expr>, <expr><name>cmd_anal</name></expr>, <expr><name>cmd_anal_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"bsize"</literal></expr>, <expr><literal type="string">"change block size"</literal></expr>, <expr><name>cmd_bsize</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"cmp"</literal></expr>, <expr><literal type="string">"compare memory"</literal></expr>, <expr><name>cmd_cmp</name></expr>, <expr><name>cmd_cmp_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Code"</literal></expr>, <expr><literal type="string">"code metadata"</literal></expr>, <expr><name>cmd_meta</name></expr>, <expr><name>cmd_meta_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><literal type="string">"debugger operations"</literal></expr>, <expr><name>cmd_debug</name></expr>, <expr><name>cmd_debug_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"eval"</literal></expr>, <expr><literal type="string">"evaluate configuration variable"</literal></expr>, <expr><name>cmd_eval</name></expr>, <expr><name>cmd_eval_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"flag"</literal></expr>, <expr><literal type="string">"get/set flags"</literal></expr>, <expr><name>cmd_flag</name></expr>, <expr><name>cmd_flag_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"g"</literal></expr>, <expr><literal type="string">"egg manipulation"</literal></expr>, <expr><name>cmd_egg</name></expr>, <expr><name>cmd_egg_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><literal type="string">"get file info"</literal></expr>, <expr><name>cmd_info</name></expr>, <expr><name>cmd_info_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"kuery"</literal></expr>, <expr><literal type="string">"perform sdb query"</literal></expr>, <expr><name>cmd_kuery</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"l"</literal></expr>, <expr><literal type="string">"list files and directories"</literal></expr>, <expr><name>cmd_ls</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"join"</literal></expr>, <expr><literal type="string">"join the contents of the two files"</literal></expr>, <expr><name>cmd_join</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"head"</literal></expr>, <expr><literal type="string">"show the top n number of line in file"</literal></expr>, <expr><name>cmd_head</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"L"</literal></expr>, <expr><literal type="string">"manage dynamically loaded plugins"</literal></expr>, <expr><name>cmd_plugins</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"mount"</literal></expr>, <expr><literal type="string">"mount filesystem"</literal></expr>, <expr><name>cmd_mount</name></expr>, <expr><name>cmd_mount_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"open"</literal></expr>, <expr><literal type="string">"open or map file"</literal></expr>, <expr><name>cmd_open</name></expr>, <expr><name>cmd_open_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"print"</literal></expr>, <expr><literal type="string">"print current block"</literal></expr>, <expr><name>cmd_print</name></expr>, <expr><name>cmd_print_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Project"</literal></expr>, <expr><literal type="string">"project"</literal></expr>, <expr><name>cmd_project</name></expr>, <expr><name>cmd_project_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"quit"</literal></expr>, <expr><literal type="string">"exit program session"</literal></expr>, <expr><name>cmd_quit</name></expr>, <expr><name>cmd_quit_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Q"</literal></expr>, <expr><literal type="string">"alias for q!"</literal></expr>, <expr><name>cmd_Quit</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">":"</literal></expr>, <expr><literal type="string">"long commands starting with :"</literal></expr>, <expr><name>cmd_colon</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"resize"</literal></expr>, <expr><literal type="string">"change file size"</literal></expr>, <expr><name>cmd_resize</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"seek"</literal></expr>, <expr><literal type="string">"seek to an offset"</literal></expr>, <expr><name>cmd_seek</name></expr>, <expr><name>cmd_seek_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"t"</literal></expr>, <expr><literal type="string">"type information (cparse)"</literal></expr>, <expr><name>cmd_type</name></expr>, <expr><name>cmd_type_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Text"</literal></expr>, <expr><literal type="string">"Text log utility"</literal></expr>, <expr><name>cmd_log</name></expr>, <expr><name>cmd_log_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"u"</literal></expr>, <expr><literal type="string">"uname/undo"</literal></expr>, <expr><name>cmd_undo</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;"</literal></expr>, <expr><literal type="string">"pipe into RCons.readChar"</literal></expr>, <expr><name>cmd_pipein</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Visual"</literal></expr>, <expr><literal type="string">"enter visual mode"</literal></expr>, <expr><name>cmd_visual</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"visualPanels"</literal></expr>, <expr><literal type="string">"enter visual mode"</literal></expr>, <expr><name>cmd_panels</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"write"</literal></expr>, <expr><literal type="string">"write bytes"</literal></expr>, <expr><name>cmd_write</name></expr>, <expr><name>cmd_write_init</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"x"</literal></expr>, <expr><literal type="string">"alias for px"</literal></expr>, <expr><name>cmd_hexdump</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"yank"</literal></expr>, <expr><literal type="string">"yank bytes"</literal></expr>, <expr><name>cmd_yank</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"zign"</literal></expr>, <expr><literal type="string">"zignatures"</literal></expr>, <expr><name>cmd_zign</name></expr>, <expr><name>cmd_zign_init</name></expr>}</block></expr>,
}</block></expr></init></decl>;</struct>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name> <operator>=</operator> <call><name>r_cmd_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>user</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <name>core_cmd0_wrapper</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>nullcallback</name></name> <operator>=</operator> <name>r_core_cmd_nullcallback</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name><operator>-&gt;</operator><name>macro</name><operator>.</operator><name>cb_printf</name></name> <operator>=</operator> <operator>(</operator><name>PrintfCallback</name><operator>)</operator><name>r_cons_printf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_cmd_set_data</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cmd_descriptors</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_cmd_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>rcmd</name></name></expr></argument>, <argument><expr><name><name>cmds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmd</name></expr></argument>, <argument><expr><name><name>cmds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>description</name></expr></argument>, <argument><expr><name><name>cmds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cmds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>descriptor_init</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cmds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>descriptor_init</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>$</name></expr></argument>, <argument><expr><name>dollar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>%</operator></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>*</operator></expr></argument>, <argument><expr><name>star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>.</operator></expr></argument>, <argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>=</operator></expr></argument>, <argument><expr><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cmd_descriptor_init</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
