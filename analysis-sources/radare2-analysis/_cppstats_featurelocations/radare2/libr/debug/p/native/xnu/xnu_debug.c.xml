<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\debug\p\native\xnu\xnu_debug.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_userconf.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUGGER</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XNU_USE_EXCTHR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XNU_USE_EXCTHR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_debug.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_asm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_reg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_host.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/host_priv.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_vm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/thread_status.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/vm_statistics.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>task_t</name></type> <name>task_dbg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xnu_debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xnu_threads.c"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_EXCTHR</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xnu_excthreads.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>proc_regionfilename</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>address</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>buffersize</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MACH_HEADER_SIZE</name></cpp:macro> <cpp:value>(64 * 1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_INFO_COUNT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_INFO_LEGACY_COUNT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_INFO_32_COUNT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_INFO_64_COUNT</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_IMAGE_INFO_32_SIZE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DYLD_IMAGE_INFO_64_SIZE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_MAP_TAG_ID</name></cpp:macro> <cpp:value>239</cpp:value></cpp:define> 

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut32</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>info_array_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>info_array</name></decl>;</decl_stmt>
}</block></struct></type> <name>DyldAllImageInfos32</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut32</name></type> <name>image_load_address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>image_file_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>image_file_mod_date</name></decl>;</decl_stmt>
}</block></struct></type> <name>DyldImageInfo32</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut32</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>info_array_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>info_array</name></decl>;</decl_stmt>
}</block></struct></type> <name>DyldAllImageInfos64</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut64</name></type> <name>image_load_address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>image_file_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>image_file_mod_date</name></decl>;</decl_stmt>
}</block></struct></type> <name>DyldImageInfo64</name>;</typedef>


<function><type><specifier>static</specifier> <name>thread_t</name></type> <name>getcurthread</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>thread_t</name></type> <name>th</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>thread_array_t</name></type> <name>threads</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n_threads</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>t</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>task_threads</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>threads</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_threads</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n_threads</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>th</name></expr></argument>, <argument><expr><name>threads</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>th</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>vm_deallocate</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><name>threads</name></expr></argument>, <argument><expr><name>n_threads</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>thread_act_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>th</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>xnu_thread_t</name><modifier>*</modifier></type> <name>get_xnu_thread</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbg</name> <operator>||</operator> <name>tid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>xnu_update_thread_list</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to update thread_list xnu_udpate_thread_list\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>threads</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>&amp;</operator><name>tid</name></expr></argument>,
<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><operator>&amp;</operator><name>thread_find</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>it</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>getcurthread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>threads</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>&amp;</operator><name>tid</name></expr></argument>,
<argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><operator>&amp;</operator><name>thread_find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>it</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Thread not found get_xnu_thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>xnu_thread_t</name> <operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>task_t</name></type> <name>task_for_pid_workaround</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>Pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>host_t</name></type> <name>myhost</name> <init>= <expr><call><name>mach_host_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_port_t</name></type> <name>psDefault</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_port_t</name></type> <name>psDefault_control</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_array_t</name></type> <name>tasks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>numTasks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><call><name>processor_set_default</name> <argument_list>(<argument><expr><name>myhost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>psDefault</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>host_processor_set_priv</name> <argument_list>(<argument><expr><name>myhost</name></expr></argument>, <argument><expr><name>psDefault</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>psDefault_control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"host_processor_set_priv failed with error 0x%x\n"</literal></expr></argument>, <argument><expr><name>kr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>numTasks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>processor_set_tasks</name> <argument_list>(<argument><expr><name>psDefault_control</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tasks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"processor_set_tasks failed with error %x\n"</literal></expr></argument>, <argument><expr><name>kr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>tasks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTasks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pid_for_task</name> <argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name>Pid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>tasks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>vm_deallocate</name> <argument_list>(<argument><expr><name>myhost</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><name>tasks</name></expr></argument>, <argument><expr><name>numTasks</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>task_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>task</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>task_t</name></type> <name>task_for_pid_ios9pangu</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><name>MACH_PORT_NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>host_get_special_port</name> <argument_list>(<argument><expr><call><name>mach_host_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>HOST_LOCAL_NODE</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>task</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_wait</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<return>return <expr><name>R_DEBUG_REASON_UNKNOWN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>__xnu_wait</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>xnu_step</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PT_STEP</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>caddr_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"ptrace-step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"mach-error: %d, %s\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>MACH_ERROR_STRING</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"step failed on task %d for pid %d\n"</literal></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><call><name>getcurthread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>set_trace_bit</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"xnu_step modificy_trace_bit error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>stepping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>task_resume</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_attach</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PT_ATTACHEXC</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PT_ATTACHEXC</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PT_ATTACH</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"ptrace (PT_ATTACH)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>pid</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>xnu_create_exception_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error setting up exception thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xnu_stop</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>pid</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<function><type><name>int</name></type> <name>xnu_detach</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<return>return <expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PT_DETACH</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name></decl>;</decl_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>xnu_restore_exception_ports</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>mach_port_deallocate</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>task_dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"xnu_detach: failed to deallocate port\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>task_dbg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dbg</name><operator>-&gt;</operator><name>threads</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>task_suspend_count</name><parameter_list>(<parameter><decl><type><name>task_t</name></type> <name>task</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>task_basic_info</name></name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>count</name> <init>= <expr><name>TASK_BASIC_INFO_COUNT</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>task_info</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>TASK_BASIC_INFO</name></expr></argument>, <argument><expr><operator>(</operator><name>task_info_t</name><operator>)</operator> <operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"failed to get task info\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>info</name><operator>.</operator><name>suspend_count</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_stop</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"xnu_stop: not implemented\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>suspend_count</name> <init>= <expr><call><name>task_suspend_count</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suspend_count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>suspend_count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>suspend_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><call><name>task_suspend</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"failed to suspend task\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>suspend_count</name> <operator>=</operator> <call><name>task_suspend_count</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>suspend_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_continue</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>XNU_USE_PTRACE</name></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>sig</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>sig</name></expr> </then><else>: <expr><name><name>dbg</name><operator>-&gt;</operator><name>reason</name><operator>.</operator><name>signum</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>task_resume</name> <argument_list>(<argument><expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PT_CONTINUE</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>data</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><call><name>getcurthread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"failed to get thread in xnu_continue\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>stepping</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clear_trace_bit</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error clearing trace bit in xnu_continue\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><call><name>task_resume</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"xnu_continue: Warning: Failed to resume task\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>xnu_reg_profile</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>&amp;</operator> <name>R_SYS_BITS_32</name></expr>)</condition> <block>{<block_content>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reg/darwin-x86.h"</cpp:file></cpp:include>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reg/darwin-x64.h"</cpp:file></cpp:include>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"invalid bit size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__POWERPC__</name></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reg/darwin-ppc.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__APPLE__</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__aarch64__</name> <operator>||</operator> <name>__arm64__</name> <operator>||</operator> <name>__arm__</name><operator>)</operator></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reg/darwin-arm64.h"</cpp:file></cpp:include>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reg/darwin-arm.h"</cpp:file></cpp:include>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unsupported Apple architecture"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>xnu_reg_write</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><call><name>getcurthread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_REG_TYPE_DRX</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name></expr></cpp:if>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>drx</name><operator>.</operator><name>uds</name><operator>.</operator><name>ds32</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>drx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name></expr></cpp:elif>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>drx</name><operator>.</operator><name>uds</name><operator>.</operator><name>ds64</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>drx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm64</name> <operator>||</operator> <name>__aarch64</name></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <name>R_SYS_BITS_64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx64</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx64</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx32</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx32</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm</name> <operator>||</operator> <name>__armv7</name> <operator>||</operator> <name>__arm__</name> <operator>||</operator> <name>__armv7__</name></expr></cpp:elif>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>debug</name><operator>.</operator><name>drx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xnu_thread_set_drx</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__POWERPC__</name></expr></cpp:if>
<cpp:warning>#<cpp:directive>warning</cpp:directive> TODO powerpc support here</cpp:warning>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>gpr</name><operator>.</operator><name>uts</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>gpr</name><operator>.</operator><name>uts</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xnu_thread_set_gpr</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_reg_read</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><call><name>getcurthread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_REG_TYPE_SEG</name></expr>:</case>
<case>case <expr><name>R_REG_TYPE_FLG</name></expr>:</case>
<case>case <expr><name>R_REG_TYPE_GPR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>xnu_thread_get_gpr</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_REG_TYPE_DRX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>xnu_thread_get_drx</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rsz</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>state_size</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rsz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>rsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rsz</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>RDebugMap</name> <modifier>*</modifier></type><name>xnu_map_alloc</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>anywhere</name> <init>= <expr><operator>!</operator><name>VM_FLAGS_ANYWHERE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>anywhere</name> <operator>=</operator> <name>VM_FLAGS_ANYWHERE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>vm_allocate</name> <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>base</name></expr></argument>,
<argument><expr><operator>(</operator><name>vm_size_t</name><operator>)</operator><name>size</name></expr></argument>,
<argument><expr><name>anywhere</name> <operator>|</operator> <call><name>VM_MAKE_TAG</name><argument_list>(<argument><expr><name>DEBUG_MAP_TAG_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"vm_allocate failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return <expr><call><name>r_debug_map_get</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_map_dealloc</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>get_xnu_thread</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>vm_deallocate</name> <argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_size_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"vm_deallocate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>xnu_get_kinfo_proc</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>kinfo_proc</name></name> <modifier>*</modifier></type><name>kp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>CTL_KERN</name></expr>, <expr><name>KERN_PROC</name></expr>, <expr><name>KERN_PROC_PID</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>kpl</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>kinfo_proc</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sysctl</name> <argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>kp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kpl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"sysctl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kpl</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>RDebugInfo</name> <modifier>*</modifier></type><name>xnu_info</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>kinfo_proc</name></name></type> <name>kp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>kinfo_proc_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugInfo</name> <modifier>*</modifier></type><name>rdi</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RDebugInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rdi</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>kinfo_proc_error</name> <operator>=</operator> <call><name>xnu_get_kinfo_proc</name><argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kinfo_proc_error</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error while querying the process info to sysctl\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>R_DBG_PROC_SLEEP</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator> <name><name>kp</name><operator>.</operator><name>kp_eproc</name><operator>.</operator><name>e_ucred</name><operator>.</operator><name>cr_uid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator> <name><name>kp</name><operator>.</operator><name>kp_eproc</name><operator>.</operator><name>e_ucred</name><operator>.</operator><name>cr_gid</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_LIBPROC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>proc_bsdinfo</name></name></type> <name>proc</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>file_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>file_path_len</name></decl>;</decl_stmt>
<expr_stmt><expr><name>file_path_len</name> <operator>=</operator> <call><name>proc_pidpath</name> <argument_list>(<argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>file_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>file_path_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>file_path</name><index>[<expr><name>file_path_len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>exe</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>file_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>proc_pidinfo</name> <argument_list>(<argument><expr><name><name>rdi</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>PROC_PIDTBSDINFO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>, <argument><expr><name>PROC_PIDTBSDINFO_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROC_PIDTBSDINFO_SIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>proc</name><operator>.</operator><name>pbi_flags</name></name> <operator>&amp;</operator> <name>PROC_FLAG_TRACED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>R_DBG_PROC_RUN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>proc</name><operator>.</operator><name>pbi_flags</name></name> <operator>&amp;</operator> <name>PROC_FLAG_INEXIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rdi</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>R_DBG_PROC_STOP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>rdi</name></expr>;</return>
</block_content>}</block></function>
















<function><type><name>RList</name> <modifier>*</modifier></type><name>xnu_thread_list</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name> <operator>||</operator> <name>__aarch_64__</name></expr></condition></ternary></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPU_PC</name></cpp:macro> <cpp:value>(dbg-&gt;bits == R_SYS_BITS_64) ? state.ts_64.__pc : state.ts_32.__pc</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>__POWERPC__</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPU_PC</name></cpp:macro> <cpp:value>state.srr0</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><name>__x86_64__</name> <operator>||</operator> <name>__i386__</name></expr></condition></ternary></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CPU_PC</name></cpp:macro> <cpp:value>(dbg-&gt;bits == R_SYS_BITS_64) ? state.uts.ts64.__rip : state.uts.ts32.__eip</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>R_REG_T</name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>xnu_update_thread_list</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>(</operator><name>RListFree</name><operator>)</operator><operator>&amp;</operator><name>r_debug_pid_free</name></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>dbg-&gt;threads</argument>, <argument>iter</argument>, <argument>thread</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>xnu_thread_get_gpr</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to get gpr registers xnu_thread_list\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>state_size</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>gpr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>gpr</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>R_REG_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>r_debug_pid_new</name> <argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><call><name>getuid</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><name>CPU_PC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static vm_prot_t unix_prot_to_darwin(int prot) {
return ((prot &amp; 1 &lt;&lt; 4) ? VM_PROT_READ : 0 |
(prot &amp; 1 &lt;&lt; 2) ? VM_PROT_WRITE : 0 |
(prot &amp; 1 &lt;&lt; 1) ? VM_PROT_EXECUTE : 0);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>xnu_map_protect</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xwr2rwx</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x&amp;1)&lt;&lt;2) | (x&amp;2) | ((x&amp;4)&gt;&gt;2)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>xnu_perms</name> <init>= <expr><call><name>xwr2rwx</name> <argument_list>(<argument><expr><name>perms</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mach_vm_protect</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_size_t</name><operator>)</operator><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>boolean_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>xnu_perms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"vm_protect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>task_t</name></type> <name>pid_to_task</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>old_pid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>task_dbg</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>old_pid</name> <operator>==</operator> <name>pid</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>task_dbg</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>task_dbg</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>old_pid</name> <operator>!=</operator> <name>pid</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>mach_port_deallocate</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>task_dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"pid_to_task: fail to deallocate port\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>task_for_pid</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>!=</operator> <name>KERN_SUCCESS</name><operator>)</operator> <operator>||</operator> <operator>!</operator><call><name>MACH_PORT_VALID</name> <argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>task</name> <operator>=</operator> <call><name>task_for_pid_workaround</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>task</name> <operator>=</operator> <call><name>task_for_pid_ios9pangu</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>task</name> <operator>!=</operator> <name>MACH_PORT_NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to get task %d for pid %d.\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>task</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Reason: 0x%x: %s\n"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MACH_ERROR_STRING</name> <argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"You probably need to run as root or sign "</literal>
<literal type="string">"the binary.\n Read doc/ios.md || doc/macos.md\n"</literal>
<literal type="string">" make -C binr/radare2 ios-sign || macos-sign\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>old_pid</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
<expr_stmt><expr><name>task_dbg</name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>
<return>return <expr><name>task</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>xnu_get_vmmap_entries_for_pid</name> <parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><name>KERN_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_address_t</name></type> <name>address</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vm_region_submap_info_64</name></name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>nesting_depth</name></decl>;</decl_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <name>VM_REGION_SUBMAP_INFO_COUNT_64</name></expr>;</expr_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>vm_region_recurse_64</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nesting_depth</name></expr></argument>,
<argument><expr><operator>(</operator><name>vm_region_info_64_t</name><operator>)</operator><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>==</operator> <name>KERN_INVALID_ADDRESS</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mach_error</name> <argument_list>(<argument><expr><literal type="string">"vm_region:"</literal></expr></argument>, <argument><expr><name>kr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>is_submap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nesting_depth</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xwr2rwx</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x&amp;1)&lt;&lt;2) | (x&amp;2) | ((x&amp;4)&gt;&gt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMAND_SIZE</name><parameter_list>(<parameter><type><name>segment_count</name></type></parameter>,<parameter><type><name>segment_command_sz</name></type></parameter>,<parameter><type><name>thread_count</name></type></parameter>,<parameter><type><name>tstate_size</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>segment_count * segment_command_sz + thread_count * sizeof (struct thread_command) + tstate_size * thread_count</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <name>void</name></type> <name>get_mach_header_sizes</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>mach_header_sz</name></decl></parameter>, 
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>segment_command_sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__ppc64__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>mach_header_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>mach_header_64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>segment_command_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>segment_command_64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__ppc__</name> <operator>||</operator> <name>__POWERPC__</name></expr></cpp:elif>
<expr_stmt><expr><operator>*</operator><name>mach_header_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>mach_header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>segment_command_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>segment_command</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>cpu_type_t</name></type> <name>xnu_get_cpu_type</name> <parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr><name>CTL_MAXNAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>CTL_MAXNAME</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cpu_type_t</name></type> <name>cpu_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>cpu_type_len</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name>cpu_type_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sysctlnametomib</name> <argument_list>(<argument><expr><literal type="string">"sysctl.proc_cputype"</literal></expr></argument>, <argument><expr><name>mib</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"sysctlnametomib"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mib</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sysctl</name> <argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpu_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpu_type_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"sysctl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cpu_type_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cpu_type</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>cpu_subtype_t</name></type> <name>xnu_get_cpu_subtype</name> <parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cpu_subtype_t</name></type> <name>subtype</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>cpu_subtype_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sysctlbyname</name> <argument_list>(<argument><expr><literal type="string">"hw.cpusubtype"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>subtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>subtype</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xnu_build_corefile_header</name> <parameter_list>(<parameter><decl><type><name>vm_offset_t</name></type> <name>header</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>segment_count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>thread_count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>command_size</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__ppc64__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>mach_header_64</name></name> <modifier>*</modifier></type><name>mh64</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mh64</name> <operator>=</operator> <operator>(</operator>struct <name>mach_header_64</name> <operator>*</operator><operator>)</operator><name>header</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>MH_MAGIC_64</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>cputype</name></name> <operator>=</operator> <call><name>xnu_get_cpu_type</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>cpusubtype</name></name> <operator>=</operator> <call><name>xnu_get_cpu_subtype</name> <argument_list>()</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>filetype</name></name> <operator>=</operator> <name>MH_CORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>ncmds</name></name> <operator>=</operator> <name>segment_count</name> <operator>+</operator> <name>thread_count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>sizeofcmds</name></name> <operator>=</operator> <name>command_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh64</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__ppc__</name> <operator>||</operator> <name>__POWERPC__</name></expr></cpp:elif>
<decl_stmt><decl><type><name><name>struct</name> <name>mach_header</name></name> <modifier>*</modifier></type><name>mh</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mh</name> <operator>=</operator> <operator>(</operator>struct <name>mach_header</name> <operator>*</operator><operator>)</operator><name>header</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>MH_MAGIC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name> <operator>=</operator> <call><name>xnu_get_cpu_type</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>cpusubtype</name></name> <operator>=</operator> <call><name>xnu_get_cpu_subtype</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>filetype</name></name> <operator>=</operator> <name>MH_CORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>ncmds</name></name> <operator>=</operator> <name>segment_count</name> <operator>+</operator> <name>thread_count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mh</name><operator>-&gt;</operator><name>sizeofcmds</name></name> <operator>=</operator> <name>command_size</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>xnu_dealloc_threads</name> <parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>threads</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>thread_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>thread_array_t</name></type> <name>thread_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><name>KERN_SUCCESS</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>task_threads</name> <argument_list>(<argument><expr><name>task_dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"task_threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>threads</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>thread</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>mach_port_deallocate</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>thread</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>vm_deallocate</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><name>thread_list</name></expr></argument>,
<argument><expr><name>thread_count</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>thread_act_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>kr</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>xnu_write_mem_maps_to_buffer</name> <parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>mem_maps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start_offset</name></decl></parameter>,
<parameter><decl><type><name>vm_offset_t</name></type> <name>header</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>header_end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segment_command_sz</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hoffset_out</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>curr_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>foffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>hoffset</name> <init>= <expr><name>header_end</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><name>KERN_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAST_DOWN</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>addr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((type)((uintptr_t)(addr))))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__ppc64__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>segment_command_64</name></name> <modifier>*</modifier></type><name>sc64</name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__ppc__</name> <operator>||</operator> <name>__POWERPC__</name></expr></cpp:elif>
<decl_stmt><decl><type><name><name>struct</name> <name>segment_command</name></name> <modifier>*</modifier></type><name>sc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>mem_maps</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>curr_map</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Writing section from 0x%"</literal><name>PFMT64x</name><literal type="string">" to 0x%"</literal><name>PFMT64x</name><literal type="string">" (%"</literal><name>PFMT64d</name><literal type="string">")\n"</literal></expr></argument>, 
<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>vm_map_offset_t</name></type> <name>vmoffset</name> <init>= <expr><name><name>curr_map</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__ppc64__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>
<expr_stmt><expr><name>sc64</name> <operator>=</operator> <operator>(</operator>struct <name>segment_command_64</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name> <operator>+</operator> <name>hoffset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>LC_SEGMENT_64</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>cmdsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>segment_command_64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>segname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>vmaddr</name></name> <operator>=</operator> <name><name>curr_map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>vmsize</name></name> <operator>=</operator> <name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>maxprot</name></name> <operator>=</operator> <call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>initprot</name></name> <operator>=</operator> <call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc64</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__ppc__</name></expr></cpp:elif>
<expr_stmt><expr><name>sc</name> <operator>=</operator> <operator>(</operator>struct <name>segment_command</name><operator>*</operator><operator>)</operator><operator>(</operator><name>header</name> <operator>+</operator> <name>hoffset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>LC_SEGMENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>cmdsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>segment_command</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>segname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>vmaddr</name></name> <operator>=</operator> <call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>vm_offset_t</name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>vmsize</name></name> <operator>=</operator> <call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>vm_size_t</name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>fileoff</name></name> <operator>=</operator> <call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>ut32</name></expr></argument>, <argument><expr><name>foffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>filesize</name></name> <operator>=</operator> <call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>ut32</name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>maxprot</name></name> <operator>=</operator> <call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>initprot</name></name> <operator>=</operator> <call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sc</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>curr_map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>VM_PROT_READ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mach_vm_protect</name> <argument_list>(<argument><expr><name>task_dbg</name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name><name>curr_map</name><operator>-&gt;</operator><name>perm</name></name> <operator>|</operator> <name>VM_PROT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if ((maxprot &amp; VM_PROT_READ) == VM_PROT_READ &amp;&amp;
(vbr.user_tag != VM_MEMORY_IOKIT)) {
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>curr_map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>VM_PROT_READ</name><operator>)</operator> <operator>==</operator> <name>VM_PROT_READ</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>vm_map_size_t</name></type> <name>tmp_size</name> <init>= <expr><name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>xfer_foffset</name> <init>= <expr><name>foffset</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>tmp_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>vm_map_size_t</name></type> <name>xfer_size</name> <init>= <expr><name>tmp_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_offset_t</name></type> <name>local_address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>local_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xfer_size</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xfer_size</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>mach_vm_read</name> <argument_list>(<argument><expr><name>task_dbg</name></expr></argument>, <argument><expr><name>vmoffset</name></expr></argument>, <argument><expr><name>xfer_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>local_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>xfer_size</name> <operator>!=</operator> <name>local_size</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to read target memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] kr = %d\n"</literal></expr></argument>, <argument><expr><name>kr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] KERN_SUCCESS = %d\n"</literal></expr></argument>, <argument><expr><name>KERN_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] xfer_size = %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>xfer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] local_size = %d\n"</literal></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>error</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__ppc64__</name> <operator>||</operator> <name>__x86_64__</name> <operator>||</operator> <name>__aarch64__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>local_address</name></expr></argument>, <argument><expr><name>xfer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>ut32</name></expr></argument>, <argument><expr><name>local_address</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CAST_DOWN</name> <argument_list>(<argument><expr><name>ut32</name></expr></argument>, <argument><expr><name>xfer_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>error</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to write in the destination\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_size</name> <operator>-=</operator> <name>xfer_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xfer_foffset</name> <operator>+=</operator> <name>xfer_size</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hoffset</name> <operator>+=</operator> <name>segment_command_sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>foffset</name> <operator>+=</operator> <name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vmoffset</name> <operator>+=</operator> <name><name>curr_map</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block>

<label><name>cleanup</name>:</label>
<expr_stmt><expr><operator>*</operator><name>hoffset_out</name> <operator>=</operator> <name>hoffset</name></expr>;</expr_stmt>
<return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>xnu_get_thread_status</name> <parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>thread_t</name></type> <name>thread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flavor</name></decl></parameter>, 
<parameter><decl><type><name>thread_state_t</name></type> <name>tstate</name></decl></parameter>, <parameter><decl><type><name>mach_msg_type_number_t</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>thread_get_state</name> <argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>flavor</name></expr></argument>, <argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xnu_collect_thread_state</name> <parameter_list>(<parameter><decl><type><name>thread_t</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tirp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>coredump_thread_state_flavor_t</name> <modifier>*</modifier></type><name>flavors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tir_t</name> <modifier>*</modifier></type><name>tir</name> <init>= <expr><operator>(</operator><name>tir_t</name> <operator>*</operator><operator>)</operator><name>tirp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>thread_command</name></name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_offset_t</name></type> <name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>hoffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>header</name> <operator>=</operator> <name><name>tir</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hoffset</name> <operator>=</operator> <name><name>tir</name><operator>-&gt;</operator><name>hoffset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flavors</name> <operator>=</operator> <name><name>tir</name><operator>-&gt;</operator><name>flavors</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] tc location: 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>hoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <operator>(</operator>struct <name>thread_command</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name> <operator>+</operator> <name>hoffset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>LC_THREAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>cmdsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>tir</name><operator>-&gt;</operator><name>tstate_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hoffset</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>coredump_nflavors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[DEBUG] %d/%d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>coredump_nflavors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>coredump_thread_state_flavor_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name> <operator>+</operator> <name>hoffset</name><operator>)</operator> <operator>=</operator> <name><name>flavors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hoffset</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>coredump_thread_state_flavor_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xnu_get_thread_status</name> <argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>flavors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flavor</name></expr></argument>,
<argument><expr><operator>(</operator><name>thread_state_t</name><operator>)</operator><operator>(</operator><name>header</name> <operator>+</operator> <name>hoffset</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>flavors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hoffset</name> <operator>+=</operator> <name><name>flavors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>tir</name><operator>-&gt;</operator><name>hoffset</name></name> <operator>=</operator> <name>hoffset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CORE_ALL_SECT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>uid_t</name></type> <name>uidFromPid</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>kinfo_proc</name></name></type> <name>process</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>procBufferSize</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name>process</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name><name>path</name><index>[]</index></name> <init>= <expr><block>{<expr><name>CTL_KERN</name></expr>, <expr><name>KERN_PROC</name></expr>, <expr><name>KERN_PROC_PID</name></expr>, <expr><name>pid</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pathLenth</name> <init>= <expr><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sysctlResult</name> <init>= <expr><call><name>sysctl</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathLenth</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>process</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>procBufferSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sysctlResult</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>procBufferSize</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uid</name> <operator>=</operator> <name><name>process</name><operator>.</operator><name>kp_eproc</name><operator>.</operator><name>e_ucred</name><operator>.</operator><name>cr_uid</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>uid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>xnu_generate_corefile</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tstate_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>segment_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>command_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>mach_header_sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>segment_command_sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>padding_sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hoffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>mem_maps_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_offset_t</name></type> <name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>padding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>threads_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>xnu_thread_t</name> <modifier>*</modifier></type><name>thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>coredump_thread_state_flavor_t</name></type> <name><name>flavors</name><index>[<expr><name>MAX_TSTATE_FLAVORS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tir_t</name></type> <name>tir</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mem_maps_buffer</name> <operator>=</operator> <call><name>r_buf_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_mach_header_sizes</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>mach_header_sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segment_command_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>task_suspend</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>threads_list</name> <operator>=</operator> <call><name>xnu_thread_list</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xnu_dealloc_threads</name> <argument_list>(<argument><expr><name>threads_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>segment_count</name> <operator>=</operator> <call><name>xnu_get_vmmap_entries_for_pid</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>thread_flavor_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flavors</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>thread_flavor_array</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tstate_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>coredump_nflavors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>tstate_size</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>coredump_thread_state_flavor_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
<operator>(</operator><name><name>flavors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>command_size</name> <operator>=</operator> <call><name>COMMAND_SIZE</name> <argument_list>(<argument><expr><name>segment_count</name></expr></argument>,<argument><expr><name>segment_command_sz</name></expr></argument>, 
<argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>threads_list</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tstate_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header_size</name> <operator>=</operator> <name>command_size</name> <operator>+</operator> <name>mach_header_sz</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>vm_offset_t</name><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xnu_build_corefile_header</name> <argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>segment_count</name></expr></argument>,
<argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>threads_list</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command_size</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dbg</name><operator>-&gt;</operator><name>maps</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"There are not loaded maps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xnu_write_mem_maps_to_buffer</name> <argument_list>(<argument><expr><name>mem_maps_buffer</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>, <argument><expr><call><name>round_page</name> <argument_list>(<argument><expr><name>header_size</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header</name></expr></argument>, <argument><expr><name>mach_header_sz</name></expr></argument>, <argument><expr><name>segment_command_sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hoffset</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"There was an error while writing the memory maps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tir</name><operator>.</operator><name>header</name></name> <operator>=</operator> <name>header</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tir</name><operator>.</operator><name>hoffset</name></name> <operator>=</operator> <name>hoffset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tir</name><operator>.</operator><name>flavors</name></name> <operator>=</operator> <name>flavors</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tir</name><operator>.</operator><name>tstate_size</name></name> <operator>=</operator> <name>tstate_size</name></expr>;</expr_stmt>

<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>threads_list</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>thread</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>xnu_collect_thread_state</name> <argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>xnu_dealloc_threads</name> <argument_list>(<argument><expr><name>threads_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>header</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>padding_sz</name> <operator>=</operator> <call><name>round_page</name> <argument_list>(<argument><expr><name>header_size</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>header_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>padding</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>padding_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>padding</name></expr></argument>, <argument><expr><name>padding_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_buf_append_buf</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>mem_maps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name>mem_maps_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>threads_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><name>error</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RDebugPid</name> <modifier>*</modifier></type><name>xnu_get_pid</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>psnamelen</name></decl>, <decl><type ref="prev"/><name>foo</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>, <decl><type ref="prev"/><name><name>mib</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>argmax</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curr_arg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start_args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>procargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>psname</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

mib[0] = CTL_KERN;
mib[1] = KERN_ARGMAX;
size = sizeof(argmax);
if (sysctl (mib, 2, &amp;argmax, &amp;size, NULL, 0) == -1) {
eprintf ("sysctl() error on getting argmax\n");
return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>uid</name> <operator>=</operator> <call><name>uidFromPid</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>procargs</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name> <argument_list>(<argument><expr><name>argmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>procargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"getcmdargs(): insufficient memory for procargs %d\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>argmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CTL_KERN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>KERN_PROCARGS2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>argmax</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>procargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sysctl</name> <argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>procargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>EINVAL</name> <operator>==</operator> <name>errno</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>procargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"sysctl(): unspecified sysctl error - %i\n"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>procargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>, <argument><expr><name>procargs</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter_args</name> <operator>=</operator> <name>procargs</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>end_args</name> <operator>=</operator> <operator>&amp;</operator><name><name>procargs</name><index>[<expr><name>size</name> <operator>-</operator> <literal type="number">30</literal></expr>]</index></name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>iter_args</name> <operator>&gt;=</operator> <name>end_args</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"getcmdargs(): argument length mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>procargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
while (iter_args &lt; end_args &amp;&amp; *iter_args != '\0') { iter_args++; }
while (iter_args &lt; end_args &amp;&amp; *iter_args == '\0') { iter_args++; }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>iter_args</name> <operator>==</operator> <name>end_args</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>procargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curr_arg</name> <operator>=</operator> <name>iter_args</name></expr>;</expr_stmt>
<expr_stmt><expr><name>start_args</name> <operator>=</operator> <name>iter_args</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>foo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>psname</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>psnamelen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>iter_args</name> <argument_list type="generic">&lt; <argument><expr><name>end_args</name> <operator>&amp;&amp;</operator> <name>nargs</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>iter_args</name><operator>++</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>alen</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>curr_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>foo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>psname</name></expr></argument>, <argument><expr><name>curr_arg</name></expr></argument>, <argument><expr><name>alen</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>foo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>psname</name><index>[<expr><name>psnamelen</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>psname</name> <operator>+</operator> <name>psnamelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curr_arg</name></expr></argument>, <argument><expr><name>alen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>psnamelen</name> <operator>+=</operator> <name>alen</name></expr>;</expr_stmt>


<expr_stmt><expr><name>curr_arg</name> <operator>=</operator> <name>iter_args</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nargs</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>





<if_stmt><if>if <condition>(<expr><name>curr_arg</name> <operator>==</operator> <name>start_args</name> <operator>||</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>psname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>procargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>r_debug_pid_new</name> <argument_list>(<argument><expr><name>psname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></function>

<decl_stmt><decl><type><name>kern_return_t</name></type> <name>mach_vm_region_recurse</name> <argument_list>(
<argument><expr><name>vm_map_t</name> <name>target_task</name></expr></argument>,
<argument><expr><name>mach_vm_address_t</name> <operator>*</operator><name>address</name></expr></argument>,
<argument><expr><name>mach_vm_size_t</name> <operator>*</operator><name>size</name></expr></argument>,
<argument><expr><name>natural_t</name> <operator>*</operator><name>nesting_depth</name></expr></argument>,
<argument><expr><name>vm_region_recurse_info_t</name> <name>info</name></expr></argument>,
<argument><expr><name>mach_msg_type_number_t</name> <operator>*</operator><name>infoCnt</name></expr></argument>
)</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>unparse_inheritance</name> <parameter_list>(<parameter><decl><type><name>vm_inherit_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VM_INHERIT_SHARE</name></expr>:</case> <return>return <expr><literal type="string">"share"</literal></expr>;</return>
<case>case <expr><name>VM_INHERIT_COPY</name></expr>:</case> <return>return <expr><literal type="string">"copy"</literal></expr>;</return>
<case>case <expr><name>VM_INHERIT_NONE</name></expr>:</case> <return>return <expr><literal type="string">"none"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"???"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>KERNEL_LOWER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDR</name></cpp:macro> <cpp:value>"%8x"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_SIZE</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_OFFSET</name></cpp:macro> <cpp:value>0x201000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KERNEL_LOWER</name></cpp:macro> <cpp:value>0x80000000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>vm_address_t</name></type> <name>get_kernel_base</name><parameter_list>(<parameter><decl><type><name>task_t</name></type> <name>___task</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>info_count</name> <init>= <expr><name>VM_REGION_SUBMAP_INFO_COUNT_64</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vm_region_submap_info_data_64_t</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>naddr</name></decl>, <decl><type ref="prev"/><name>addr</name> <init>= <expr><name>KERNEL_LOWER</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>task_for_pid</name> <argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>count</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>naddr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>vm_region_recurse_64</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><operator>(</operator><name>vm_address_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>naddr</name></expr></argument>,
<argument><expr><operator>(</operator><name>vm_size_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>,
<argument><expr><operator>(</operator><name>vm_region_info_t</name><operator>)</operator><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>naddr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" size 0x%08"</literal><name>PFMT64x</name><literal type="string">" perm 0x%x\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>size</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>max_protection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>addr</name> <operator>+</operator> <name>IMAGE_OFFSET</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>mach_port_deallocate</name> <argument_list>(<argument><expr><call><name>mach_task_self</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"get_kernel_base: leaking kernel port\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>vm_address_t</name><operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mach0_size</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">4096</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>xnu_map_free</name><parameter_list>(<parameter><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>xnu_dbg_modules</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__POWERPC__</name></expr></cpp:if>
<cpp:warning>#<cpp:directive>warning</cpp:directive> TODO: xnu_dbg_modules not supported</cpp:warning>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>task_dyld_info</name></name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>info_array_count</name></decl>, <decl><type ref="prev"/><name>info_array_size</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>info_array_address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>info_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>file_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name>TASK_DYLD_INFO_COUNT</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>file_path_address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>mr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>kr</name> <operator>=</operator> <call><name>task_info</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>TASK_DYLD_INFO</name></expr></argument>, <argument><expr><operator>(</operator><name>task_info_t</name><operator>)</operator> <operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>all_image_info_format</name></name> <operator>==</operator> <name>TASK_DYLD_ALL_IMAGE_INFO_64</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DyldAllImageInfos64</name></type> <name>all_infos</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>all_image_info_addr</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>all_infos</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DyldAllImageInfos64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_count</name> <operator>=</operator> <name><name>all_infos</name><operator>.</operator><name>info_array_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_size</name> <operator>=</operator> <name>info_array_count</name> <operator>*</operator> <name>DYLD_IMAGE_INFO_64_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_address</name> <operator>=</operator> <name><name>all_infos</name><operator>.</operator><name>info_array</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>DyldAllImageInfos32</name></type> <name>all_info</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>all_image_info_addr</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>all_info</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DyldAllImageInfos32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_count</name> <operator>=</operator> <name><name>all_info</name><operator>.</operator><name>info_array_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_size</name> <operator>=</operator> <name>info_array_count</name> <operator>*</operator> <name>DYLD_IMAGE_INFO_32_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array_address</name> <operator>=</operator> <name><name>all_info</name><operator>.</operator><name>info_array</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>info_array_address</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>info_array_size</name> <operator>=</operator> <call><name>R_ABS</name> <argument_list>(<argument><expr><name>info_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>info_array</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>info_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>info_array</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate info_array_size %d\n"</literal></expr></argument>,
<argument><expr><name>info_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>info_array_address</name></expr></argument>, <argument><expr><name>info_array</name></expr></argument>, <argument><expr><name>info_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>xnu_map_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>info_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>info_array_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>all_image_info_format</name></name> <operator>==</operator> <name>TASK_DYLD_ALL_IMAGE_INFO_64</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DyldImageInfo64</name> <modifier>*</modifier></type> <name>info</name> <init>= <expr><name>info_array</name> <operator>+</operator> \
<operator>(</operator><name>i</name> <operator>*</operator> <name>DYLD_IMAGE_INFO_64_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>image_load_address</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>file_path_address</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>image_file_path</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>DyldImageInfo32</name> <modifier>*</modifier></type> <name>info</name> <init>= <expr><name>info_array</name> <operator>+</operator> \
<operator>(</operator><name>i</name> <operator>*</operator> <name>DYLD_IMAGE_INFO_32_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>image_load_address</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>file_path_address</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>image_file_path</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>file_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>file_path_address</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>file_path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mach0_size</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mr</name> <operator>=</operator> <call><name>r_debug_map_new</name> <argument_list>(<argument><expr><name>file_path</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create r_debug_map_new\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>file_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>mr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>info_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RDebugMap</name> <modifier>*</modifier></type><name>moduleAt</name><parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>map</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RDebugMap</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RDebugMap</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RDebugMap</name> <modifier>*</modifier></type><name>r_debug_map_clone</name> <parameter_list>(<parameter><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>R_NEWCOPY</name> <argument_list>(<argument><expr><name>RDebugMap</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>map</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RList</name> <modifier>*</modifier></type><name>xnu_dbg_maps</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>only_modules</name></decl></parameter>)</parameter_list> <block>{<block_content>



<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>module_name</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_vm_address_t</name></type> <name>address</name> <init>= <expr><name>MACH_VM_MIN_ADDRESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_vm_size_t</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>mach_vm_size_t</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_vm_size_t</name></type> <name>osize</name> <init>= <expr><operator>(</operator><name>mach_vm_size_t</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>natural_t</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tid</name> <init>= <expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>task_t</name></type> <name>task</name> <init>= <expr><call><name>pid_to_task</name> <argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>mr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>task</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>modules</name> <init>= <expr><call><name>xnu_dbg_modules</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>only_modules</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>modules</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__arm64__</name> <operator>||</operator> <name>__aarch64__</name></expr></cpp:if>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>osize</name> <operator>=</operator> <literal type="number">16384</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>osize</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if (dbg-&gt;pid == 0) {
vm_address_t base = get_kernel_base (task);
eprintf ("Kernel Base Address: 0x%"PFMT64x"\n", (ut64)base);
return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>(</operator><name>RListFree</name><operator>)</operator><name>xnu_map_free</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>vm_region_submap_info_64</name></name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>info_count</name> <init>= <expr><name>VM_REGION_SUBMAP_INFO_COUNT_64</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>kern_return_t</name></type> <name>kr</name> <init>= <expr><call><name>mach_vm_region_recurse</name> <argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>,
<argument><expr><operator>(</operator><name>vm_region_recurse_info_t</name><operator>)</operator> <operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>kr</name> <operator>!=</operator> <name>KERN_SUCCESS</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>is_submap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>module_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__POWERPC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>proc_regionfilename</name> <argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>module_name</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>module_name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>module_name</name><index>[<expr><name>ret</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>maxperm</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>depthstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>depthstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>depthstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>depthstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>max_protection</name></name> <operator>!=</operator> <name><name>info</name><operator>.</operator><name>protection</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>maxperm</name></expr></argument>, <argument><expr><call><name>r_str_rwx_i</name> <argument_list>(<argument><expr><call><name>xwr2rwx</name> <argument_list>(
<argument><expr><name><name>info</name><operator>.</operator><name>max_protection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>maxperm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%02x_%s%s%s%s%s%s%s%s"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>unparse_inheritance</name> <argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>inheritance</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>info</name><operator>.</operator><name>user_tag</name></name></expr>?</condition><then> <expr><literal type="string">"_user"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>info</name><operator>.</operator><name>is_submap</name></name></expr>?</condition><then> <expr><literal type="string">"_sub"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>info</name><operator>.</operator><name>is_submap</name></name></expr> ?</condition><then> <expr><literal type="string">"_submap"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>module_name</name></expr></argument>, <argument><expr><name>maxperm</name></expr></argument>, <argument><expr><name>depthstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mr</name> <operator>=</operator> <call><name>r_debug_map_new</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>address</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>protection</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>xwr2rwx</name> <argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>max_protection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create r_debug_map_new\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>rdm</name> <init>= <expr><call><name>moduleAt</name> <argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rdm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>rdm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>module_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>module_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name> <init>= <expr><call><name>r_str_lchr</name> <argument_list>(<argument><expr><name><name>mr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name><name>mr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mr</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>mr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"size error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>modules</argument>, <argument>iter</argument>, <argument>m</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>m2</name> <init>= <expr><call><name>r_debug_map_clone</name> <argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m2</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>m2</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>m2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>m2</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>m2</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name> <init>= <expr><call><name>r_str_lchr</name> <argument_list>(<argument><expr><name><name>m2</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name><name>m2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function></block_content></block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
