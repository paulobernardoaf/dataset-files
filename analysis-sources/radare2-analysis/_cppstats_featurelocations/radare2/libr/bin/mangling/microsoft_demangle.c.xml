<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\bin\mangling\microsoft_demangle.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"microsoft_demangle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cons.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_R_LIST_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_list.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MICROSOFT_NAME_LEN</name></cpp:macro> <cpp:value>(256)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MICROSOFR_CLASS_NAMESPACE_LEN</name></cpp:macro> <cpp:value>(256)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMPOSSIBLE_LEN</name></cpp:macro> <cpp:value>(MICROSOFT_NAME_LEN + MICROSOFR_CLASS_NAMESPACE_LEN)</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>abbr_types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>abbr_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><enum>enum <name>EObjectType</name> <block>{
<decl><name>eObjectTypeStaticClassMember</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>eObjectTypeGlobal</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>eObjectTypeMax</name> <init>= <expr><literal type="number">99</literal></expr></init></decl>
}</block></enum></type> <name>EObjectType</name>;</typedef>




<typedef>typedef <type><enum>enum <name>ETCStateMachineErr</name> <block>{
<decl><name>eTCStateMachineErrOK</name></decl>,
<decl><name>eTCStateMachineErrUncorrectTypeCode</name></decl>,
<decl><name>eTCStateMachineErrUnsupportedTypeCode</name></decl>,
<decl><name>eTCStateMachineErrAlloc</name></decl>,
<decl><name>eTCStateMachineErrMax</name></decl>
}</block></enum></type> <name>ETCStateMachineErr</name>;</typedef>

<typedef>typedef <type><enum>enum <name>ETCState</name> <block>{ 
<decl><name>eTCStateStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>eTCStateEnd</name></decl>, <decl><name>eTCStateH</name></decl>, <decl><name>eTCStateX</name></decl>, <decl><name>eTCStateN</name></decl>, <decl><name>eTCStateD</name></decl>,
<decl><name>eTCStateC</name></decl>, <decl><name>eTCStateE</name></decl>, <decl><name>eTCStateF</name></decl>, <decl><name>eTCStateG</name></decl>, <decl><name>eTCStateI</name></decl>, <decl><name>eTCStateJ</name></decl>, <decl><name>eTCStateK</name></decl>,
<decl><name>eTCStateM</name></decl>, <decl><name>eTCStateZ</name></decl>, <decl><name>eTCState_</name></decl>, <decl><name>eTCStateT</name></decl>, <decl><name>eTCStateU</name></decl>, <decl><name>eTCStateW</name></decl>, <decl><name>eTCStateV</name></decl>,
<decl><name>eTCStateO</name></decl>, <decl><name>eTCStateS</name></decl>, <decl><name>eTCStateP</name></decl>, <decl><name>eTCStateR</name></decl>, <decl><name>eTCStateQ</name></decl>, <decl><name>eTCStateA</name></decl>, <decl><name>eTCStateMax</name></decl>
}</block></enum></type> <name>ETCState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>STypeCodeStr</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type_str_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_pos</name></decl>;</decl_stmt>
}</block></struct></type> <name>STypeCodeStr</name>;</typedef>

<struct_decl>struct <name>SStateInfo</name>;</struct_decl>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>state_func</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>SStateInfo</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>SStateInfo</name> <block>{
<decl_stmt><decl><type><name>ETCState</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff_for_parsing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>amount_of_read_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ETCStateMachineErr</name></type> <name>err</name></decl>;</decl_stmt>
}</block></struct></type> <name>SStateInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SStrInfo</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>SStrInfo</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_STATE_ACTION</name><parameter_list>(<parameter><type><name>action</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void tc_state_##action(SStateInfo *state, STypeCodeStr *type_code_str);</cpp:value></cpp:define>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>start</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>end</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>X</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>N</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>D</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>C</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>E</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>F</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>G</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>H</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>I</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>J</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>K</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>M</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>Z</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>_</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>T</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>U</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>W</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>V</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>O</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>S</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>P</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>R</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>Q</argument>)</argument_list></macro>
<macro><name>DECL_STATE_ACTION</name><argument_list>(<argument>A</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DECL_STATE_ACTION</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME</name><parameter_list>(<parameter><type><name>action</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tc_state_##action</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>state_func</name> <specifier>const</specifier></type> <name><name>state_table</name><index>[<expr><name>eTCStateMax</name></expr>]</index></name> <init>= <expr><block>{
<expr><call><name>NAME</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr> , <expr><call><name>NAME</name><argument_list>(<argument><expr><name>H</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NAME</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>J</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>_</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NAME</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>W</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>O</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NAME</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NAME</name><argument_list>(<argument><expr><name>Q</name></expr></argument>)</argument_list></call></expr>, <macro><name>NAME</name><argument_list>(<argument>A</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NAME</name></cpp:undef>








<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_state_struct</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff_for_parsing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EDemanglerErr</name></type> <name>get_type_code_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>amount_of_read_chars</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str_type_code</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_type_code_str_struct</name><parameter_list>(<parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_coder_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_type_code_str_struct</name><parameter_list>(<parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_template</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>str_info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_num</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_state</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state_info</name></decl></parameter>, <parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>state_table</name><index>[<expr><name><name>state_info</name><operator>-&gt;</operator><name>state</name></name></expr>]</index></name><operator>(</operator><name>state_info</name><operator>,</operator> <name>type_code_str</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>copy_string</name><parameter_list>(<parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str_for_copy</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>copy_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>str_for_copy_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>copy_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>str_for_copy</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>str_for_copy</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>copy_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>free_space</name> <init>= <expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str_len</name></name> <operator>-</operator> <name><name>type_code_str</name><operator>-&gt;</operator><name>curr_pos</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str_for_copy_len</name> <operator>&gt;</operator> <name>free_space</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>free_space</name> <operator>&gt;</operator> <name>str_for_copy_len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str_len</name></name> <operator>+</operator> <operator>(</operator><name>str_for_copy_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newlen</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>copy_string_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str_len</name></name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type_str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>copy_string_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name> <operator>=</operator> <name>type_str</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>copy_string_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name> <operator>+</operator> <name><name>type_code_str</name><operator>-&gt;</operator><name>curr_pos</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_for_copy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>str_for_copy</name></expr></argument>, <argument><expr><name>str_for_copy_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>str_for_copy_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>curr_pos</name></name> <operator>+=</operator> <name>str_for_copy_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name><index>[<expr><name><name>type_code_str</name><operator>-&gt;</operator><name>curr_pos</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>copy_string_err</name>:</label>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>get_template_params</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>amount_of_read_chars</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str_type_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name> <init>= <expr><name>eDemanglerErrOK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SStateInfo</name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_state_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>template_param</name><index>[]</index></name> <init>= <expr><literal type="string">"template-parameter-"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>.</operator><name>amount_of_read_chars</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>buff_for_parsing</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_str_newf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>template_param</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>get_template_params_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>amount_of_read_chars</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>buff_for_parsing</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>signed_a</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>signed_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>signed_b</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%sE%d"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>signed_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_str_newf</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>template_param</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"F"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>signed_a</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signed_b</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"{%d, %d}"</literal></expr></argument>, <argument><expr><name>signed_a</name></expr></argument>, <argument><expr><name>signed_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"G"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name>c</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>signed_a</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signed_b</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signed_c</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"{%d, %d, %d}"</literal></expr></argument>, <argument><expr><name>signed_a</name></expr></argument>, <argument><expr><name>signed_b</name></expr></argument>, <argument><expr><name>signed_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"H"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"I"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"{%s, %s}"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"J"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&amp;&amp;</operator> <name>c</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"{%s, %s, %s}"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"Q"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>get_num</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_str_newf</name><argument_list>(<argument><expr><literal type="string">"non-type-%s%s"</literal></expr></argument>, <argument><expr><name>template_param</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUnsupportedMangling</name></expr>;</expr_stmt>
<goto>goto <name>get_template_params_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>str_type_code</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>amount_of_read_chars</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>amount_of_read_chars</name></name></expr>;</expr_stmt>

<label><name>get_template_params_err</name>:</label>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_operator_code</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>names_l</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_OPERATOR_CODE</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ str_info = (SStrInfo *) malloc (sizeof(SStrInfo)); if (!str_info) break; str_info-&gt;len = strlen (str); str_info-&gt;str_ptr = str; r_list_append (names_l, str_info); }</cpp:value></cpp:define>






<decl_stmt><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>str_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>read_len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><operator>*</operator><operator>++</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'0'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"~destructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'3'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'4'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&gt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'6'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&lt;&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'8'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator=="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'9'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator!="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator #{return_type}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator-&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'E'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'J'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator-&gt;*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'L'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator%"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'M'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&lt;="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'O'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'P'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&gt;="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'Q'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'R'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator~"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'T'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'U'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'W'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator||"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'X'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator*="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'Y'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator+="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'Z'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name><argument_list>(<argument><expr><literal type="string">"operator-="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>str_info</name> <operator>=</operator> <operator>(</operator><name>SStrInfo</name> <operator>*</operator><operator>)</operator><call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str_info</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>get_template</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>, <argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>read_len</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'_'</literal></expr>:</case>
<switch>switch <condition>(<expr><operator>*</operator><operator>++</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'0'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator/="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator%="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator&gt;&gt;="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'3'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator&lt;&lt;="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'4'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator&amp;="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator|="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'6'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator^="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vftable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'8'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vbtable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'9'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vcall"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"typeof"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"local_static_guard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vbase_dtor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'E'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vector_dtor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"scalar_dtor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vector_ctor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vector_dtor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'J'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"vector_vbase_ctor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'L'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"eh_vector_ctor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'M'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"eh_vector_dtor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"eh_vector_vbase_ctor_iter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'O'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"copy_ctor_closure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"local_vftable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'T'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"local_vftable_ctor_closure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'U'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator new[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"operator delete[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'X'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"placement_new_closure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'Y'</literal></expr>:</case> <expr_stmt><expr><call><name>SET_OPERATOR_CODE</name> <argument_list>(<argument><expr><literal type="string">"placement_delete_closure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>read_len</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>read_len</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>read_len</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_OPERATOR_CODE</name></cpp:undef>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_template</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>str_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_type_code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STypeCodeStr</name></type> <name>type_code_str</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_type_code_str_struct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>get_template_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>names_l</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>names_l</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>get_operator_code</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_list_head</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>copy_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><name><name>name</name><operator>-&gt;</operator><name>str_ptr</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>get_template_err</name>;</goto>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>tmp</name> <operator>-</operator> <name>buf</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_type_code_string</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str_type_code</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>get_template_params</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str_type_code</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>get_template_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><name>str_type_code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str_type_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>get_template_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str_info</name><operator>-&gt;</operator><name>str_ptr</name></name> <operator>=</operator> <name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str_info</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>type_code_str</name><operator>.</operator><name>curr_pos</name></name></expr>;</expr_stmt>

<label><name>get_template_err</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
it = r_list_iterator (abbr_names);
r_list_foreach (abbr_names, it, tmp) {
R_FREE (tmp);
}
r_list_free (abbr_names);
abbr_names = saved_abbr_names; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>int</name></type> <name>get_namespace_and_name</name><parameter_list>( <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>amount_of_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curr_pos</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_pos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>names_l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>str_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>read_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>names_l</name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>get_operator_code</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name>read_len</name> <operator>+=</operator> <name>res</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>len</name> <operator>=</operator> <name>curr_pos</name> <operator>-</operator> <name>prev_pos</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>get_namespace_and_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>curr_pos</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>curr_pos</name> <operator>-</operator> <name>prev_pos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>prev_pos</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>curr_pos</name><operator>)</operator> <operator>==</operator> <literal type="char">'@'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>len</name> <operator>&gt;=</operator> <name>MICROSOFT_NAME_LEN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>get_namespace_and_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">'?'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>tmp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'$'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>str_info</name> <operator>=</operator> <operator>(</operator><name>SStrInfo</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>get_template</name> <argument_list>(<argument><expr><name>tmp</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>get_namespace_and_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>, <argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prev_pos</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>read_len</name> <operator>+=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>


<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>abbr_names</name></expr></argument>, <argument><expr><operator>*</operator><name>tmp</name> <operator>-</operator> <literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>get_namespace_and_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>prev_pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>abbr_names</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>str_info</name> <operator>=</operator> <operator>(</operator><name>SStrInfo</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SStrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str_info</name><operator>-&gt;</operator><name>str_ptr</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str_info</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>, <argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>read_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>prev_pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <name>curr_pos</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>prev_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <name>curr_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>curr_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curr_pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>read_len</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<label><name>get_namespace_and_name_err</name>:</label>
<expr_stmt><expr><name>tmp_len</name> <operator>=</operator> <call><name>r_list_length</name><argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>amount_of_names</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>amount_of_names</name> <operator>=</operator> <name>tmp_len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_iterator</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach_prev</name> <argument_list>(<argument>names_l</argument>, <argument>it</argument>, <argument>str_info</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name><argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><name><name>str_info</name><operator>-&gt;</operator><name>str_ptr</name></name></expr></argument>, <argument><expr><name><name>str_info</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>tmp_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name><argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">"::"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>names_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>read_len</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_U</name></cpp:macro> <cpp:value>'U'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_X</name></cpp:macro> <cpp:value>'X'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_D</name></cpp:macro> <cpp:value>'D'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_C</name></cpp:macro> <cpp:value>'C'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_E</name></cpp:macro> <cpp:value>'E'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_F</name></cpp:macro> <cpp:value>'F'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_G</name></cpp:macro> <cpp:value>'G'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_H</name></cpp:macro> <cpp:value>'H'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_I</name></cpp:macro> <cpp:value>'I'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_J</name></cpp:macro> <cpp:value>'J'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_K</name></cpp:macro> <cpp:value>'K'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_M</name></cpp:macro> <cpp:value>'M'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_N</name></cpp:macro> <cpp:value>'N'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_T</name></cpp:macro> <cpp:value>'T'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_Z</name></cpp:macro> <cpp:value>'Z'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_W</name></cpp:macro> <cpp:value>'W'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_V</name></cpp:macro> <cpp:value>'V'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_O</name></cpp:macro> <cpp:value>'O'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_S</name></cpp:macro> <cpp:value>'S'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_P</name></cpp:macro> <cpp:value>'P'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_R</name></cpp:macro> <cpp:value>'R'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_Q</name></cpp:macro> <cpp:value>'Q'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED_A</name></cpp:macro> <cpp:value>'A'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SINGLEQUOTED__</name></cpp:macro> <cpp:value>'_'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_WITH_QUOTES</name><parameter_list>(<parameter><type><name>letter</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SINGLEQUOTED_##letter)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_STATE_ACTION</name><parameter_list>(<parameter><type><name>action</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void tc_state_##action(SStateInfo *state, STypeCodeStr *type_code_str)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GO_TO_NEXT_STATE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>, <parameter><type><name>new_state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ (state)-&gt;amount_of_read_chars++; (state)-&gt;buff_for_parsing++; (state)-&gt;state = eTCStateEnd; }</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_LETTER_ACTIION</name><parameter_list>(<parameter><type><name>action</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void tc_state_##action(SStateInfo *state, STypeCodeStr *type_code_str) { if (copy_string(type_code_str, type, 0) == 0) { state-&gt;err = eTCStateMachineErrAlloc; } state-&gt;state = eTCStateEnd; }</cpp:value></cpp:define> 








<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>X</argument>, <argument><literal type="string">"void"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>D</argument>, <argument><literal type="string">"char"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>C</argument>, <argument><literal type="string">"signed char"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>E</argument>, <argument><literal type="string">"unsigned char"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>F</argument>, <argument><literal type="string">"short int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>G</argument>, <argument><literal type="string">"unsigned short int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>H</argument>, <argument><literal type="string">"int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>I</argument>, <argument><literal type="string">"unsigned int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>J</argument>, <argument><literal type="string">"long int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>K</argument>, <argument><literal type="string">"unsigned long int"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>M</argument>, <argument><literal type="string">"float"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>N</argument>, <argument><literal type="string">"double"</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>Z</argument>, <argument><literal type="string">"varargs ..."</literal></argument>)</argument_list></macro>
<macro><name>ONE_LETTER_ACTIION</name><argument_list>(<argument>O</argument>, <argument><literal type="string">"long double"</literal></argument>)</argument_list></macro>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>_</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCESS_CASE</name><parameter_list>(<parameter><type><name>letter</name></type></parameter>, <parameter><type><name>type_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case CHAR_WITH_QUOTES(letter): copy_string(type_code_str, type_str, 0); break;</cpp:value></cpp:define>




<switch>switch<condition>(<expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>J</argument>, <argument><literal type="string">"long long(__int64)"</literal></argument>)</argument_list></macro>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>K</argument>, <argument><literal type="string">"unsigned long long(unsigned __int64)"</literal></argument>)</argument_list></macro>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>T</argument>, <argument><literal type="string">"long double(80 bit precision)"</literal></argument>)</argument_list></macro>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>Z</argument>, <argument><literal type="string">"long double(64 bit precision)"</literal></argument>)</argument_list></macro>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>W</argument>, <argument><literal type="string">"wchar_t"</literal></argument>)</argument_list></macro>
<macro><name>PROCESS_CASE</name> <argument_list>(<argument>N</argument>, <argument><literal type="string">"bool"</literal></argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUncorrectTypeCode</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PROCESS_CASE</name></cpp:undef>
</block_content>}</block>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_USER_DEF_TYPE_NAME</name><parameter_list>(<parameter><type><name>data_struct_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ copy_string (type_code_str, data_struct_str, 0); check_len = get_namespace_and_name (state-&gt;buff_for_parsing, type_code_str, 0); if (check_len) { state-&gt;amount_of_read_chars += check_len + 1; state-&gt;buff_for_parsing += check_len + 1; } else { state-&gt;err = eTCStateMachineErrUncorrectTypeCode; } }</cpp:value></cpp:define>












<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>T</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCESS_CASE</name><parameter_list>(<parameter><type><name>case_string</name></type></parameter>, <parameter><type><name>type_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ check_len = strlen (case_string); if ((check_len &lt; buff_len) &amp;&amp; (strncmp (state-&gt;buff_for_parsing, case_string, check_len) == 0)) { copy_string (type_code_str, type_str, 0); state-&gt;buff_for_parsing += check_len; state-&gt;amount_of_read_chars += check_len; return; } }</cpp:value></cpp:define>










<decl_stmt><decl><type><name>int</name></type> <name>buff_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>check_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m64@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m64"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m128@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m128"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m128i@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m128i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m256@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m256"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m256i@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m256i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m512@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m512"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m512i@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m512i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_USER_DEF_TYPE_NAME</name> <argument_list>(<argument><expr><literal type="string">"union "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PROCESS_CASE</name></cpp:undef>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>U</argument>)</argument_list></macro>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCESS_CASE</name><parameter_list>(<parameter><type><name>case_string</name></type></parameter>, <parameter><type><name>type_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ check_len = strlen (case_string); if ((check_len &lt; buff_len) &amp;&amp; (strncmp (state-&gt;buff_for_parsing, case_string, check_len) == 0)) { copy_string (type_code_str, type_str, 0); state-&gt;amount_of_read_chars += check_len; state-&gt;buff_for_parsing += check_len; return; } }</cpp:value></cpp:define>










<decl_stmt><decl><type><name>int</name></type> <name>buff_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>check_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m128d@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m128d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m256d@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m256d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PROCESS_CASE</name> <argument_list>(<argument><expr><literal type="string">"__m512d@@"</literal></expr></argument>, <argument><expr><literal type="string">"__m512d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_USER_DEF_TYPE_NAME</name> <argument_list>(<argument><expr><literal type="string">"struct "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PROCESS_CASE</name></cpp:undef>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>W</argument>)</argument_list></macro>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>check_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>!=</operator> <literal type="char">'4'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUncorrectTypeCode</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_USER_DEF_TYPE_NAME</name><argument_list>(<argument><expr><literal type="string">"enum "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>V</argument>)</argument_list></macro>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>check_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_USER_DEF_TYPE_NAME</name><argument_list>(<argument><expr><literal type="string">"class "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_num</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&lt;=</operator> <literal type="char">'8'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>==</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'1'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&lt;=</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&lt;=</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>*=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>+=</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name> <argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODIFIER</name><parameter_list>(<parameter><type><name>modifier_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ unsigned int i = 0; EDemanglerErr err = eDemanglerErrOK; char *tmp = NULL; STypeCodeStr tmp_str; STypeCodeStr modifier; int flag__64ptr = 0; state-&gt;state = eTCStateEnd; if (!init_type_code_str_struct (&amp;tmp_str)) { state-&gt;err = eTCStateMachineErrAlloc; return; } if (!init_type_code_str_struct (&amp;modifier)) { free_type_code_str_struct (&amp;tmp_str); state-&gt;err = eTCStateMachineErrAlloc; return; } if (*state-&gt;buff_for_parsing == 'E') { flag__64ptr = 1; state-&gt;amount_of_read_chars++; state-&gt;buff_for_parsing++; } switch (*state-&gt;buff_for_parsing++) { case 'A': break; case 'B': copy_string (&amp;modifier, "const ", 0); break; case 'C': copy_string (&amp;modifier, "volatile ", 0); break; case 'D': copy_string (&amp;modifier, "const volatile ", 0); break; default: state-&gt;err = eTCStateMachineErrUnsupportedTypeCode; break; } state-&gt;amount_of_read_chars++;if (*state-&gt;buff_for_parsing == 'Y') { char *n1; int num; state-&gt;buff_for_parsing++; state-&gt;amount_of_read_chars++; if (!(n1 = get_num (state))) { goto MODIFIER_err; } num = atoi (n1); R_FREE (n1); copy_string (&amp;tmp_str, " ", 0); copy_string (&amp;tmp_str, "(", 0); copy_string (&amp;tmp_str, modifier.type_str, modifier.curr_pos); copy_string (&amp;tmp_str, modifier_str, 0); copy_string (&amp;tmp_str, ")", 0); while (num--) { n1 = get_num (state); copy_string (&amp;tmp_str, "[", 0); copy_string (&amp;tmp_str, n1, 0); copy_string (&amp;tmp_str, "]", 0); R_FREE (n1); } } if (tmp_str.curr_pos == 0) { copy_string (&amp;tmp_str, " ", 0); copy_string (&amp;tmp_str, modifier.type_str, modifier.curr_pos); copy_string (&amp;tmp_str, modifier_str, 0); if (flag__64ptr) { copy_string (&amp;tmp_str, " __ptr64", 0); } } err = get_type_code_string (state-&gt;buff_for_parsing, &amp;i, &amp;tmp); if (err != eDemanglerErrOK) { state-&gt;err = eTCStateMachineErrUnsupportedTypeCode; goto MODIFIER_err; } state-&gt;amount_of_read_chars += i; state-&gt;buff_for_parsing += i; copy_string (type_code_str, tmp, 0); copy_string (type_code_str, tmp_str.type_str, tmp_str.curr_pos); MODIFIER_err: R_FREE (tmp); free_type_code_str_struct (&amp;tmp_str); free_type_code_str_struct (&amp;modifier); }</cpp:value></cpp:define>


































































































<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>S</argument>)</argument_list></macro>
<block>{<block_content>
<expr_stmt><expr><call><name>MODIFIER</name> <argument_list>(<argument><expr><literal type="string">"* const volatile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>P</argument>)</argument_list></macro>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator> <operator>==</operator> <literal type="char">'6'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>call_conv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>is_abbr_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>


<switch>switch <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__cdecl"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__cdecl __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__pascal"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__pascal __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'E'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__thiscall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__thiscall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__stdcall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__stdcall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__fastcall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'J'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__fastcall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"default (none given)"</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <operator>(</operator><name>ETCStateMachineErr</name><operator>)</operator><name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 


<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_type_code_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUnsupportedTypeCode</name></expr>;</expr_stmt>
<goto>goto <name>FUNCTION_POINTER_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>call_conv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><name>call_conv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">"*)("</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>


<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>!=</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_type_code_string</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&gt;=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>id</name> <init>= <expr><operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>abbr_types</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUncorrectTypeCode</name></expr>;</expr_stmt>
<goto>goto <name>FUNCTION_POINTER_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>is_abbr_type</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUncorrectTypeCode</name></expr>;</expr_stmt>
<goto>goto <name>FUNCTION_POINTER_err</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>abbr_types</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_abbr_type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><name>type_code_str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>)</operator> <operator>!=</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>ETCState</name><operator>)</operator> <name>eTCStateMachineErrUnsupportedTypeCode</name></expr>;</expr_stmt>
<goto>goto <name>FUNCTION_POINTER_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>

<label><name>FUNCTION_POINTER_err</name>:</label>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MODIFIER</name> <argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>R</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MODIFIER</name> <argument_list>(<argument><expr><literal type="string">"* volatile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>Q</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MODIFIER</name> <argument_list>(<argument><expr><literal type="string">"* const"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEF_STATE_ACTION</name><argument_list>(<argument>A</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MODIFIER</name> <argument_list>(<argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MODIFIER</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ONE_LETTER_ACTION</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GO_TO_NEXT_STATE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_STATE_ACTION</name></cpp:undef>


<function><type><specifier>static</specifier> <name>void</name></type> <name>tc_state_start</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_LETTER_STATE</name><parameter_list>(<parameter><type><name>letter</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case CHAR_WITH_QUOTES(letter): state-&gt;state = eTCState##letter; break;</cpp:value></cpp:define> 




<switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>X</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>D</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>C</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>E</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>F</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>G</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>H</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>I</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>J</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>K</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>M</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>N</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>Z</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>_</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>T</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>U</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>W</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>V</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>O</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>S</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>P</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>R</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>Q</argument>)</argument_list></macro>
<macro><name>ONE_LETTER_STATE</name> <argument_list>(<argument>A</argument>)</argument_list></macro>
<default>default:</default>


<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateEnd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrUncorrectTypeCode</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ONE_LETTER_STATE</name></cpp:undef>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>tc_state_end</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>init_state_struct</name><parameter_list>(<parameter><decl><type><name>SStateInfo</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff_for_parsing</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>eTCStateStart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buff_for_parsing</name></name> <operator>=</operator> <name>buff_for_parsing</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>amount_of_read_chars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>eTCStateMachineErrOK</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>init_type_code_str_struct</name><parameter_list>(<parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_coder_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_STR_LEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>


<expr_stmt><expr><name><name>type_coder_str</name><operator>-&gt;</operator><name>type_str_len</name></name> <operator>=</operator> <name>TYPE_STR_LEN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type_coder_str</name><operator>-&gt;</operator><name>type_str</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>TYPE_STR_LEN</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>type_coder_str</name><operator>-&gt;</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>type_coder_str</name><operator>-&gt;</operator><name>type_str</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TYPE_STR_LEN</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type_coder_str</name><operator>-&gt;</operator><name>curr_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 


<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPE_STR_LEN</name></cpp:undef>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>free_type_code_str_struct</name><parameter_list>(<parameter><decl><type><name>STypeCodeStr</name> <modifier>*</modifier></type><name>type_code_str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>type_code_str</name><operator>-&gt;</operator><name>type_str_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>EDemanglerErr</name></type> <name>get_type_code_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>amount_of_read_chars</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str_type_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name> <init>= <expr><name>eDemanglerErrOK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_sym</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STypeCodeStr</name></type> <name>type_code_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SStateInfo</name></type> <name>state</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_type_code_str_struct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrMemoryAllocation</name></expr>;</expr_stmt>
<goto>goto <name>get_type_code_string_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>init_state_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>tmp_sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>eTCStateEnd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>run_state</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>err</name></name> <operator>!=</operator> <name>eTCStateMachineErrOK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>str_type_code</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>amount_of_read_chars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>state</name><operator>.</operator><name>err</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eTCStateMachineErrUncorrectTypeCode</name></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eTCStateMachineErrUnsupportedTypeCode</name></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUnsupportedMangling</name></expr>;</expr_stmt>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<goto>goto <name>get_type_code_string_err</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>str_type_code</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>amount_of_read_chars</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>amount_of_read_chars</name></name></expr>;</expr_stmt>

<label><name>get_type_code_string_err</name>:</label>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_type_code_str_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>EDemanglerErr</name></type> <name>parse_microsoft_mangled_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>demangled_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeCodeStr</name></type> <name>type_code_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STypeCodeStr</name></type> <name>func_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name> <init>= <expr><name>eDemanglerErrOK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_implicit_this_pointer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_static</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>is_abbr_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>access_modifier</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>memb_func_access_code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>call_conv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>storage_class_code_for_ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>__64ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>func_args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SStrInfo</name> <modifier>*</modifier></type><name>str_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curr_pos</name> <init>= <expr><name>sym</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr64</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>storage_class</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>type_code_str</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_type_code_str_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrMemoryAllocation</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_type_code_str_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrMemoryAllocation</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>get_namespace_and_name</name> <argument_list>(<argument><expr><name>curr_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>curr_pos</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<switch>switch <condition>(<expr><operator>*</operator><name>curr_pos</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'0'</literal></expr> :</case> 
<case>case <expr><literal type="char">'1'</literal></expr> :</case> 
<case>case <expr><literal type="char">'2'</literal></expr> :</case> 
<case>case <expr><literal type="char">'3'</literal></expr> :</case> 
<case>case <expr><literal type="char">'4'</literal></expr> :</case> 
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_type_code_string</name> <argument_list>(<argument><expr><name>curr_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>curr_pos</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>curr_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name> <operator>||</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>!=</operator> <literal type="char">'E'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr64</name> <operator>=</operator> <literal type="string">"__ptr64"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_STORAGE_CLASS</name><parameter_list>(<parameter><type><name>letter</name></type></parameter>, <parameter><type><name>storage_class_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ case letter: storage_class = storage_class_str; break; }</cpp:value></cpp:define>





<switch>switch <condition>(<expr><operator>*</operator><name>curr_pos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_STORAGE_CLASS</name> <argument_list>(<argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_STORAGE_CLASS</name> <argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>, <argument><expr><literal type="string">"const"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_STORAGE_CLASS</name> <argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"volatile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_STORAGE_CLASS</name> <argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><literal type="string">"const volatile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_STORAGE_CLASS</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr64</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>storage_class</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %s"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>storage_class</name></expr></argument>,<argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>storage_class</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %s"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>ptr64</name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %s %s"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>storage_class</name></expr></argument>, <argument><expr><name>ptr64</name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>

<case>case <expr><literal type="char">'6'</literal></expr> :</case> 
<case>case <expr><literal type="char">'7'</literal></expr> :</case> 
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUnsupportedMangling</name></expr>;</expr_stmt>
<break>break;</break>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ACCESS_MODIFIER</name><parameter_list>(<parameter><type><name>letter</name></type></parameter>, <parameter><type><name>flag_set</name></type></parameter>, <parameter><type><name>modifier_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ case letter: access_modifier = modifier_str; (flag_set) = 1; break; }</cpp:value></cpp:define>






<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'E'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"private virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"private virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'M'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"protected virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'N'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"protected virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'U'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"public virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'V'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"public virtual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"private"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'B'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"private"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'I'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"protected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'J'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"protected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'Q'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'R'</literal></expr></argument>, <argument><expr><name>is_implicit_this_pointer</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"private: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'D'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"private: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'K'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"protected: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'L'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"protected: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"public: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_ACCESS_MODIFIER</name> <argument_list>(<argument><expr><literal type="char">'T'</literal></expr></argument>, <argument><expr><name>is_static</name></expr></argument>, <argument><expr><literal type="string">"public: static"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'Y'</literal></expr> :</case> 
<case>case <expr><literal type="char">'Z'</literal></expr> :</case> 
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_ACCESS_MODIFIER</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>__64ptr</name> <operator>=</operator> <literal type="string">"__ptr64"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>is_implicit_this_pointer</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>curr_pos</name><operator>++</operator></expr>)</condition>
<block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <break>break;</break> 
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><name>memb_func_access_code</name> <operator>=</operator> <literal type="string">"const"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><name>memb_func_access_code</name> <operator>=</operator> <literal type="string">"volatile"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>memb_func_access_code</name> <operator>=</operator> <literal type="string">"const volatile"</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>







<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>is_static</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>


<switch>switch <condition>(<expr><operator>*</operator><name>curr_pos</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__cdecl"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__cdecl __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__pascal"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__pascal __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'E'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__thiscall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__thiscall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__stdcall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__stdcall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__fastcall"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'J'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"__fastcall __declspec(dllexport)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case> <expr_stmt><expr><name>call_conv</name> <operator>=</operator> <literal type="string">"default (none given)"</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><operator>++</operator><name>curr_pos</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case> <break>break;</break> 
<case>case <expr><literal type="char">'B'</literal></expr>:</case> <expr_stmt><expr><name>storage_class_code_for_ret</name> <operator>=</operator> <literal type="string">"const"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case> <expr_stmt><expr><name>storage_class_code_for_ret</name> <operator>=</operator> <literal type="string">"volatile"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>storage_class_code_for_ret</name> <operator>=</operator> <literal type="string">"const volatile"</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUnsupportedMangling</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></switch>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret_type</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_type_code_string</name> <argument_list>(<argument><expr><name>curr_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>curr_pos</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>func_args</name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>curr_pos</name> <operator>!=</operator> <literal type="char">'Z'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>get_type_code_string</name> <argument_list>(<argument><expr><name>curr_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>eDemanglerErrOK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>curr_pos</name> <operator>&gt;=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>curr_pos</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>abbr_types</name></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>curr_pos</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>is_abbr_type</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curr_pos</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>abbr_types</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str_arg</name> <operator>=</operator> <operator>(</operator><name>SStrInfo</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str_arg</name><operator>-&gt;</operator><name>str_ptr</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str_arg</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>func_args</name></expr></argument>, <argument><expr><name>str_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_abbr_type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_abbr_type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<while>while <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>curr_pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>curr_pos</name> <operator>!=</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>access_modifier</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>access_modifier</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>access_modifier</name></expr></argument>, <argument><expr><literal type="string">"static"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>storage_class_code_for_ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>storage_class_code_for_ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>call_conv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>call_conv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>curr_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>func_args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>func_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>func_args</argument>, <argument>it</argument>, <argument>str_arg</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name><name>str_arg</name><operator>-&gt;</operator><name>str_ptr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>i</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>str_arg</name><operator>-&gt;</operator><name>str_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>memb_func_access_code</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>memb_func_access_code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>__64ptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_string</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>, <argument><expr><name>__64ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_type</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>func_str</name><operator>.</operator><name>type_str</name></name></expr></argument>, <argument><expr><literal type="string">"#{return_type}"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>func_str</name><operator>.</operator><name>type_str</name></name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name><name>func_str</name><operator>.</operator><name>type_str</name></name></expr></argument>, <argument><expr><literal type="string">"#{return_type}"</literal></expr></argument>, <argument><expr><name>ret_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>func_str</name><operator>.</operator><name>curr_pos</name></name> <operator>-=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"#{return_type}"</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>func_str</name><operator>.</operator><name>type_str</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>func_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>parse_microsoft_mangled_name_err</name>:</label>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_type_code_str_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_type_code_str_struct</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>func_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>func_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDemanglerErr</name></type> <name>parse_microsoft_rtti_mangled_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>demangled_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name> <init>= <expr><name>eDemanglerErrOK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"AT"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"union"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"AU"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"struct"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"AV"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"class"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><literal type="string">"AW"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"enum"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_rtti_mangled_name_err</name>;</goto>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>STypeCodeStr</name></type> <name>type_code_str</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_type_code_str_struct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrMemoryAllocation</name></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_rtti_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>get_namespace_and_name</name> <argument_list>(<argument><expr><name>sym</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_code_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrUncorrectMangledSymbol</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>parse_microsoft_rtti_mangled_name_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>demangled_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>type_code_str</name><operator>.</operator><name>type_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>parse_microsoft_rtti_mangled_name_err</name>:</label>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>EDemanglerErr</name></type> <name>microsoft_demangle</name><parameter_list>(<parameter><decl><type><name>SDemangler</name> <modifier>*</modifier></type><name>demangler</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>demangled_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EDemanglerErr</name></type> <name>err</name> <init>= <expr><name>eDemanglerErrOK</name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>abbr_types</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>abbr_names</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>demangler</name> <operator>||</operator> <operator>!</operator><name>demangled_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>eDemanglerErrMemoryAllocation</name></expr>;</expr_stmt>
<goto>goto <name>microsoft_demangle_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>demangler</name><operator>-&gt;</operator><name>symbol</name></name></expr></argument>, <argument><expr><literal type="string">".?"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>parse_microsoft_rtti_mangled_name</name> <argument_list>(<argument><expr><name><name>demangler</name><operator>-&gt;</operator><name>symbol</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>demangled_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>parse_microsoft_mangled_name</name> <argument_list>(<argument><expr><name><name>demangler</name><operator>-&gt;</operator><name>symbol</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>demangled_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>microsoft_demangle_err</name>:</label>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>abbr_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>abbr_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_USER_DEF_TYPE_NAME</name></cpp:undef>
</unit>
