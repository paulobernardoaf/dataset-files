<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\bin\pdb\tpi.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tpi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stream_file.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>base_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>p_types_list</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_base_type</name><parameter_list>(<parameter><decl><type><name>EBASE_TYPES</name></type> <name>base_type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>base_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eT_32PINT4</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PRCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to unsigned char"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PUCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to unsigned char"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PULONG</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to unsigned long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PLONG</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PUQUAD</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to unsigned long long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PUSHORT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to unsigned short"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PVOID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to void"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_64PVOID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer64 to void"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_INT4</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_INT8</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"long long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_LONG</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_QUAD</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"long long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_RCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned char"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_REAL32</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"float"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_REAL64</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"double"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_REAL80</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"long double"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_SHORT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"short"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_UCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned char"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_UINT4</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_ULONG</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_UQUAD</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned long long"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_USHORT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsigned short"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_WCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"wchar"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_VOID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"void"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eT_32PWCHAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"pointer to wchar"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="string">"unsupported base type"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>get_sval_name_len</name><parameter_list>(<parameter><decl><type><name>SVal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name> <operator>&lt;</operator> <name>eLF_CHAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SCString</name> <modifier>*</modifier></type><name>scstr</name> <init>= <expr><operator>(</operator><name>SCString</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <name><name>scstr</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_ULONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_ULONG</name> <modifier>*</modifier></type><name>lf_ulong</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ulong</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_ULONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <name><name>lf_ulong</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_USHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_USHORT</name> <modifier>*</modifier></type><name>lf_ushort</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ushort</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_USHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <name><name>lf_ushort</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"get_sval_name_len: Skipping unsupported type (%d)\n"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>get_sval_name</name><parameter_list>(<parameter><decl><type><name>SVal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name> <operator>&lt;</operator> <name>eLF_CHAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SCString</name> <modifier>*</modifier></type><name>scstr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>scstr</name> <operator>=</operator> <operator>(</operator><name>SCString</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>scstr</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_UQUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_UQUADWORD</name> <modifier>*</modifier></type><name>lf_uquadword</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_uquadword</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_UQUADWORD</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_uquadword</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_QUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_QUADWORD</name> <modifier>*</modifier></type><name>lf_quadword</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_quadword</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_QUADWORD</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_quadword</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_CHAR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_CHAR</name> <modifier>*</modifier></type><name>lf_char</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_char</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_CHAR</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_char</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_ULONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_ULONG</name> <modifier>*</modifier></type><name>lf_ulong</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ulong</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_ULONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_ulong</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_LONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_LONG</name> <modifier>*</modifier></type><name>lf_long</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_long</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_LONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_long</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_USHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_USHORT</name> <modifier>*</modifier></type><name>lf_ushort</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ushort</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_USHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator><name><name>lf_ushort</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_SHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_SHORT</name> <modifier>*</modifier></type><name>lf_short</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_short</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_SHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_short</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"get_sval_name: Skipping unsupported type (%d)\n"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>void</name></type> <name>is_union_fwdref</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>is_fwdref</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>is_fwdref</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>bits</name><operator>.</operator><name>fwdref</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>is_struct_class_fwdref</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>is_fwdref</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>is_fwdref</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>bits</name><operator>.</operator><name>fwdref</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_array_element_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf_array</name><operator>-&gt;</operator><name>element_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_array_index_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf_array</name><operator>-&gt;</operator><name>index_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_bitfield_base_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_BITFIELD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_BITFIELD</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>base_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_class_struct_derived</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>derived</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_class_struct_vshape</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>vshape</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_mfunction_return_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MFUNCTION</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MFUNCTION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>return_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_mfunction_class_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MFUNCTION</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MFUNCTION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>class_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_mfunction_this_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MFUNCTION</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MFUNCTION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>this_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_mfunction_arglist</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MFUNCTION</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MFUNCTION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>arglist</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_modifier_modified_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MODIFIER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MODIFIER</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>modified_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_pointer_utype</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_POINTER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_POINTER</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>utype</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_procedure_return_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_PROCEDURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_PROCEDURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>return_type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_procedure_arglist</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_PROCEDURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_PROCEDURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>arg_list</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_member_index</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MEMBER</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_nesttype_index</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_NESTTYPE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_NESTTYPE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>get_onemethod_index</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ONEMETHOD</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_method_mlist</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_METHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_METHOD</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>mlist</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_enum_utype</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ENUM</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_idx</name> <init>= <expr><name><name>lf</name><operator>-&gt;</operator><name>utype</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>curr_idx</name> <operator>&lt;</operator> <name>base_idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>curr_idx</name> <operator>-=</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_type</name> <operator>=</operator> <call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>curr_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>curr_idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_fieldlist_members</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_FIELDLIST</name> <modifier>*</modifier></type><name>lf_fieldlist</name> <init>= <expr><operator>(</operator><name>SLF_FIELDLIST</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <name><name>lf_fieldlist</name><operator>-&gt;</operator><name>substructs</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_union_members</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>indx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lf_union</name><operator>-&gt;</operator><name>field_list</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>indx</name> <operator>=</operator> <name><name>lf_union</name><operator>-&gt;</operator><name>field_list</name></name> <operator>-</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>SType</name> <operator>*</operator><operator>)</operator><call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SLF_FIELDLIST</name> <operator>*</operator><operator>)</operator> <name><name>tmp</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name><operator>)</operator><operator>-&gt;</operator><name>substructs</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_struct_class_members</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>SLF_FIELDLIST</name> <modifier>*</modifier></type><name>lf_fieldlist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>indx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lf</name><operator>-&gt;</operator><name>field_list</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>indx</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>field_list</name></name> <operator>-</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>SType</name> <operator>*</operator><operator>)</operator><call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lf_fieldlist</name> <operator>=</operator> <operator>(</operator><name>SLF_FIELDLIST</name> <operator>*</operator><operator>)</operator> <name><name>tmp</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <name><name>lf_fieldlist</name><operator>-&gt;</operator><name>substructs</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enum_members</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ENUM</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>indx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lf</name><operator>-&gt;</operator><name>field_list</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>indx</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>field_list</name></name> <operator>-</operator> <name>base_idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>SType</name> <operator>*</operator><operator>)</operator><call><name>r_list_get_n</name><argument_list>(<argument><expr><name>p_types_list</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SLF_FIELDLIST</name> <operator>*</operator><operator>)</operator> <name><name>tmp</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name><operator>)</operator><operator>-&gt;</operator><name>substructs</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_sval_val</name><parameter_list>(<parameter><decl><type><name>SVal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name> <operator>&lt;</operator> <name>eLF_CHAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_UQUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_UQUADWORD</name> <modifier>*</modifier></type><name>lf_uqword</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_uqword</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_UQUADWORD</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_uqword</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_QUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_QUADWORD</name> <modifier>*</modifier></type><name>lf_qword</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_qword</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_QUADWORD</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_qword</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_ULONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_ULONG</name> <modifier>*</modifier></type><name>lf_ulong</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ulong</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_ULONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_ulong</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_LONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_LONG</name> <modifier>*</modifier></type><name>lf_long</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_long</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_LONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_long</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_USHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_USHORT</name> <modifier>*</modifier></type><name>lf_ushort</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ushort</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_USHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_ushort</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_SHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_SHORT</name> <modifier>*</modifier></type><name>lf_short</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_short</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_SHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_short</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_CHAR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_CHAR</name> <modifier>*</modifier></type><name>lf_char</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_char</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_CHAR</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf_char</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"get_sval_val: Skipping unsupported type (%d)\n"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>get_onemethod_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf_onemethod</name> <init>= <expr><operator>(</operator><name>SLF_ONEMETHOD</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str_data</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enum_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf_enum</name> <init>= <expr><operator>(</operator><name>SLF_ENUM</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>res_len</name> <operator>=</operator> <name><name>lf_enum</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_class_struct_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_array_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_array</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_union_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_union</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enumerate_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUMERATE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ENUMERATE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>enum_value</name></name></expr></argument>, <argument><expr><name>res_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_nesttype_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_NESTTYPE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_NESTTYPE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_method_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_METHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_METHOD</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_member_name_len</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MEMBER</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_member_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MEMBER</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_onemethod_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ONEMETHOD</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str_data</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_method_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_METHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_METHOD</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_nesttype_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_NESTTYPE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_NESTTYPE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enumerate_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUMERATE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ENUMERATE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>enum_value</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enum_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf_enum</name> <init>= <expr><operator>(</operator><name>SLF_ENUM</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <name><name>lf_enum</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_class_struct_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_array_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_array</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_union_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_union</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_onemethod_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ONEMETHOD</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_member_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_MEMBER</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_sval_val</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enumerate_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUMERATE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_ENUMERATE</name> <operator>*</operator><operator>)</operator><name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_sval_val</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>enum_value</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_class_struct_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_STRUCTURE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_sval_val</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_array_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>get_sval_val</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_array</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_union_val</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>get_sval_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_union</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>void</name></type> <name>free_sval</name><parameter_list>(<parameter><decl><type><name>SVal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name> <operator>&lt;</operator> <name>eLF_CHAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SCString</name> <modifier>*</modifier></type><name>scstr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>scstr</name> <operator>=</operator> <operator>(</operator><name>SCString</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>scstr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_ULONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_ULONG</name> <modifier>*</modifier></type><name>lf_ulong</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ulong</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_ULONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>lf_ulong</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_LONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_LONG</name> <modifier>*</modifier></type><name>lf_long</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_long</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_LONG</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>lf_long</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_SHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_SHORT</name> <modifier>*</modifier></type><name>lf_short</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_short</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_SHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>lf_short</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_USHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_USHORT</name> <modifier>*</modifier></type><name>lf_ushort</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_ushort</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_USHORT</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>lf_ushort</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_CHAR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_CHAR</name> <modifier>*</modifier></type><name>lf_char</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lf_char</name> <operator>=</operator> <operator>(</operator><name>SVal_LF_CHAR</name> <operator>*</operator><operator>)</operator> <name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>lf_char</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"free_sval()::not supproted type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_enumerate</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>typeInfo</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type_info</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUMERATE</name> <modifier>*</modifier></type><name>lf_en</name> <init>= <expr><operator>(</operator><name>SLF_ENUMERATE</name> <operator>*</operator><operator>)</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_sval</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lf_en</name><operator>-&gt;</operator><name>enum_value</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_nesttype</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>typeInfo</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type_info</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_NESTTYPE</name> <modifier>*</modifier></type><name>lf_nest</name> <init>= <expr><operator>(</operator><name>SLF_NESTTYPE</name> <operator>*</operator><operator>)</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>lf_nest</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_method</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>typeInfo</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type_info</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_METHOD</name> <modifier>*</modifier></type><name>lf_meth</name> <init>= <expr><operator>(</operator><name>SLF_METHOD</name> <operator>*</operator><operator>)</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>lf_meth</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_member</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>typeInfo</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type_info</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf_mem</name> <init>= <expr><operator>(</operator><name>SLF_MEMBER</name> <operator>*</operator><operator>)</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_sval</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_mem</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_fieldlist</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_FIELDLIST</name> <modifier>*</modifier></type><name>lf_fieldlist</name> <init>= <expr><operator>(</operator><name>SLF_FIELDLIST</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>type_info</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_iterator</name><argument_list>(<argument><expr><name><name>lf_fieldlist</name><operator>-&gt;</operator><name>substructs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>r_list_iter_next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type_info</name> <operator>=</operator> <operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>r_list_iter_get</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <argument_list>(<argument><expr><name>type_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type_info</name><operator>-&gt;</operator><name>type_info</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>type_info</name><operator>-&gt;</operator><name>type_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>type_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>lf_fieldlist</name><operator>-&gt;</operator><name>substructs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_class</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_CLASS</name> <modifier>*</modifier></type><name>lf_class</name> <init>= <expr><operator>(</operator><name>SLF_CLASS</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_class</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_union</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name> <init>= <expr><operator>(</operator><name>SLF_UNION</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_sval</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_union</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_onemethod</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf_onemethod</name> <init>= <expr><operator>(</operator><name>SLF_ONEMETHOD</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str_data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_enum</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf_enum</name> <init>= <expr><operator>(</operator><name>SLF_ENUM</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_array</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name> <init>= <expr><operator>(</operator><name>SLF_ARRAY</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free_sval</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_array</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_arglist</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_ARGLIST</name> <modifier>*</modifier></type><name>lf_arglist</name> <init>= <expr><operator>(</operator><name>SLF_ARGLIST</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_lf_vtshape</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_VTSHAPE</name> <modifier>*</modifier></type><name>lf_vtshape</name> <init>= <expr><operator>(</operator><name>SLF_VTSHAPE</name> <operator>*</operator><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_tpi_stream</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STpiStream</name> <modifier>*</modifier></type><name>tpi_stream</name> <init>= <expr><operator>(</operator><name>STpiStream</name> <operator>*</operator><operator>)</operator><name>stream</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_iterator</name> <argument_list>(<argument><expr><name><name>tpi_stream</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>r_list_iter_next</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>SType</name> <operator>*</operator><operator>)</operator> <call><name>r_list_iter_get</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>free_</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>free_</name></name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>type</name><operator>-&gt;</operator><name>type_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>free_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>free_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>tpi_stream</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_array_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>need_to_free</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_element_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"array: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"array: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_pointer_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_utype</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"pointer to "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"pointer to "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_name</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_modifier_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>need_to_free</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_modified_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"modifier "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"modifier "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_procedure_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>name_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"proc "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"proc "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_bitfield_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SLF_BITFIELD</name> <modifier>*</modifier></type><name>bitfeild_info</name> <init>= <expr><operator>(</operator><name>SLF_BITFIELD</name> <operator>*</operator><operator>)</operator><name><name>ti</name><operator>-&gt;</operator><name>type_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_base_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"bitfield "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"%s %s : %d"</literal></expr></argument>, <argument><expr><literal type="string">"bitfield"</literal></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>bitfeild_info</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"%s : %d"</literal></expr></argument>, <argument><expr><literal type="string">"bitfield"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>bitfeild_info</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_fieldlist_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"fieldlist "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"fieldlist "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enum_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_utype</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"enum "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"enum "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_class_struct_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELeafType</name></type> <name>lt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lt</name> <operator>=</operator> <name><name>ti</name><operator>-&gt;</operator><name>leaf_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_name</name></name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lt</name> <operator>==</operator> <name>eLF_CLASS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <literal type="string">"class "</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <literal type="string">"struct "</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_arglist_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>type</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"arg_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"arg_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

























</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_mfunction_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"mfunction "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"mfunction "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>get_union_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_name</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <literal type="string">"union "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_vtshape_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"vtshape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"vthape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_enumerate_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_name</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <literal type="string">"enumerate "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_nesttype_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_index</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"nesttype "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"nesttype "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_method_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_name</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <literal type="string">"method "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_member_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_index</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"(member) "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"(member) "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_onemethod_print_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>STypeInfo</name> <operator>*</operator><operator>)</operator> <name>type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_name</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_to_free</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base_type</name> <operator>=</operator> <call><name><name>ti</name><operator>-&gt;</operator><name>get_index</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_to_free</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_base_type</name> <argument_list>(<argument><expr><name>base_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>type_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ti</name><operator>-&gt;</operator><name>get_print_type</name></name> <argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"onemethod "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name_len</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>name</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"onemethod "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>need_to_free</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>init_scstring</name><parameter_list>(<parameter><decl><type><name>SCString</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>cstr</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>deinit_scstring</name><parameter_list>(<parameter><decl><type><name>SCString</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cstr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>parse_sctring</name><parameter_list>(<parameter><decl><type><name>SCString</name> <modifier>*</modifier></type><name>sctr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sctr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sctr</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>leaf_data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CAN_READ</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>+</operator> <name>c</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>CAN_READ</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>read_bytes</name><operator>)</operator> <operator>+=</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_scstring</name> <argument_list>(<argument><expr><name>sctr</name></expr></argument>, <argument><expr><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>leaf_data</name> <operator>-</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_sval</name><parameter_list>(<parameter><decl><type><name>SVal</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name> <operator>&lt;</operator> <name>eLF_CHAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SCString</name> <modifier>*</modifier></type><name>sctr</name> <init>= <expr><operator>(</operator><name>SCString</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SCString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sctr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><name>sctr</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <name>sctr</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_UQUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_UQUADWORD</name></type> <name>lf_uqword</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>READ8</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_uqword</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_uqword</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVal_LF_UQUADWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_uqword</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVal_LF_UQUADWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_QUADWORD</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_QUADWORD</name></type> <name>lf_qword</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>READ8</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_qword</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_qword</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_QUADWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_qword</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_QUADWORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_CHAR</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_CHAR</name></type> <name>lf_char</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_char</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_char</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_char</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_CHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_LONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_LONG</name></type> <name>lf_long</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lf_long</name><operator>.</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_long</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_long</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_LONG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_long</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_LONG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_ULONG</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_ULONG</name></type> <name>lf_ulong</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lf_ulong</name><operator>.</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_ulong</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_ulong</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_ULONG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_ulong</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_ULONG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_SHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_SHORT</name></type> <name>lf_short</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_short</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_short</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_SHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_short</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_SHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>eLF_USHORT</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>SVal_LF_USHORT</name></type> <name>lf_ushort</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_ushort</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_ushort</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVal_LF_USHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>name_or_val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lf_ushort</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SVal_LF_USHORT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"parse_sval: Skipping unsupported type (%d)\n"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>value_or_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_enumerate</name><parameter_list>(<parameter><decl><type><name>SLF_ENUMERATE</name> <modifier>*</modifier></type><name>lf_enumerate</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>read_bytes_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp_read_bytes_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_enumerate</name><operator>-&gt;</operator><name>enum_value</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>read_bytes_before</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enumerate</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>fldattr</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_read_bytes_before</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_enumerate</name><operator>-&gt;</operator><name>enum_value</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_read_bytes_before</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enumerate</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_enumerate</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<return>return <expr><operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>read_bytes_before</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_nesttype</name><parameter_list>(<parameter><decl><type><name>SLF_NESTTYPE</name> <modifier>*</modifier></type><name>lf_nesttype</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>read_bytes_before</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_nesttype</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_nesttype</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_nesttype</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_sctring</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_nesttype</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>read_bytes_before</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_method</name><parameter_list>(<parameter><decl><type><name>SLF_METHOD</name> <modifier>*</modifier></type><name>lf_method</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>read_bytes_before</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>, <decl><type ref="prev"/><name>tmp_read_bytes_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_method</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_method</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_method</name><operator>-&gt;</operator><name>mlist</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_read_bytes_before</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_method</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_read_bytes_before</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_method</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_method</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>read_bytes_before</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_member</name><parameter_list>(<parameter><decl><type><name>SLF_MEMBER</name> <modifier>*</modifier></type><name>lf_member</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>read_bytes_before</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>, <decl><type ref="prev"/><name>tmp_read_bytes_before</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_member</name><operator>-&gt;</operator><name>offset</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_member</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>fldattr</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_member</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_read_bytes_before</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_member</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_read_bytes_before</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_member</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_member</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<return>return <expr><operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>read_bytes_before</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_onemethod</name><parameter_list>(<parameter><decl><type><name>SLF_ONEMETHOD</name> <modifier>*</modifier></type><name>lf_onemethod</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>read_bytes_before</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>, <decl><type ref="prev"/><name>tmp_before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str_data</name><operator>.</operator><name>name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>fldattr</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>fldattr</name></name> <operator>=</operator> <call><name>SWAP_UINT16</name><argument_list>(<argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>fldattr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>lf_onemethod</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>bits</name><operator>.</operator><name>mprop</name></name> <operator>==</operator> <name>eMTintro</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>lf_onemethod</name><operator>-&gt;</operator><name>fldattr</name><operator>.</operator><name>bits</name><operator>.</operator><name>mprop</name></name> <operator>==</operator> <name>eMTpureintro</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lf_onemethod</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str_data</name></name><operator>)</operator></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_onemethod</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>read_bytes_before</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>init_stype_info</name><parameter_list>(<parameter><decl><type><name>STypeInfo</name> <modifier>*</modifier></type><name>type_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arg_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_element_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_base_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_derived</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_vshape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_utype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_return_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_class_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_this_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arglist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_mlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_modified_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>is_fwdref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>type_info</name><operator>-&gt;</operator><name>leaf_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_FIELDLIST</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <name>get_fieldlist_members</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_fieldlist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_fieldlist_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ENUM</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_enum_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_enum_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <name>get_enum_members</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_utype</name></name> <operator>=</operator> <name>get_enum_utype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_enum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_enum_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_CLASS</name></expr>:</case>
<case>case <expr><name>eLF_STRUCTURE</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_class_struct_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_class_struct_val</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_class_struct_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <name>get_struct_class_members</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_derived</name></name> <operator>=</operator> <name>get_class_struct_derived</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_vshape</name></name> <operator>=</operator> <name>get_class_struct_vshape</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>is_fwdref</name></name> <operator>=</operator> <name>is_struct_class_fwdref</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_class</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_class_struct_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_POINTER</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_utype</name></name> <operator>=</operator> <name>get_pointer_utype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_pointer_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ARRAY</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_array_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_array_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_array_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_element_type</name></name> <operator>=</operator> <name>get_array_element_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index_type</name></name> <operator>=</operator> <name>get_array_index_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_array</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_array_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MODIFIER</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_modified_type</name></name> <operator>=</operator> <name>get_modifier_modified_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_modifier_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ARGLIST</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_arglist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_arglist_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MFUNCTION</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_return_type</name></name> <operator>=</operator> <name>get_mfunction_return_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_class_type</name></name> <operator>=</operator> <name>get_mfunction_class_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_this_type</name></name> <operator>=</operator> <name>get_mfunction_this_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arglist</name></name> <operator>=</operator> <name>get_mfunction_arglist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_mfunction_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_METHODLIST</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>eLF_PROCEDURE</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_return_type</name></name> <operator>=</operator> <name>get_procedure_return_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arglist</name></name> <operator>=</operator> <name>get_procedure_arglist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_procedure_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_UNION</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_union_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_union_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_union_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <name>get_union_members</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>is_fwdref</name></name> <operator>=</operator> <name>is_union_fwdref</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_union</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_union_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_BITFIELD</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_base_type</name></name> <operator>=</operator> <name>get_bitfield_base_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_bitfield_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_VTSHAPE</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_vtshape</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_vtshape_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ENUMERATE</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_enumerate_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_enumerate_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_enumerate_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_enumerate</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_enumerate_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_NESTTYPE</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_nesttype_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_nesttype_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index</name></name> <operator>=</operator> <name>get_nesttype_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_nesttype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_nesttype_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_METHOD</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_method_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_method_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_mlist</name></name> <operator>=</operator> <name>get_method_mlist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_method</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_method_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MEMBER</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_member_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_member_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_member_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index</name></name> <operator>=</operator> <name>get_member_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_member</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_member_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ONEMETHOD</name></expr>:</case>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <name>get_onemethod_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <name>get_onemethod_name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <name>get_onemethod_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index</name></name> <operator>=</operator> <name>get_onemethod_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_lf_onemethod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <name>get_onemethod_print_type</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_name_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_members</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arg_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_element_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_base_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_derived</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_vshape</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_utype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_return_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_class_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_this_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_arglist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_mlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type_info</name><operator>-&gt;</operator><name>get_print_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_LF2</name><parameter_list>(<parameter><type><name>lf_type</name></type></parameter>, <parameter><type><name>lf_func_name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ STypeInfo *type_info = (STypeInfo *) malloc (sizeof (STypeInfo)); if (!type_info) return 0; lf_type *lf = (lf_type *) malloc (sizeof (lf_type)); if (!lf) { free (type_info); return 0; } curr_read_bytes = parse_##lf_func_name (lf, p, read_bytes, len); type_info-&gt;type_info = (void *) lf; type_info-&gt;leaf_type = type; init_stype_info (type_info); r_list_append (lf_fieldlist-&gt;substructs, type_info); }</cpp:value></cpp:define>















<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_fieldlist</name><parameter_list>(<parameter><decl><type><name>SLF_FIELDLIST</name> <modifier>*</modifier></type><name>lf_fieldlist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ELeafType</name></type> <name>leaf_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>leaf_data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_fieldlist</name><operator>-&gt;</operator><name>substructs</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>read_bytes</name> <operator>&lt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>leaf_type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>leaf_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_ENUMERATE</name></expr>:</case>
<expr_stmt><expr><call><name>PARSE_LF2</name><argument_list>(<argument><expr><name>SLF_ENUMERATE</name></expr></argument>, <argument><expr><name>lf_enumerate</name></expr></argument>, <argument><expr><name>eLF_ENUMERATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_NESTTYPE</name></expr>:</case>
<expr_stmt><expr><call><name>PARSE_LF2</name><argument_list>(<argument><expr><name>SLF_NESTTYPE</name></expr></argument>, <argument><expr><name>lf_nesttype</name></expr></argument>, <argument><expr><name>eLF_NESTTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_METHOD</name></expr>:</case>
<expr_stmt><expr><call><name>PARSE_LF2</name><argument_list>(<argument><expr><name>SLF_METHOD</name></expr></argument>, <argument><expr><name>lf_method</name></expr></argument>, <argument><expr><name>eLF_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MEMBER</name></expr>:</case>
<expr_stmt><expr><call><name>PARSE_LF2</name><argument_list>(<argument><expr><name>SLF_MEMBER</name></expr></argument>, <argument><expr><name>lf_member</name></expr></argument>, <argument><expr><name>eLF_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ONEMETHOD</name></expr>:</case>
<expr_stmt><expr><call><name>PARSE_LF2</name><argument_list>(<argument><expr><name>SLF_ONEMETHOD</name></expr></argument>, <argument><expr><name>lf_onemethod</name></expr></argument>, <argument><expr><name>eLF_ONEMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>curr_read_bytes</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>curr_read_bytes</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_enum</name><parameter_list>(<parameter><decl><type><name>SLF_ENUM</name> <modifier>*</modifier></type><name>lf_enum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>utype</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>field_list</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name> <operator>=</operator> <call><name>SWAP_UINT16</name><argument_list>(<argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sctring</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_enum</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>before_read_bytes</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_enum</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_class</name><parameter_list>(<parameter><decl><type><name>SLF_CLASS</name> <modifier>*</modifier></type><name>lf_class</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_class</name><operator>-&gt;</operator><name>size</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>field_list</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>derived</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>vshape</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_class</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>before_read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>leaf_data</name> <operator>+</operator> <name>before_read_bytes</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_class</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_structure</name><parameter_list>(<parameter><decl><type><name>SLF_STRUCTURE</name> <modifier>*</modifier></type><name>lf_structure</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>size</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>field_list</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>derived</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>vshape</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name> <operator>=</operator> <call><name>SWAP_UINT16</name><argument_list>(<argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_structure</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>before_read_bytes</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_structure</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_pointer</name><parameter_list>(<parameter><decl><type><name>SLF_POINTER</name> <modifier>*</modifier></type><name>lf_pointer</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>utype</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>ptr_attr</name><operator>.</operator><name>ptr_attr</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>ptr_attr</name><operator>.</operator><name>ptr_attr</name></name> <operator>=</operator> <call><name>SWAP_UINT32</name><argument_list>(<argument><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>ptr_attr</name><operator>.</operator><name>ptr_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_pointer</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_array</name><parameter_list>(<parameter><decl><type><name>SLF_ARRAY</name> <modifier>*</modifier></type><name>lf_array</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_array</name><operator>-&gt;</operator><name>size</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_array</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_array</name><operator>-&gt;</operator><name>index_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_array</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>before_read_bytes</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_array</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_array</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_modifier</name><parameter_list>(<parameter><decl><type><name>SLF_MODIFIER</name> <modifier>*</modifier></type><name>lf_modifier</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>modified_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>umodifier</name><operator>.</operator><name>modifier</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>umodifier</name><operator>.</operator><name>modifier</name></name> <operator>=</operator> <call><name>SWAP_UINT16</name><argument_list>(<argument><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>umodifier</name><operator>.</operator><name>modifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_modifier</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_arglist</name><parameter_list>(<parameter><decl><type><name>SLF_ARGLIST</name> <modifier>*</modifier></type><name>lf_arglist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>arg_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <operator>(</operator><name><name>lf_arglist</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>read_bytes</name> <operator>+=</operator> <operator>(</operator><name><name>lf_arglist</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name> <argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name> <argument_list>(<argument><expr><name><name>lf_arglist</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_mfunction</name><parameter_list>(<parameter><decl><type><name>SLF_MFUNCTION</name> <modifier>*</modifier></type><name>lf_mfunction</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>return_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>class_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>this_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>call_conv</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>reserved</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>parm_count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>arglist</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>this_adjust</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>st32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_mfunction</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_procedure</name><parameter_list>(<parameter><decl><type><name>SLF_PROCEDURE</name> <modifier>*</modifier></type><name>lf_procedure</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>return_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>call_conv</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>reserved</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>parm_count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>arg_list</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_procedure</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_union</name><parameter_list>(<parameter><decl><type><name>SLF_UNION</name> <modifier>*</modifier></type><name>lf_union</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>before_read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lf_union</name><operator>-&gt;</operator><name>size</name><operator>.</operator><name>name_or_val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_union</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_union</name><operator>-&gt;</operator><name>prop</name><operator>.</operator><name>cv_property</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_union</name><operator>-&gt;</operator><name>field_list</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lf_union</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>before_read_bytes</name> <operator>=</operator> <operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>before_read_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>leaf_data</name> <operator>+</operator> <name>before_read_bytes</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_union</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_union</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_bitfield</name><parameter_list>(<parameter><decl><type><name>SLF_BITFIELD</name> <modifier>*</modifier></type><name>lf_bitfield</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READ4</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_bitfield</name><operator>-&gt;</operator><name>base_type</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_bitfield</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_bitfield</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_bitfield</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name><argument_list>(<argument><expr><name><name>lf_bitfield</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_lf_vtshape</name><parameter_list>(<parameter><decl><type><name>SLF_VTSHAPE</name> <modifier>*</modifier></type><name>lf_vtshape</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>read_bytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp_before_read_bytes</name> <init>= <expr><operator>*</operator><name>read_bytes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt> 

<expr_stmt><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>READ2</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><literal type="number">4</literal> <operator>*</operator> <name><name>lf_vtshape</name><operator>-&gt;</operator><name>count</name></name> <operator>+</operator> <operator>(</operator><name><name>lf_vtshape</name><operator>-&gt;</operator><name>count</name></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>vt_descriptors</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>read_bytes</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PEEK_READ1</name><argument_list>(<argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>ut8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PAD_ALIGN</name> <argument_list>(<argument><expr><name><name>lf_vtshape</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>, <argument><expr><operator>*</operator><name>read_bytes</name></expr></argument>, <argument><expr><name>leaf_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>read_bytes</name> <operator>-</operator> <name>tmp_before_read_bytes</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_LF</name><parameter_list>(<parameter><type><name>lf_type</name></type></parameter>, <parameter><type><name>lf_func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ lf_type *lf = (lf_type *) malloc(sizeof(lf_type)); if (!lf) { free (leaf_data); return 0; }parse_##lf_func(lf, leaf_data + 2, &amp;read_bytes, type-&gt;length); type-&gt;type_data.type_info = (void *) lf; init_stype_info(&amp;type-&gt;type_data); }</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_tpi_stypes</name><parameter_list>(<parameter><decl><type><name>R_STREAM_FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>SType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>leaf_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>read_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>stream_file_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>type</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>leaf_data</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leaf_data</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>stream_file_read</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>leaf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>leaf_type</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>short</name> <operator>*</operator><operator>)</operator><name>leaf_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>read_bytes</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>leaf_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>eLF_FIELDLIST</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_FIELDLIST</name></expr></argument>, <argument><expr><name>lf_fieldlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ENUM</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_ENUM</name></expr></argument>, <argument><expr><name>lf_enum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>eLF_CLASS</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_CLASS</name></expr></argument>, <argument><expr><name>lf_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_STRUCTURE</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_STRUCTURE</name></expr></argument>, <argument><expr><name>lf_structure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_POINTER</name></expr>:</case>

<block>{<block_content>
<decl_stmt><decl><type><name>SLF_POINTER</name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><operator>(</operator><name>SLF_POINTER</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLF_POINTER</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> \
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lf</name></expr>)</condition> <block>{<block_content> \
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>leaf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> \
<return>return <expr><literal type="number">0</literal></expr>;</return> \
</block_content>}</block></if></if_stmt> \
<expr_stmt><expr><call><name>parse_lf_pointer</name><argument_list>(<argument><expr><name>lf</name></expr></argument>, <argument><expr><name>leaf_data</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_bytes</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> \
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>lf</name></expr>;</expr_stmt> \
<expr_stmt><expr><call><name>init_stype_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>type</name><operator>-&gt;</operator><name>type_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> \
</block_content>}</block>

<break>break;</break>
<case>case <expr><name>eLF_ARRAY</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_ARRAY</name></expr></argument>, <argument><expr><name>lf_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MODIFIER</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_MODIFIER</name></expr></argument>, <argument><expr><name>lf_modifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_ARGLIST</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_ARGLIST</name></expr></argument>, <argument><expr><name>lf_arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_MFUNCTION</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_MFUNCTION</name></expr></argument>, <argument><expr><name>lf_mfunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_METHODLIST</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>eLF_PROCEDURE</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_PROCEDURE</name></expr></argument>, <argument><expr><name>lf_procedure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_UNION</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_UNION</name></expr></argument>, <argument><expr><name>lf_union</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_BITFIELD</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_BITFIELD</name></expr></argument>, <argument><expr><name>lf_bitfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>eLF_VTSHAPE</name></expr>:</case>

<expr_stmt><expr><call><name>PARSE_LF</name><argument_list>(<argument><expr><name>SLF_VTSHAPE</name></expr></argument>, <argument><expr><name>lf_vtshape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"parse_tpi_streams(): unsupported leaf type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>leaf_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>read_bytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>parse_tpi_stream</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parsed_pdb_stream</name></decl></parameter>, <parameter><decl><type><name>R_STREAM_FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SType</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STpiStream</name> <modifier>*</modifier></type><name>tpi_stream</name> <init>= <expr><operator>(</operator><name>STpiStream</name> <operator>*</operator><operator>)</operator> <name>parsed_pdb_stream</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tpi_stream</name><operator>-&gt;</operator><name>types</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p_types_list</name> <operator>=</operator> <name><name>tpi_stream</name><operator>-&gt;</operator><name>types</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>stream_file_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STPIHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>tpi_stream</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base_idx</name> <operator>=</operator> <name><name>tpi_stream</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>ti_min</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tpi_stream</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>ti_min</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tpi_stream</name><operator>-&gt;</operator><name>header</name><operator>.</operator><name>ti_max</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>SType</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>SType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>tpi_idx</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>type_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>type_data</name><operator>.</operator><name>leaf_type</name></name> <operator>=</operator> <name>eLF_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_stype_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>type</name><operator>-&gt;</operator><name>type_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_tpi_stypes</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name><argument_list>(<argument><expr><name><name>tpi_stream</name><operator>-&gt;</operator><name>types</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>init_tpi_stream</name><parameter_list>(<parameter><decl><type><name>STpiStream</name> <modifier>*</modifier></type><name>tpi_stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>tpi_stream</name><operator>-&gt;</operator><name>free_</name></name> <operator>=</operator> <name>free_tpi_stream</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
