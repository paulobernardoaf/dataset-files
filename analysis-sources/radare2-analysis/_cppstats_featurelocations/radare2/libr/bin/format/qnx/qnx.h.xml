<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\bin\format\qnx\qnx.h">

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_QNX_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_QNX_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qnx_specs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_bin.h&gt;</cpp:file></cpp:include>

<enum>enum <block>{
<decl><name>LMF_HEADER_REC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>LMF_COMMENT_REC</name></decl>,
<decl><name>LMF_LOAD_REC</name></decl>,
<decl><name>LMF_FIXUP_REC</name></decl>,
<decl><name>LMF_8087_FIXUP_REC</name></decl>,
<decl><name>LMF_IMAGE_END_REC</name></decl>,
<decl><name>LMF_RESOURCE_REC</name></decl>,
<decl><name>LMF_RW_END_REC</name></decl>,
<decl><name>LMF_LINEAR_FIXUP_REC</name></decl>
}</block>;</enum>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_record {
ut8 rec_type;
ut8 reserved; 
ut16 data_nbytes; 
ut16 spare; 
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_record</name></expr>;</expr_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_data {
ut16 segment;
ut32 offset;
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_data</name></expr>;</expr_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_header {
ut16 version;
ut16 cflags;
ut16 cpu; 
ut16 fpu; 
ut16 code_index; 
ut16 stack_index; 
ut16 heap_index; 
ut16 argv_index; 
ut16 spare2[<literal type="number">4</literal>]; 
ut32 code_offset; 
ut32 stack_nbytes; 
ut32 heap_nbytes; 
ut32 image_base; 
ut32 spare3[<literal type="number">2</literal>];
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_header</name></expr>;</expr_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_eof {
ut8 spare[<literal type="number">6</literal>];
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_eof</name></expr>;</expr_stmt>


<enum>enum <block>{
<decl><name>RES_USAGE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
}</block>;</enum>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_resource {
ut16 res_type;
ut16 spare[<literal type="number">3</literal>];
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_resource</name></expr>;</expr_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct lmf_rw_end {
ut16 verify;
ut32 signature;
}</argument>)</argument_list></macro> <expr_stmt><expr><name>lmf_rw_end</name></expr>;</expr_stmt>

<macro><name>R_PACKED</name> <argument_list>(
<argument>typedef struct {
Sdb *kv;
lmf_header lmfh;
RList* fixups;
RList* sections;
lmf_rw_end rwend;
}</argument>)</argument_list></macro> <expr_stmt><expr><name>QnxObj</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif></unit>
