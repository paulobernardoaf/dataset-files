<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\bin\format\mach0\mach0.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mach0.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_hash.h&gt;</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bprintf</name></cpp:macro> <cpp:value>if (bin-&gt;verbose) eprintf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Eprintf</name></cpp:macro> <cpp:value>if (mo-&gt;verbose) eprintf</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>_ulebr</name> <block>{
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
}</block></struct></type> <name>ulebr</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>symbol_t</name></name> <modifier>*</modifier></type><name>symbols</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symbols_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HtPP</name> <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
}</block></struct></type> <name>RSymCtx</name>;</typedef>

<typedef>typedef <macro><name>void</name> <argument_list>(<argument>*RExportsIterator</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name><operator>,</operator> <specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name><operator>,</operator> <name>ut64</name> <name>flags</name><operator>,</operator> <name>ut64</name> <name>offset</name><operator>,</operator> <name>void</name> <operator>*</operator><name>ctx</name><operator>)</operator></expr>;</expr_stmt></typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>next_child</name></decl>;</decl_stmt>
}</block></struct></type> <name>RTrieState</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mach0_endian</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>read_uleb128</name><parameter_list>(<parameter><decl><type><name>ulebr</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>slice</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed uleb128\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>slice</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"uleb128 too big for uint64, bit=%d, result=0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>bit</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><name>slice</name> <operator>&lt;&lt;</operator> <name>bit</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bit</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>;</do>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st64</name></type> <name>read_sleb128</name><parameter_list>(<parameter><decl><type><name>ulebr</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>st64</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name>byte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed sleb128\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>st64</name><operator>)</operator><operator>(</operator><name>byte</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <name>bit</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bit</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"too large sleb128 shift\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>byte</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>byte</name> <operator>&amp;</operator> <literal type="number">0x40</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>-</operator><literal type="number">1LL</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>bit</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>entry_to_vaddr</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>main_cmd</name><operator>.</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_MAIN</name></expr>:</case>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name></expr>;</return>
<case>case <expr><name>LC_UNIXTHREAD</name></expr>:</case>
<case>case <expr><name>LC_THREAD</name></expr>:</case>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>addr_to_offset</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>addr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>segment_base</name></decl>, <decl><type ref="prev"/><name>segment_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>segment_base</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vmaddr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>segment_size</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vmsize</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>segment_base</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name>segment_base</name> <operator>+</operator> <name>segment_size</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fileoff</name> <operator>+</operator> <operator>(</operator><name>addr</name> <operator>-</operator> <name>segment_base</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>offset_to_vaddr</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>offset</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>segment_base</name></decl>, <decl><type ref="prev"/><name>segment_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>segment_base</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fileoff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>segment_size</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>filesize</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name>segment_base</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name>segment_base</name> <operator>+</operator> <name>segment_size</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>+</operator> <operator>(</operator><name>offset</name> <operator>-</operator> <name>segment_base</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>pa2va</name><parameter_list>(<parameter><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bf</name> <operator>||</operator> <operator>!</operator><name><name>bf</name><operator>-&gt;</operator><name>rbin</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RIO</name> <modifier>*</modifier></type><name>io</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>rbin</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>bin</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>o</name><operator>-&gt;</operator><name>bin_obj</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>offset_to_vaddr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>init_sdb_formats</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>




<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_build_platform.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_build_platform"</literal> <literal type="string">"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_build_tool.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_build_tool"</literal> <literal type="string">"{CLANG=1, SWIFT=2, LD=3};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_load_command_type.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_load_command_type"</literal> <literal type="string">"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_header_filetype.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_header_filetype"</literal> <literal type="string">"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_header_flags.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_header_flags"</literal> <literal type="string">"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_section_types.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_section_types"</literal> <literal type="string">"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_section_attrs.cparse"</literal></expr></argument>,
<argument><expr><literal type="string">"enum mach0_section_attrs"</literal> <literal type="string">"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_header.format"</literal></expr></argument>,
<argument><expr><literal type="string">"xxx[4]Edd[4]B "</literal>
<literal type="string">"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_segment.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed[16]zxxxxoodx "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_segment64.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed[16]zqqqqoodx "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_symtab_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxdxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_dysymtab_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edddddddddddxdxdxxxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_section.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[16]z[16]zxxxxxx[1]E[3]Bxx "</literal>
<literal type="string">"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_section64.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[16]z[16]zqqxxxx[1]E[3]Bxxx "</literal>
<literal type="string">"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_dylib.format"</literal></expr></argument>,
<argument><expr><literal type="string">"xxxxz "</literal>
<literal type="string">"name_offset timestamp current_version compatibility_version name"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_dylib_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed? "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_id_dylib_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed? "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_uuid_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed[16]b "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize uuid"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_rpath_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxz "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize path_offset path"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_entry_point_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edqq "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize entryoff stacksize"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_encryption_info64_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxddx "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size id padding"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_encryption_info_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxdd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size id"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_code_signature_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_dyld_info_only_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxdxdxdxdxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_load_dylinker_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxz "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize name_offset name"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_id_dylinker_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxzi "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize name_offset name"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_build_version_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ed[4]Exxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_build_version_tool.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Ex "</literal>
<literal type="string">"(mach0_build_tool)tool version"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_source_version_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edq "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize version"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_function_starts_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_data_in_code_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_version_min_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxx "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize version reserved"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_segment_split_info_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Edxd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize offset size"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_unixthread_command.format"</literal></expr></argument>,
<argument><expr><literal type="string">"[4]Eddd "</literal>
<literal type="string">"(mach0_load_command_type)cmd cmdsize flavor count"</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>init_hdr</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>magicbytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>machohdrbytes</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr></argument>, <argument><expr><name>magicbytes</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedface</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedface</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAT_MAGIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAT_MAGIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedfacf</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedfacf</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return> 
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr></argument>, <argument><expr><name>machohdrbytes</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>machohdrbytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>machohdrbytes</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (hdr)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>cputype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>cpusubtype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>filetype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>ncmds</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>sizeofcmds</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>reserved</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>init_sdb_formats</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_header.offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_segments</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>sect</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>size_sects</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>segcom</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>sec</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_sects</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_sects</name> <operator>||</operator> <name>size_sects</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name></name> <operator>=</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"realloc (seg)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>segcom</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (seg)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cmd</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cmdsize</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmsize</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>fileoff</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>filesize</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmsize</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>fileoff</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>filesize</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>maxprot</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>initprot</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nsects</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>segcom</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_segment64_%d.offset"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_segment_%d.offset"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0_segments.count"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nsects</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sect</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>+=</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nsects</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>&gt;</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_nsects</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\n"</literal></expr></argument>,
<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr></argument>, <argument><expr><name>new_nsects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>new_nsects</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Invalid number of sections\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_sects</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name><operator>-</operator><name>sect</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_sects</name> <operator>||</operator> <name>size_sects</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cmdsize</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> \
<operator>+</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>nsects</name><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator>\
<name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size_sects</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name></name> <operator>=</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"realloc (sects)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>sect</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>j</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (sects)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>=</operator> <name>sect</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_section_%.16s_%.16s.offset"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_section_%.16s_%.16s.format"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mach0_section64"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_section_%.16s_%.16s.format"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mach0_section"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>align</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>reloff</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>nreloc</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>reserved1</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>reserved2</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>reserved3</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Error</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>errorMessage = x; goto error;</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_symtab</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>mo</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>symtab_command</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>size_sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>symt</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>symtab_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>nlst</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>be</name> <init>= <expr><name><name>mo</name><operator>-&gt;</operator><name>big_endian</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>mo</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symtab_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>mo</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>symt</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>symtab_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symtab_command</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (symtab)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>symoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>nsyms</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>stroff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>.</operator><name>strsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>symt</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>nsymtab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>strsize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>st</name><operator>.</operator><name>strsize</name></name> <operator>&lt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>st</name><operator>.</operator><name>nsyms</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>nsymtab</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>nsyms</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>stroff</name></name> <operator>&gt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>st</name><operator>.</operator><name>stroff</name></name> <operator>+</operator> <name><name>st</name><operator>.</operator><name>strsize</name></name> <operator>&gt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_sym</name></expr></argument>, <argument><expr><name><name>mo</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"fail2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_sym</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"symbol size is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>symoff</name></name> <operator>&gt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>st</name><operator>.</operator><name>symoff</name></name> <operator>+</operator> <name>size_sym</name> <operator>&gt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"symoff is out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>mo</name><operator>-&gt;</operator><name>symstr</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>strsize</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"symoff is out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symstrlen</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>strsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>stroff</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name><name>mo</name><operator>-&gt;</operator><name>symstr</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>strsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>st</name><operator>.</operator><name>strsize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"Error: read (symstr)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>mo</name><operator>-&gt;</operator><name>symtab</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mo</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>st</name><operator>.</operator><name>symoff</name></name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>nlst</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name> <argument_list>(<argument><expr><literal type="string">"read (nlist)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_strx</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>nlst</name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_type</name> <operator>=</operator> <call><name>r_read_ble8</name> <argument_list>(<argument><expr><name>nlst</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_sect</name> <operator>=</operator> <call><name>r_read_ble8</name> <argument_list>(<argument><expr><name>nlst</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_desc</name> <operator>=</operator> <call><name>r_read_ble16</name> <argument_list>(<argument><expr><name>nlst</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_value</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>nlst</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_value</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>nlst</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>symstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_dysymtab</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>size_tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>dysym</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dysymtab_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>dytoc</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>dymod</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>dylib_module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>idsyms</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dysymtab_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>dysym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dysymtab_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dysymtab_command</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (dysymtab)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>ilocalsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocalsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iextdefsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextdefsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>tocoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>ntoc</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>modtaboff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nmodtab</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>extrefsymoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">48</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextrefsyms</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">52</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>indirectsymoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">56</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nindirectsyms</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>extreloff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextrel</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">68</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>locreloff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">72</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocrel</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dysym</name><index>[<expr><literal type="number">76</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ntoc</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>ntoc</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ntoc</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>toc</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ntoc</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"calloc (toc)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_tab</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ntoc</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_tab</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>tocoff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>tocoff</name></name> <operator>+</operator> <name>size_tab</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ntoc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>tocoff</name></name> <operator>+</operator>
<name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>dytoc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_table_of_contents</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (toc)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symbol_index</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dytoc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>toc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>module_index</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dytoc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nmodtab</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nmodtab</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nmodtab</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>modtab</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nmodtab</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>dylib_module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"calloc (modtab)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_tab</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nmodtab</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>dylib_module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_tab</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>modtaboff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>modtaboff</name></name> <operator>+</operator> <name>size_tab</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nmodtab</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>modtaboff</name></name> <operator>+</operator>
<name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>dylib_module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>dymod</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>dylib_module</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (modtab)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>module_name</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iextdefsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextdefsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>irefsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nrefsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ilocalsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nlocalsym</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iextrel</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nextrel</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iinit_iterm</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ninit_nterm</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objc_module_info_size</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objc_module_info_addr</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">48</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objc_module_info_addr</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>modtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objc_module_info_size</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dymod</name><index>[<expr><literal type="number">48</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nindirectsyms</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"calloc (indirectsyms)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size_tab</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_tab</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>indirectsymoff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>indirectsymoff</name></name> <operator>+</operator> <name>size_tab</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>indirectsymoff</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>idsyms</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (indirect syms)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>idsyms</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>readString</name> <parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>off</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parseCodeDirectory</name> <parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<typedef>typedef <type><struct>struct <name>__CodeDirectory</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>magic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>version</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>hashOffset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>identOffset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nSpecialSlots</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nCodeSlots</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>codeLimit</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>hashSize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>hashType</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>platform</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>pageSize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>spare2</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint32_t</name></type> <name>scatterOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>teamIDOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>spare3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>codeLimit64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>execSegBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>execSegLimit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>execSegFlags</name></decl>;</decl_stmt>
}</block></struct></type> <name>CS_CodeDirectory</name>;</typedef>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>psize</name> <init>= <expr><name>datasize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Offset: 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CS_CodeDirectory</name></type> <name>cscd</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READFIELD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cscd.x = r_read_ble32 (p + r_offsetof (CS_CodeDirectory, x), 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READFIELD8</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cscd.x = p[r_offsetof (CS_CodeDirectory, x)]</cpp:value></cpp:define>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>hashOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>identOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>nSpecialSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>nCodeSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>teamIDOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD8</name> <argument_list>(<argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READFIELD</name> <argument_list>(<argument><expr><name>codeLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Version: %x\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Flags: %x\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Length: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"PageSize: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>pageSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hashOffset: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>hashOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"codeLimit: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>codeLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hashSize: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>hashSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hashType: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>hashType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>identity</name> <init>= <expr><call><name>readString</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>identOffset</name></name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Identity: %s\n"</literal></expr></argument>, <argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>teamId</name> <init>= <expr><call><name>readString</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>teamIDOffset</name></name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TeamID: %s\n"</literal></expr></argument>, <argument><expr><name>teamId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"CodeSlots: %d\n"</literal></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>nCodeSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>teamId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hashSize</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>algoType</name> <init>= <expr><name>R_HASH_SHA1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashName</name> <init>= <expr><literal type="string">"sha1"</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>cscd</name><operator>.</operator><name>hashType</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> 
<case>case <expr><literal type="number">1</literal></expr>:</case> 
<expr_stmt><expr><name>hashSize</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hashName</name> <operator>=</operator> <literal type="string">"sha1"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>algoType</name> <operator>=</operator> <name>R_HASH_SHA1</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> 
<expr_stmt><expr><name>hashSize</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>algoType</name> <operator>=</operator> <name>R_HASH_SHA256</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hashName</name> <operator>=</operator> <literal type="string">"sha256"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<decl_stmt><decl><type><name>RHash</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>r_hash_new</name> <argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fofsz</name> <init>= <expr><name><name>cscd</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>fofbuf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>fofsz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fofbuf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>fofsz</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid cdhash offset/length values\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_hash_do_begin</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>algoType</name> <operator>==</operator> <name>R_HASH_SHA1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_hash_do_sha1</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_hash_do_sha256</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_hash_do_end</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ph %s @ 0x%"</literal><name>PFMT64x</name><literal type="string">"!%d\n"</literal></expr></argument>, <argument><expr><name>hashName</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ComputedCDHash: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hashSize</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>digest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fofbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>hash</name> <init>= <expr><name>p</name> <operator>+</operator> <name><name>cscd</name><operator>.</operator><name>hashOffset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Hashed region: 0x%08"</literal><name>PFMT64x</name><literal type="string">" - 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>cscd</name><operator>.</operator><name>codeLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cscd</name><operator>.</operator><name>nCodeSlots</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fof</name> <init>= <expr><literal type="number">4096</literal> <operator>*</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>j</name> <operator>*</operator> <name>hashSize</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <name><name>cscd</name><operator>.</operator><name>hashOffset</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>hashSize</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>hash</name><index>[<expr><name>idx</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>fofbuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fofsz</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>fofbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>cscd</name><operator>.</operator><name>codeLimit</name></name> <operator>-</operator> <name>fof</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>fof</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>fofbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_hash_do_begin</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>algoType</name> <operator>==</operator> <name>R_HASH_SHA1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_hash_do_sha1</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_hash_do_sha256</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fofbuf</name></expr></argument>, <argument><expr><name>fofsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_hash_do_end</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name> <argument_list>(<argument><expr><name>hash</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>digest</name></name></expr></argument>, <argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" wx "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hashSize</name></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>digest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" OK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>r_hash_free</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_signature</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>linkedit_data_command</name></name></type> <name>link</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>lit</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blob_index_t</name></name></type> <name>idx</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>super_blob_t</name></name></type> <name>super</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>lit</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to get data while parsing LC_CODE_SIGNATURE command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>link</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>link</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lit</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>link</name><operator>.</operator><name>dataoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lit</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>link</name><operator>.</operator><name>datasize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>lit</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>link</name><operator>.</operator><name>dataoff</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>data</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>super_blob_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Malformed entitlement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>super</name><operator>.</operator><name>blob</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>super</name><operator>.</operator><name>blob</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>super</name><operator>.</operator><name>count</name></name> <operator>=</operator> <call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>verbose</name> <init>= <expr><call><name>r_sys_getenv</name> <argument_list>(<argument><expr><literal type="string">"RABIN2_CODESIGN_VERBOSE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isVerbose</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isVerbose</name> <operator>=</operator> <operator>*</operator><name>verbose</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>super</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data</name> <operator>+</operator> <name>i</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Malformed entitlement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blob_index_t</name></name></type> <name>bi</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <literal type="number">12</literal> <operator>+</operator> <operator>(</operator><name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_index_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>bi</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_index_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_index_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>idx</name><operator>.</operator><name>type</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bi</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bi</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>idx</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CSSLOT_ENTITLEMENTS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>true</name> <operator>||</operator> <name>isVerbose</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Malformed entitlement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blob_t</name></name></type> <name>entitlements</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entitlements</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entitlements</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>mach0_endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>entitlements</name><operator>.</operator><name>length</name></name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name> <operator>&lt;</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>blob_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Malformed entitlement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Malformed entitlement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CSSLOT_CODEDIRECTORY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>isVerbose</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parseCodeDirectory</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>link</name><operator>.</operator><name>datasize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x1000</literal></expr>:</case>

<break>break;</break>
<case>case <expr><name>CSSLOT_CMS_SIGNATURE</name></expr>:</case> 
<if_stmt><if>if <condition>(<expr><name>isVerbose</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>header</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>length</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>UT16_MAX</name></expr></argument>, <argument><expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>header</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name> <modifier>*</modifier></type><name>words</name> <init>= <expr><operator>(</operator><name>ut32</name><operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Magic: %x\n"</literal></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"wtf DUMP @%d!%d\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"openssl pkcs7 -print_certs -text -inform der -in DUMP\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"pFp@%d!%d\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CSSLOT_REQUIREMENTS</name></expr>:</case> 
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>p</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name><name>idx</name><operator>.</operator><name>offset</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>slot_size</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>slot_size</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>ident_size</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ident</name> <init>= <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>, <argument><expr><name>ident_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ident</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.ident"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid code slot size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>CSSLOT_INFOSLOT</name></expr>:</case> 
<case>case <expr><name>CSSLOT_RESOURCEDIR</name></expr>:</case> 
<case>case <expr><name>CSSLOT_APPLICATION</name></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"TODO: Some codesign slots are not yet supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown Code signature slot %d\n"</literal></expr></argument>, <argument><expr><name><name>idx</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>signature</name></name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"No entitlement found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_thread</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr>struct <name>load_command</name> <operator>*</operator><name>lc</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>, <argument><expr><name>bool</name> <name>is_first_thread</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr_thread</name></decl>, <decl><type ref="prev"/><name>pc</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>pc_offset</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>flavor</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>arw_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arw_sz</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>thc</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>tmp</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>thc</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>wrong_read</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>thread</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>thc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>thread</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>thc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>wrong_read</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>flavor</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>wrong_read</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>flavor</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator>
<name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>flavor</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>flavor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>wrong_read</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_thread</name> <operator>=</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>thread_command</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>flavor</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>cputype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_TYPE_I386</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_X86_64</name></expr>:</case>
<switch>switch <condition>(<expr><name>flavor</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>X86_THREAD_STATE32</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>x86_thread_state32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_32</name></name></expr></argument>, <argument><expr><literal type="string">"16i"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state x86_32)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_32</name><operator>.</operator><name>eip</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name><argument_list>(<argument><expr>struct <name>x86_thread_state32</name></expr></argument>, <argument><expr><name>eip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>x86_thread_state32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>X86_THREAD_STATE64</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>x86_thread_state64</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_64</name></name></expr></argument>, <argument><expr><literal type="string">"32l"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state x86_64)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_64</name><operator>.</operator><name>rip</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name><argument_list>(<argument><expr>struct <name>x86_thread_state64</name></expr></argument>, <argument><expr><name>rip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>x86_64</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>x86_thread_state64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>

</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_POWERPC64</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flavor</name> <operator>==</operator> <name>X86_THREAD_STATE32</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>ppc_thread_state32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_32</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr>?</condition><then><expr><literal type="string">"40I"</literal></expr></then><else>:<expr><literal type="string">"40i"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state ppc_32)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_32</name><operator>.</operator><name>srr0</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name><argument_list>(<argument><expr>struct <name>ppc_thread_state32</name></expr></argument>, <argument><expr><name>srr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>ppc_thread_state32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flavor</name> <operator>==</operator> <name>X86_THREAD_STATE64</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>ppc_thread_state64</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_64</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr>?</condition><then><expr><literal type="string">"34LI3LI"</literal></expr></then><else>:<expr><literal type="string">"34li3li"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state ppc_64)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_64</name><operator>.</operator><name>srr0</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name><argument_list>(<argument><expr>struct <name>ppc_thread_state64</name></expr></argument>, <argument><expr><name>srr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>ppc_64</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>ppc_thread_state64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_ARM</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>arm_thread_state32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_32</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr>?</condition><then><expr><literal type="string">"17I"</literal></expr></then><else>:<expr><literal type="string">"17i"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state arm)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_32</name><operator>.</operator><name>r15</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name> <argument_list>(<argument><expr>struct <name>arm_thread_state32</name></expr></argument>, <argument><expr><name>r15</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>arm_thread_state32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_ARM64</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr_thread</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>arm_thread_state64</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>r_buf_fread_at</name><argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>ptr_thread</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_64</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr>?</condition><then><expr><literal type="string">"34LI1I"</literal></expr></then><else>:<expr><literal type="string">"34Li1i"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread state arm)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>r_read_be64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_64</name><operator>.</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pc_offset</name> <operator>=</operator> <name>ptr_thread</name> <operator>+</operator> <call><name>r_offsetof</name> <argument_list>(<argument><expr>struct <name>arm_thread_state64</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>thread_state</name><operator>.</operator><name>arm_64</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arw_sz</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>arm_thread_state64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (unknown thread state structure)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>


<if_stmt><if>if <condition>(<expr><name>arw_ptr</name> <operator>&amp;&amp;</operator> <name>arw_sz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arw_ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"arw "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arw_sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><literal type="number">0xff</literal> <operator>&amp;</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_first_thread</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_cmd</name></name> <operator>=</operator> <operator>*</operator><name>lc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pc_offset</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry.offset"</literal></expr></argument>, <argument><expr><name>pc_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
<label><name>wrong_read</name>:</label>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (thread)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_function_starts</name> <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>linkedit_data_command</name></name></type> <name>fc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>sfc</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Likely overflow while parsing"</literal>
<literal type="string">" LC_FUNCTION_STARTS command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>func_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>sfc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>linkedit_data_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to get data while parsing"</literal>
<literal type="string">" LC_FUNCTION_STARTS command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>fc</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sfc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fc</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sfc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fc</name><operator>.</operator><name>dataoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sfc</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fc</name><operator>.</operator><name>datasize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sfc</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>fc</name><operator>.</operator><name>datasize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>fc</name><operator>.</operator><name>datasize</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to allocate buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>func_size</name></name> <operator>=</operator> <name><name>fc</name><operator>.</operator><name>datasize</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fc</name><operator>.</operator><name>dataoff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>fc</name><operator>.</operator><name>dataoff</name></name> <operator>+</operator> <name><name>fc</name><operator>.</operator><name>datasize</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Likely overflow while parsing "</literal>
<literal type="string">"LC_FUNCTION_STARTS command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>fc</name><operator>.</operator><name>dataoff</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fc</name><operator>.</operator><name>datasize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>fc</name><operator>.</operator><name>datasize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to get data while parsing"</literal>
<literal type="string">" LC_FUNCTION_STARTS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name><name>fc</name><operator>.</operator><name>datasize</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>func_start</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>func_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_dylib</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>ut64</name> <name>off</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dylib_command</name></name></type> <name>dl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lib</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>sdl</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lib</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>relibs</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name> <operator>*</operator> <name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relibs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"realloc (libs)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name></name> <operator>=</operator> <name>relibs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>sdl</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylib_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (dylib)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>current_version</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>compatibility_version</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdl</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator>\
<name>off</name> <operator>+</operator> <name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>name</name></name> <operator>+</operator> <name>R_BIN_MACH0_STRING_LENGTH</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>lib</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <name><name>dl</name><operator>.</operator><name>dylib</name><operator>.</operator><name>name</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>lib</name></expr>]</index></name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>lib</name></expr>]</index><index>[<expr><name>R_BIN_MACH0_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (dylib str)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_to_string</name><parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_DATA_IN_CODE</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DATA_IN_CODE"</literal></expr>;</return>
<case>case <expr><name>LC_CODE_SIGNATURE</name></expr>:</case>
<return>return <expr><literal type="string">"LC_CODE_SIGNATURE"</literal></expr>;</return>
<case>case <expr><name>LC_RPATH</name></expr>:</case>
<return>return <expr><literal type="string">"LC_RPATH"</literal></expr>;</return>
<case>case <expr><name>LC_TWOLEVEL_HINTS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_TWOLEVEL_HINTS"</literal></expr>;</return>
<case>case <expr><name>LC_PREBIND_CKSUM</name></expr>:</case>
<return>return <expr><literal type="string">"LC_PREBIND_CKSUM"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SEGMENT"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT_64</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SEGMENT_64"</literal></expr>;</return>
<case>case <expr><name>LC_SYMTAB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SYMTAB"</literal></expr>;</return>
<case>case <expr><name>LC_SYMSEG</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SYMSEG"</literal></expr>;</return>
<case>case <expr><name>LC_DYSYMTAB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DYSYMTAB"</literal></expr>;</return>
<case>case <expr><name>LC_PREBOUND_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_PREBOUND_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_ROUTINES</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ROUTINES"</literal></expr>;</return>
<case>case <expr><name>LC_ROUTINES_64</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ROUTINES_64"</literal></expr>;</return>
<case>case <expr><name>LC_SUB_FRAMEWORK</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SUB_FRAMEWORK"</literal></expr>;</return>
<case>case <expr><name>LC_SUB_UMBRELLA</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SUB_UMBRELLA"</literal></expr>;</return>
<case>case <expr><name>LC_SUB_CLIENT</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SUB_CLIENT"</literal></expr>;</return>
<case>case <expr><name>LC_SUB_LIBRARY</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SUB_LIBRARY"</literal></expr>;</return>
<case>case <expr><name>LC_FUNCTION_STARTS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_FUNCTION_STARTS"</literal></expr>;</return>
<case>case <expr><name>LC_DYLIB_CODE_SIGN_DRS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DYLIB_CODE_SIGN_DRS"</literal></expr>;</return>
<case>case <expr><name>LC_NOTE</name></expr>:</case>
<return>return <expr><literal type="string">"LC_NOTE"</literal></expr>;</return>
<case>case <expr><name>LC_BUILD_VERSION</name></expr>:</case>
<return>return <expr><literal type="string">"LC_BUILD_VERSION"</literal></expr>;</return>
<case>case <expr><name>LC_VERSION_MIN_MACOSX</name></expr>:</case>
<return>return <expr><literal type="string">"LC_VERSION_MIN_MACOSX"</literal></expr>;</return>
<case>case <expr><name>LC_VERSION_MIN_IPHONEOS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_VERSION_MIN_IPHONEOS"</literal></expr>;</return>
<case>case <expr><name>LC_VERSION_MIN_TVOS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_VERSION_MIN_TVOS"</literal></expr>;</return>
<case>case <expr><name>LC_VERSION_MIN_WATCHOS</name></expr>:</case>
<return>return <expr><literal type="string">"LC_VERSION_MIN_WATCHOS"</literal></expr>;</return>
<case>case <expr><name>LC_DYLD_INFO</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DYLD_INFO"</literal></expr>;</return>
<case>case <expr><name>LC_DYLD_INFO_ONLY</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DYLD_INFO_ONLY"</literal></expr>;</return>
<case>case <expr><name>LC_DYLD_ENVIRONMENT</name></expr>:</case>
<return>return <expr><literal type="string">"LC_DYLD_ENVIRONMENT"</literal></expr>;</return>
<case>case <expr><name>LC_SOURCE_VERSION</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SOURCE_VERSION"</literal></expr>;</return>
<case>case <expr><name>LC_MAIN</name></expr>:</case>
<return>return <expr><literal type="string">"LC_MAIN"</literal></expr>;</return>
<case>case <expr><name>LC_UUID</name></expr>:</case>
<return>return <expr><literal type="string">"LC_UUID"</literal></expr>;</return>
<case>case <expr><name>LC_ID_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ID_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_ID_DYLINKER</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ID_DYLINKER"</literal></expr>;</return>
<case>case <expr><name>LC_LAZY_LOAD_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LAZY_LOAD_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_ENCRYPTION_INFO</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ENCRYPTION_INFO"</literal></expr>;</return>
<case>case <expr><name>LC_ENCRYPTION_INFO_64</name></expr>:</case>
<return>return <expr><literal type="string">"LC_ENCRYPTION_INFO_64"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT_SPLIT_INFO</name></expr>:</case>
<return>return <expr><literal type="string">"LC_SEGMENT_SPLIT_INFO"</literal></expr>;</return>
<case>case <expr><name>LC_REEXPORT_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_REEXPORT_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_LINKER_OPTION</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LINKER_OPTION"</literal></expr>;</return>
<case>case <expr><name>LC_LINKER_OPTIMIZATION_HINT</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LINKER_OPTIMIZATION_HINT"</literal></expr>;</return>
<case>case <expr><name>LC_LOAD_DYLINKER</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LOAD_DYLINKER"</literal></expr>;</return>
<case>case <expr><name>LC_LOAD_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LOAD_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_LOAD_WEAK_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LOAD_WEAK_DYLIB"</literal></expr>;</return>
<case>case <expr><name>LC_THREAD</name></expr>:</case>
<return>return <expr><literal type="string">"LC_THREAD"</literal></expr>;</return>
<case>case <expr><name>LC_UNIXTHREAD</name></expr>:</case>
<return>return <expr><literal type="string">"LC_UNIXTHREAD"</literal></expr>;</return>
<case>case <expr><name>LC_LOADFVMLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_LOADFVMLIB"</literal></expr>;</return>
<case>case <expr><name>LC_IDFVMLIB</name></expr>:</case>
<return>return <expr><literal type="string">"LC_IDFVMLIB"</literal></expr>;</return>
<case>case <expr><name>LC_IDENT</name></expr>:</case>
<return>return <expr><literal type="string">"LC_IDENT"</literal></expr>;</return>
<case>case <expr><name>LC_FVMFILE</name></expr>:</case>
<return>return <expr><literal type="string">"LC_FVMFILE"</literal></expr>;</return>
<case>case <expr><name>LC_PREPAGE</name></expr>:</case>
<return>return <expr><literal type="string">"LC_PREPAGE"</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_to_pf_definition</name><parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_BUILD_VERSION</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_build_version_command"</literal></expr>;</return>
<case>case <expr><name>LC_CODE_SIGNATURE</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_code_signature_command"</literal></expr>;</return>
<case>case <expr><name>LC_DATA_IN_CODE</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_data_in_code_command"</literal></expr>;</return>
<case>case <expr><name>LC_DYLD_INFO</name></expr>:</case>
<case>case <expr><name>LC_DYLD_INFO_ONLY</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_dyld_info_only_command"</literal></expr>;</return>
<case>case <expr><name>LC_DYLD_ENVIRONMENT</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_DYLIB_CODE_SIGN_DRS</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_DYSYMTAB</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_dysymtab_command"</literal></expr>;</return>
<case>case <expr><name>LC_ENCRYPTION_INFO</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_encryption_info_command"</literal></expr>;</return>
<case>case <expr><name>LC_ENCRYPTION_INFO_64</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_encryption_info64_command"</literal></expr>;</return>
<case>case <expr><name>LC_FUNCTION_STARTS</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_function_starts_command"</literal></expr>;</return>
<case>case <expr><name>LC_FVMFILE</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_ID_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_id_dylib_command"</literal></expr>;</return>
<case>case <expr><name>LC_ID_DYLINKER</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_id_dylinker_command"</literal></expr>;</return>
<case>case <expr><name>LC_IDENT</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_IDFVMLIB</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_LINKER_OPTION</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_LINKER_OPTIMIZATION_HINT</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_LOAD_DYLINKER</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_load_dylinker_command"</literal></expr>;</return>
<case>case <expr><name>LC_LAZY_LOAD_DYLIB</name></expr>:</case>
<case>case <expr><name>LC_LOAD_WEAK_DYLIB</name></expr>:</case>
<case>case <expr><name>LC_LOAD_DYLIB</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_dylib_command"</literal></expr>;</return>
<case>case <expr><name>LC_LOADFVMLIB</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_MAIN</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_entry_point_command"</literal></expr>;</return>
<case>case <expr><name>LC_NOTE</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_PREBIND_CKSUM</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_PREBOUND_DYLIB</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_PREPAGE</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_REEXPORT_DYLIB</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_ROUTINES</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_ROUTINES_64</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_RPATH</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_rpath_command"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_segment"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT_64</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_segment64"</literal></expr>;</return>
<case>case <expr><name>LC_SEGMENT_SPLIT_INFO</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_segment_split_info_command"</literal></expr>;</return>
<case>case <expr><name>LC_SOURCE_VERSION</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_source_version_command"</literal></expr>;</return>
<case>case <expr><name>LC_SUB_FRAMEWORK</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_SUB_UMBRELLA</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_SUB_CLIENT</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_SUB_LIBRARY</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_SYMTAB</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_symtab_command"</literal></expr>;</return>
<case>case <expr><name>LC_SYMSEG</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_TWOLEVEL_HINTS</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_UUID</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_uuid_command"</literal></expr>;</return>
<case>case <expr><name>LC_VERSION_MIN_MACOSX</name></expr>:</case>
<case>case <expr><name>LC_VERSION_MIN_IPHONEOS</name></expr>:</case>
<case>case <expr><name>LC_VERSION_MIN_TVOS</name></expr>:</case>
<case>case <expr><name>LC_VERSION_MIN_WATCHOS</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_version_min_command"</literal></expr>;</return>
<case>case <expr><name>LC_THREAD</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>LC_UNIXTHREAD</name></expr>:</case>
<return>return <expr><literal type="string">"mach0_unixthread_command"</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>build_version_platform_to_string</name><parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>platform</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>platform</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><literal type="string">"macOS"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><literal type="string">"iOS"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<return>return <expr><literal type="string">"tvOS"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<return>return <expr><literal type="string">"watchOS"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<return>return <expr><literal type="string">"bridgeOS"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case>
<return>return <expr><literal type="string">"iOSmac"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<return>return <expr><literal type="string">"iOS Simulator"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<return>return <expr><literal type="string">"tvOS Simulator"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case>
<return>return <expr><literal type="string">"watchOS Simulator"</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>build_version_tool_to_string</name><parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>tool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>tool</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><literal type="string">"clang"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><literal type="string">"swift"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<return>return <expr><literal type="string">"ld"</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>init_items</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>load_command</name></name></type> <name>lc</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>loadc</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>load_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_first_thread</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>uuidn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>has_crypto</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>sizeofcmds</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: chopping hdr.sizeofcmds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>sizeofcmds</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">128</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>off</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</init> \
<condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>ncmds</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>off</name> <operator>+=</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>load_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0: out of bounds command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>loadc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>load_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (lc) at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>loadc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>loadc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>off</name> <operator>+</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: mach0_header %d = cmdsize&lt;1. (0x%llx vs 0x%llx)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>off</name> <operator>+</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.offset"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format_name</name> <init>= <expr><call><name>cmd_to_pf_definition</name> <argument_list>(<argument><expr><name><name>lc</name><operator>.</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.format"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>format_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.format"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"[4]Ed (mach_load_command_type)cmd size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>lc</name><operator>.</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_DATA_IN_CODE</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"data_in_code"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LC_RPATH</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"rpath"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>LC_SEGMENT_64</name></expr>:</case>
<case>case <expr><name>LC_SEGMENT</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"segment"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_segments</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"error parsing segment\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>LC_SYMTAB</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"symtab"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_symtab</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"error parsing symtab\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>LC_DYSYMTAB</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dysymtab"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_dysymtab</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"error parsing dysymtab\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>LC_DYLIB_CODE_SIGN_DRS</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dylib_code_sign_drs"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>LC_VERSION_MIN_MACOSX</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"version_min_macosx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<break>break;</break>
<case>case <expr><name>LC_VERSION_MIN_IPHONEOS</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"version_min_iphoneos"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>


<break>break;</break>
<case>case <expr><name>LC_VERSION_MIN_TVOS</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"version_min_tvos"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LC_VERSION_MIN_WATCHOS</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"version_min_watchos"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LC_UUID</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"uuid"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>uuid_command</name></name></type> <name>uc</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>uuid_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"UUID out of bounds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_fread_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>uc</name></expr></argument>, <argument><expr><literal type="string">"24c"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>val</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"uuid.%d"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>uuidn</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_hex_bin2str</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>uc</name><operator>.</operator><name>uuid</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_ENCRYPTION_INFO_64</name></expr>:</case>

<case>case <expr><name>LC_ENCRYPTION_INFO</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"encryption_info"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>encryption_info_command</name></expr></argument>)</argument_list> <name>eic</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>seic</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>encryption_info_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>encryption_info_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"encryption info out of bounds\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>seic</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>encryption_info_command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>eic</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>seic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eic</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>seic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eic</name><operator>.</operator><name>cryptoff</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>seic</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eic</name><operator>.</operator><name>cryptsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>seic</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eic</name><operator>.</operator><name>cryptid</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>seic</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>has_crypto</name></name> <operator>=</operator> <name><name>eic</name><operator>.</operator><name>cryptid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"crypto"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"cryptid"</literal></expr></argument>, <argument><expr><name><name>eic</name><operator>.</operator><name>cryptid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"cryptoff"</literal></expr></argument>, <argument><expr><name><name>eic</name><operator>.</operator><name>cryptoff</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"cryptsize"</literal></expr></argument>, <argument><expr><name><name>eic</name><operator>.</operator><name>cryptsize</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"cryptheader"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt> </block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_LOAD_DYLINKER</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dylinker"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>intrp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dylinker_command</name></name></type> <name>dy</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>sdy</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylinker_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylinker_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Cannot parse dylinker command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>sdy</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dylinker_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: read (LC_DYLD_INFO) at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dy</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dy</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdy</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dy</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdy</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>dy</name><operator>.</operator><name>cmdsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <literal type="number">0xc</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>intrp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>intrp</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_MAIN</name></expr>:</case>
<block>{<block_content>
<struct>struct <block>{
<decl_stmt><decl><type><name>ut64</name></type> <name>eo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ss</name></decl>;</decl_stmt>
}</block> <decl><name>ep</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>sep</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_first_thread</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: LC_MAIN with other threads\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <literal type="number">8</literal> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"invalid command size for main\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ep</name><operator>.</operator><name>eo</name></name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ep</name><operator>.</operator><name>ss</name></name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sep</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name><name>ep</name><operator>.</operator><name>eo</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_cmd</name></name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry.offset"</literal></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"stacksize"</literal></expr></argument>, <argument><expr><name><name>ep</name><operator>.</operator><name>ss</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_first_thread</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_UNIXTHREAD</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"unixthread"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_first_thread</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name><argument_list>(<argument><expr><literal type="string">"Error: LC_UNIXTHREAD with other threads\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<case>case <expr><name>LC_THREAD</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"thread"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_thread</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>is_first_thread</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>is_first_thread</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LC_LOAD_DYLIB</name></expr>:</case>
<case>case <expr><name>LC_LOAD_WEAK_DYLIB</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"load_dylib"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_dylib</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse dylib\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>LC_DYLD_INFO</name></expr>:</case>
<case>case <expr><name>LC_DYLD_INFO_ONLY</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>dyldi</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dyld_info_command</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dyld_info"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dyld_info_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>dyld_info_command</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse dyldinfo\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>dyldi</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>dyld_info_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (LC_DYLD_INFO) at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>rebase_off</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>rebase_size</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_size</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>weak_bind_off</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>weak_bind_size</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_off</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_size</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">36</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>export_off</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>export_size</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>dyldi</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_CODE_SIGNATURE</name></expr>:</case>
<expr_stmt><expr><call><name>parse_signature</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"signature"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<break>break;</break>
<case>case <expr><name>LC_SOURCE_VERSION</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<break>break;</break>
<case>case <expr><name>LC_SEGMENT_SPLIT_INFO</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"split_info"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>LC_FUNCTION_STARTS</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"function_starts"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_function_starts</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse LC_FUNCTION_STARTS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>LC_REEXPORT_DYLIB</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dylib"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<default>default:</default>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>off</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</init> \
<condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>ncmds</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>off</name> <operator>+=</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>loadc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>load_command</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (lc) at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lc</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>loadc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>loadc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>off</name> <operator>+</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: mach0_header %d = cmdsize&lt;1. (0x%llx vs 0x%llx)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>off</name> <operator>+</operator> <name><name>lc</name><operator>.</operator><name>cmdsize</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.offset"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format_name</name> <init>= <expr><call><name>cmd_to_pf_definition</name> <argument_list>(<argument><expr><name><name>lc</name><operator>.</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.format"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>format_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.format"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"[4]Ed (mach_load_command_type)cmd size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>lc</name><operator>.</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_DATA_IN_CODE</name></expr>:</case>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"mach0_cmd_%d.cmd"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"data_in_code"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>dataoff</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>datasize</name><init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"data-in-code at 0x%x size %d\n"</literal></expr></argument>, <argument><expr><name>dataoff</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><call><name>malloc</name> <argument_list>(<argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>db</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>dataoff</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>datasize</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>dw</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>db</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_read_ble16</name> <argument_list>(<argument><expr><name>db</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>va</name> <init>= <expr><call><name>offset_to_vaddr</name><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cd 4 %d @ 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>len</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>init</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>mo</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_hdr</name> <argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: File is not MACH0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_items</name> <argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Cannot initialize items\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>mo</name><operator>-&gt;</operator><name>baddr</name></name> <operator>=</operator> <call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_baddr</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>mach0_free</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>mo</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mo</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>symbols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>segs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>sects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>symtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>symstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>imports_by_ord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mo</name><operator>-&gt;</operator><name>imports_by_name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>imports_by_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>dyld_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>modtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>libs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>func_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>signature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>intrp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>compiler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name><name>mo</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>opts_set_default</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>opts_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>options</name></expr></argument>, <argument><expr><name>RBinFile</name> <operator>*</operator><name>bf</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>header_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bf</name> <operator>&amp;&amp;</operator> <name><name>bf</name><operator>-&gt;</operator><name>rbin</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name><name>bf</name><operator>-&gt;</operator><name>rbin</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>duplicate_ptr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_only_key</name><parameter_list>(<parameter><decl><type><name>HtPPKv</name> <modifier>*</modifier></type><name>kv</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ptr_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">8</literal></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>MACH0_</name><argument_list>(<argument><expr><name>mach0_new</name></expr></argument>)</argument_list><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>file</name></expr></argument>, <argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>opts_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>options</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>bin</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>options</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>binsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>binsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>binsz</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>mach0_free</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <call><name>r_buf_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_buf_set_bytes</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>mach0_free</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>mach0_free</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_name</name></name> <operator>=</operator> <call><name>ht_pp_new</name> <argument_list>(<argument><expr><operator>(</operator><name>HtPPDupValue</name><operator>)</operator><name>duplicate_ptr</name></expr></argument>, <argument><expr><name>free_only_key</name></expr></argument>, <argument><expr><operator>(</operator><name>HtPPCalcSizeV</name><operator>)</operator><name>ptr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>bin</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>MACH0_</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>)</argument_list><argument_list>(<argument><expr><name>RBuffer</name> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>opts_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>options</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>bin</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <call><name>r_buf_ref</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name> <operator>=</operator> <call><name>sdb_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"bin.mach0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>options</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>mach0_free</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>bin</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function><type><specifier>static</specifier> <name>int</name></type> <name>prot2perm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__isDataSection</name><parameter_list>(<parameter><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>sect</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>sect</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"_cstring"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>sect</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"_objc_methname"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>sect</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"_objc_classname"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>sect</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"_objc_methtype"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RList</name> <modifier>*</modifier><name>MACH0_</name></type>(<name>get_segments</name>)<parameter_list>(<parameter><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list> <modifier>*</modifier><name>bin</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>o</name><operator>-&gt;</operator><name>bin_obj</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>r_bin_section_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list> <modifier>*</modifier><name>seg</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>seg</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seg</name><operator>-&gt;</operator><name>initprot</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_bin_section_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>fileoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name> <operator>+=</operator> <name><name>bf</name><operator>-&gt;</operator><name>o</name><operator>-&gt;</operator><name>boffset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_ndup</name> <argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>segname</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name> <operator>=</operator> <call><name>prot2perm</name> <argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>initprot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>add</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>last_section</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last_section</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinSection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>==</operator> <name>S_ZEROFILL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>segment_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmsize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name> <operator>=</operator> <call><name>prot2perm</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>initprot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>segment_index</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segment_name</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d.%s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>segment_index</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>segment_name</name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>is_data</name></name> <operator>=</operator> <call><name>__isDataSection</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">"interpos"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">"__mod_"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ws</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ws</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"Cd %d[%"</literal><name>PFMT64d</name><literal type="string">"]"</literal></expr></argument>, <argument><expr><name>ws</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name> <operator>/</operator> <name>ws</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>segment_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name><name>struct</name> <name>section_t</name></name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_sections</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section_t</name></name> <modifier>*</modifier></type><name>sections</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>segname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>sectname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>raw_segname</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>segment_command</name></expr></argument>)</argument_list> <modifier>*</modifier><name>seg</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sections</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>section_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>seg</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmaddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>fileoff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vsize</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>vmsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>align</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>sectname</name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>segname</name></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sectname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name>sectname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>perm</name> <operator>=</operator> <call><name>prot2perm</name> <argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>initprot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>sections</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sections</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>section_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>==</operator> <name>S_ZEROFILL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vsize</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>align</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>align</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name>sectname</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name>sectname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>raw_segname</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segname</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>raw_segname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>segname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>segname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d.%s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>raw_segname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>&amp;&amp;</operator>
<name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>&lt;</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>vmsize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>perm</name> <operator>=</operator> <call><name>prot2perm</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>initprot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>




<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>segname</name></expr></argument>, <argument><expr><name>sectname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>sections</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_import_stub</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr>struct <name>symbol_t</name> <operator>*</operator><name>symbol</name></expr></argument>, <argument><expr><name>int</name> <name>idx</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nsyms</name></decl>, <decl><type ref="prev"/><name>stridx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symstr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>is_imported</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>SECTION_TYPE</name><operator>)</operator> <operator>==</operator> <name>S_SYMBOL_STUBS</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>sect_size</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>sect_fragment</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved2</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0: section offset starts way beyond the end of the file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sect_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0: Invalid symbol table size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sect_size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nsyms</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>sect_size</name> <operator>/</operator> <name>sect_fragment</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved1</name> <operator>+</operator> <name>j</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved1</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_LOCAL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name>j</name> <operator>*</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved2</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0: corrupted reserved2 value leads to int overflow.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbol</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>stridx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>stridx</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>symstrlen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name> <operator>+</operator> <name>stridx</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>symstr</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>symstr</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symstr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>symstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>inSymtab</name><parameter_list>(<parameter><decl><type><name>HtPP</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s.%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ht_pp_find</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ht_pp_insert</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_name</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>mo</name></expr></argument>, <argument><expr><name>ut32</name> <name>stridx</name></expr></argument>, <argument><expr><name>bool</name> <name>filter</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>stridx</name> <operator>&gt;=</operator> <name><name>mo</name><operator>-&gt;</operator><name>symstrlen</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>mo</name><operator>-&gt;</operator><name>symstrlen</name></name> <operator>-</operator> <name>stridx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symstr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>mo</name><operator>-&gt;</operator><name>symstr</name></name> <operator>+</operator> <name>stridx</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>(</operator><name><name>symstr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal> <operator>||</operator> <operator>!</operator><name><name>symstr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>symstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_filter</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>walk_exports</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>RExportsIterator</name> <name>iterator</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator> <name>ctx</name></expr></argument>)</argument_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULEB</name><parameter_list>(<parameter><type><name>at</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>read_uleb128 (&amp;ur, end)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulebr</name></type> <name>ur</name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type> <name>trie</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type> <name>states</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>export_size</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>trie</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trie</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type> <name>end</name> <init>= <expr><name>trie</name> <operator>+</operator> <name>size</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>export_off</name></name></expr></argument>, <argument><expr><name>trie</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>export_size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>states</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>states</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RTrieState</name> <modifier>*</modifier></type> <name>root</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RTrieState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>root</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>trie</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>states</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>RTrieState</name> <modifier>*</modifier></type> <name>state</name> <init>= <expr><call><name>r_list_get_top</name> <argument_list>(<argument><expr><name>states</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>len</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>flags</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>resolver</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isReexport</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>EXPORT_SYMBOL_FLAGS_REEXPORT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>hasResolver</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>hasResolver</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>resolver</name> <operator>=</operator> <name>res</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isReexport</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>ur</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isReexport</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>bin</name><operator>-&gt;</operator><name>header_at</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>iterator</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isReexport</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTrieState</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>states</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed export trie\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>hasResolver</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>stub_name</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"stub.%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>iterator</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stub_name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iterator</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>stub_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>iterator</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isReexport</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>hasResolver</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>child_count</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>child_count</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>i</name></name> <operator>==</operator> <name>child_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_pop</name> <argument_list>(<argument><expr><name>states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>next_child</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_child</name></name> <operator>=</operator> <name><name>ur</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>next_child</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>RTrieState</name> <modifier>*</modifier></type> <name>next</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RTrieState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ur</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed export trie\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>tr</name> <init>= <expr><call><name>ULEB</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>tr</name> <operator>+</operator> <name>trie</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>next</name><operator>-&gt;</operator><name>node</name></name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed export trie\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RTrieState</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>states</argument>, <argument>it</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed export trie\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block>
<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_child</name></name> <operator>=</operator> <name><name>ur</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>states</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>states</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ULEB</name></cpp:undef>

<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>trie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_exports_list</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>ut64</name> <name>flags</name></expr></argument>, <argument><expr><name>ut64</name> <name>offset</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator> <name>ctx</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>(</operator><name>RList</name><operator>*</operator><operator>)</operator> <name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>sym</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinSymbol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sym</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <call><name>offset_to_vaddr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"EXT"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>bind</name></name> <operator>=</operator> <name>R_BIN_BIND_GLOBAL_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_symbols_list</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type> <name>cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>symbol_t</name></name> <modifier>*</modifier></type><name>symbols</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>stridx</name></decl>, <decl><type ref="prev"/><name>symbols_size</name></decl>, <decl><type ref="prev"/><name>symbols_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>to</name></decl>, <decl><type ref="prev"/><name>from</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cache</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>r_bin_symbol_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cache</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>HtPP</name> <modifier>*</modifier></type><name>hash</name> <init>= <expr><call><name>ht_pp_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hash</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>walk_exports</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>fill_exports_list</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>it</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>inSymtab</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>symbols_count</name> <operator>=</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextdefsym</name></name> <operator>+</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocalsym</name></name> <operator>+</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>symbols_count</name> <operator>+=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbols_size</name> <operator>=</operator> <operator>(</operator><name>symbols_count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>symbols_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>symbols</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>symbols_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iextdefsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextdefsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>ilocalsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocalsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOT_USED</name></expr></cpp:if>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>maxsymbols</name> <init>= <expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>symbols_count</name> <operator>&gt;=</operator> <name>maxsymbols</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symbols_count</name> <operator>=</operator> <name>maxsymbols</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"macho warning: Symbol table truncated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>symbols_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>sym</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinSymbol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_type</name> <operator>&amp;</operator> <name>N_EXT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"EXT"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"LOCAL"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stridx</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sym_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>sym_name</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"__Dmain"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"4main"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"STATIC"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"_main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"unk%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>inSymtab</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>symbol_t</name></name></type> <name>symbol</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>symbols_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0-get-symbols: error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_import_stub</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>symbol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>sym</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinSymbol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <name><name>symbol</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <name><name>symbol</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>symbol</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sym</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"unk%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>is_imported</name></name> <operator>=</operator> <name><name>symbol</name><operator>.</operator><name>is_imported</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list> <modifier>*</modifier><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>n_strx</name></name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>section</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>n_sect</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>section</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>symbols_count</name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>sym</name> <init>= <expr><call><name>R_NEW0</name><argument_list>(<argument><expr><name>RBinSymbol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>is_imported</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>is_imported</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>n_type</name></name> <operator>&amp;</operator> <name>N_EXT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"EXT"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="string">"LOCAL"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sym_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>sym_name</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>inSymtab</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>vaddr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_bin_symbol_free</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"__Dmain"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"4main"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"STATIC"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"_main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"unk%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_export_symbol_t</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>ut64</name> <name>flags</name></expr></argument>, <argument><expr><name>ut64</name> <name>offset</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>ctx</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>RSymCtx</name> <modifier>*</modifier></type><name>sym_ctx</name> <init>= <expr><operator>(</operator><name>RSymCtx</name><operator>*</operator><operator>)</operator> <name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>j</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols_count</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <call><name>offset_to_vaddr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>inSymtab</name> <argument_list>(<argument><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_EXT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>-&gt;</operator><name>j</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>symbol_t</name></name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_symbols</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>symbol_t</name></name> <modifier>*</modifier></type><name>symbols</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>stridx</name></decl>, <decl><type ref="prev"/><name>symbols_size</name></decl>, <decl><type ref="prev"/><name>symbols_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>to</name></decl>, <decl><type ref="prev"/><name>from</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symbols</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>symbols</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>HtPP</name> <modifier>*</modifier></type><name>hash</name> <init>= <expr><call><name>ht_pp_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hash</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_exports</name> <init>= <expr><call><name>walk_exports</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>symbols_count</name> <operator>=</operator> <name>n_exports</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>symbols_count</name> <operator>=</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextdefsym</name></name> <operator>+</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocalsym</name></name> <operator>+</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>symbols_count</name> <operator>+=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbols_size</name> <operator>=</operator> <operator>(</operator><name>symbols_count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>symbols_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>symbols</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>symbols_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iextdefsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextdefsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>ilocalsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nlocalsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOT_USED</name></expr></cpp:if>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>maxsymbols</name> <init>= <expr><name>symbols_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>symbols_count</name> <operator>&gt;=</operator> <name>maxsymbols</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symbols_count</name> <operator>=</operator> <name>maxsymbols</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"macho warning: Symbol table truncated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>symbols_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>is_imported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_type</name> <operator>&amp;</operator> <name>N_EXT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_EXT</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_LOCAL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sym_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sym_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>R_BIN_MACH0_STRING_LENGTH</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"__Dmain"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"4main"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"STATIC"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"_main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>inSymtab</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>symbols_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"mach0-get-symbols: error\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_import_stub</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>nlist</name></expr></argument>)</argument_list> <modifier>*</modifier><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>n_strx</name></name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>section</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>n_sect</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>section</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>symbols_count</name></expr>)</condition> <block>{<block_content> 


<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>n_type</name></name> <operator>&amp;</operator> <name>N_EXT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_EXT</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>R_BIN_MACH0_SYMBOL_TYPE_LOCAL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sym_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sym_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"entry%d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>R_BIN_MACH0_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>inSymtab</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>symbols</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"__Dmain"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"4main"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"STATIC"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"_main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>n_exports</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>symbols_size</name> <operator>=</operator> <operator>(</operator><name>symbols_count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>symbol_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>symbols_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>symbols</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>symbols_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n_exports</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>symbols_count</name> <operator>-</operator> <name>j</name><operator>)</operator> <operator>&gt;=</operator> <name>n_exports</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RSymCtx</name></type> <name>sym_ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>.</operator><name>symbols</name></name> <operator>=</operator> <name>symbols</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>.</operator><name>j</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>.</operator><name>symbols_count</name></name> <operator>=</operator> <name>symbols_count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym_ctx</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>walk_exports</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>assign_export_symbol_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>sym_ctx</name><operator>.</operator><name>j</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols</name></name> <operator>=</operator> <name>symbols</name></expr>;</expr_stmt>
<return>return <expr><name>symbols</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parse_import_ptr</name><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr>struct <name>reloc_t</name> <operator>*</operator><name>reloc</name></expr></argument>, <argument><expr><name>int</name> <name>idx</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>sym</name></decl>, <decl><type ref="prev"/><name>wordsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>stype</name></decl>;</decl_stmt>
<expr_stmt><expr><name>wordsize</name> <operator>=</operator> <call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_bits</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>n_desc</name> <operator>&amp;</operator> <name>REFERENCE_TYPE</name><operator>)</operator> <operator>==</operator> <name>REFERENCE_FLAG_UNDEFINED_LAZY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stype</name> <operator>=</operator> <name>S_LAZY_SYMBOL_POINTERS</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>stype</name> <operator>=</operator> <name>S_NON_LAZY_SYMBOL_POINTERS</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>addend</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ((T) / 8): reloc-&gt;type = R_BIN_RELOC_ ##T; break</cpp:value></cpp:define>
<switch>switch <condition>(<expr><name>wordsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default> <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE</name></cpp:undef>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>SECTION_TYPE</name><operator>)</operator> <operator>==</operator> <name>stype</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sym</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved1</name> <operator>+</operator> <name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>indidx</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reserved1</name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>indidx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>indidx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nindirectsyms</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name><index>[<expr><name>indidx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <ternary><condition><expr><name>sym</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <name>sym</name> <operator>*</operator> <name>wordsize</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <ternary><condition><expr><name>sym</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>+</operator> <name>sym</name> <operator>*</operator> <name>wordsize</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>import_t</name></name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_imports</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>stridx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>&gt;</operator> <literal type="number">0xfffff</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>import_t</name></name> <modifier>*</modifier></type><name>imports</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>import_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>imports</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING: Imports index out of bounds. Ignoring relocs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>imports</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>imp_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>imp_name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>imports</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>imp_name</name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>imp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>imports</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>ord</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>imports</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>imports</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <operator>(</operator><name>RBinImport</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinImport</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>imports</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>reloc_comparator</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>reloc_t</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>reloc_t</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_relocation_info</name> <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>RSkipList</name> <operator>*</operator> <name>relocs</name></expr></argument>, <argument><expr><name>ut32</name> <name>offset</name></expr></argument>, <argument><expr><name>ut32</name> <name>num</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name> <operator>||</operator> <operator>!</operator><name>offset</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>total_size</name> <init>= <expr><name>num</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>relocation_info</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>relocation_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>info</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>info</name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>total_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name></type> <name>a_info</name> <init>= <expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>sym_num</name> <init>= <expr><name><name>a_info</name><operator>.</operator><name>r_symbolnum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sym_num</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>stridx</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>sym_num</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><call><name>get_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>stridx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sym_name</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>reloc_t</name></name> <modifier>*</modifier></type><name>reloc</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>reloc_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reloc</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <call><name>offset_to_vaddr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>a_info</name><operator>.</operator><name>r_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>a_info</name><operator>.</operator><name>r_address</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>ord</name></name> <operator>=</operator> <name>sym_num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>a_info</name><operator>.</operator><name>r_type</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>external</name></name> <operator>=</operator> <name><name>a_info</name><operator>.</operator><name>r_extern</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>pc_relative</name></name> <operator>=</operator> <name><name>a_info</name><operator>.</operator><name>r_pcrel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>a_info</name><operator>.</operator><name>r_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>reloc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_skiplist_insert</name> <argument_list>(<argument><expr><name>relocs</name></expr></argument>, <argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>RSkipList</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_relocs</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>RSkipList</name> <modifier>*</modifier></type><name>relocs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulebr</name></type> <name>ur</name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordsize</name> <init>= <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_bits</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>opcodes</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"/><name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rel_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lib_ord</name></decl>, <decl><type ref="prev"/><name>seg_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>sym_ord</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>skip</name></decl>, <decl><type ref="prev"/><name>bind_size</name></decl>, <decl><type ref="prev"/><name>lazy_size</name></decl>, <decl><type ref="prev"/><name>weak_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st64</name></type> <name>addend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>segmentAddress</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ((T) / 8): rel_type = R_BIN_RELOC_ ##T; break</cpp:value></cpp:define>
<switch>switch <condition>(<expr><name>wordsize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CASE</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE</name></cpp:undef>
<expr_stmt><expr><name>bind_size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lazy_size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>weak_size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>weak_bind_size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bind_size</name> <operator>||</operator> <operator>!</operator><name>lazy_size</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bind_size</name> <operator>+</operator> <name>lazy_size</name><operator>)</operator><operator>&lt;</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name> <operator>+</operator> <name>bind_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_off</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> \
<name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_off</name></name> <operator>+</operator> <name>lazy_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name> <operator>+</operator> <name>bind_size</name> <operator>+</operator> <name>lazy_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>weak_bind_off</name></name> <operator>+</operator> <name>weak_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>amount</name> <init>= <expr><name>bind_size</name> <operator>+</operator> <name>lazy_size</name> <operator>+</operator> <name>weak_size</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>relocs</name> <operator>=</operator> <call><name>r_skiplist_new</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <operator>&amp;</operator><name>free</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <operator>&amp;</operator><name>reloc_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relocs</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>opcodes</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>amount</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opcodes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_skiplist_free</name> <argument_list>(<argument><expr><name>relocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name></expr></argument>, <argument><expr><name>opcodes</name></expr></argument>, <argument><expr><name>bind_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>lazy_bind_off</name></name></expr></argument>, <argument><expr><name>opcodes</name> <operator>+</operator> <name>bind_size</name></expr></argument>, <argument><expr><name>lazy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>weak_bind_off</name></name></expr></argument>, <argument><expr><name>opcodes</name> <operator>+</operator> <name>bind_size</name> <operator>+</operator> <name>lazy_size</name></expr></argument>, <argument><expr><name>weak_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>amount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: read (dyld_info bind) at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>dyld_info</name><operator>-&gt;</operator><name>bind_off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>opcodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_skiplist_free</name> <argument_list>(<argument><expr><name>relocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name>opcodes</name></expr><operator>,</operator> <expr><name>end</name> <operator>=</operator> <name>opcodes</name> <operator>+</operator> <name>amount</name></expr> ;</init> <condition><expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name>imm</name> <init>= <expr><operator>*</operator><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>&amp;</operator> <name>BIND_IMMEDIATE_MASK</name></expr></init></decl>, <decl><type ref="prev"/><name>op</name> <init>= <expr><operator>*</operator><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>&amp;</operator> <name>BIND_OPCODE_MASK</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name><name>ur</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ur</name><operator>.</operator><name>p</name></name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULEB</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>read_uleb128 (&amp;ur,end)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLEB</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>read_sleb128 (&amp;ur,end)</cpp:value></cpp:define>
<case>case <expr><name>BIND_OPCODE_DONE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_DYLIB_ORDINAL_IMM</name></expr>:</case>
<expr_stmt><expr><name>lib_ord</name> <operator>=</operator> <name>imm</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB</name></expr>:</case>
<expr_stmt><expr><name>lib_ord</name> <operator>=</operator> <call><name>ULEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_DYLIB_SPECIAL_IMM</name></expr>:</case>
<expr_stmt><expr><name>lib_ord</name> <operator>=</operator> <ternary><condition><expr><name>imm</name></expr>?</condition><then> <expr><operator>(</operator><name>st8</name><operator>)</operator><operator>(</operator><name>BIND_OPCODE_MASK</name> <operator>|</operator> <name>imm</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ur</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name><name>ur</name><operator>.</operator><name>p</name></name><operator>++</operator> <operator>&amp;&amp;</operator> <name><name>ur</name><operator>.</operator><name>p</name></name><operator>&lt;</operator><name>end</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>
<expr_stmt><expr><name>sym_ord</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name> <operator>&lt;</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iundefsym</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>iundefsym</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iundefsym</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sidx</name> <init>= <expr><name>iundefsym</name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sidx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sidx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsymtab</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>stridx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symtab</name><index>[<expr><name>sidx</name></expr>]</index></name><operator>.</operator><name>n_strx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>stridx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>stridx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>symstrlen</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name> <operator>+</operator> <name>stridx</name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sym_ord</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>BIND_OPCODE_SET_TYPE_IMM</name></expr>:</case>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>imm</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_ADDEND_SLEB</name></expr>:</case>
<expr_stmt><expr><name>addend</name> <operator>=</operator> <call><name>SLEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</name></expr>:</case>
<expr_stmt><expr><name>seg_idx</name> <operator>=</operator> <name>imm</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>seg_idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>seg_idx</name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB"</literal>
<literal type="string">" has unexistent segment %d\n"</literal></expr></argument>, <argument><expr><name>seg_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>opcodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_skiplist_free</name> <argument_list>(<argument><expr><name>relocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>seg_idx</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> <operator>+</operator> <call><name>ULEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>segmentAddress</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>seg_idx</name></expr>]</index></name><operator>.</operator><name>vmaddr</name> \
<operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>seg_idx</name></expr>]</index></name><operator>.</operator><name>vmsize</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_ADD_ADDR_ULEB</name></expr>:</case>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <call><name>ULEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_BIND</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {if ((sym_ord &lt; 0 &amp;&amp; !sym_name) || seg_idx &lt; 0 ) break;if (!addr) break;struct reloc_t *reloc = R_NEW0 (struct reloc_t);reloc-&gt;addr = addr;reloc-&gt;offset = addr - bin-&gt;segs[seg_idx].vmaddr + bin-&gt;segs[seg_idx].fileoff;if (type == BIND_TYPE_TEXT_PCREL32)reloc-&gt;addend = addend - (bin-&gt;baddr + addr);elsereloc-&gt;addend = addend; reloc-&gt;ord = lib_ord;reloc-&gt;ord = sym_ord;reloc-&gt;type = rel_type;if (sym_name)r_str_ncpy (reloc-&gt;name, sym_name, 256);r_skiplist_insert (relocs, reloc);} while (0)</cpp:value></cpp:define>

















<case>case <expr><name>BIND_OPCODE_DO_BIND</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>segmentAddress</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Malformed DO bind opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DO_BIND</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>wordsize</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>segmentAddress</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Malformed ADDR ULEB bind opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DO_BIND</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <call><name>ULEB</name> <argument_list>()</argument_list></call> <operator>+</operator> <name>wordsize</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>segmentAddress</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Malformed IMM SCALED bind opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DO_BIND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name>imm</name> <operator>*</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name>wordsize</name> <operator>+</operator> <name>wordsize</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</name></expr>:</case>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>ULEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>skip</name> <operator>=</operator> <call><name>ULEB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name>segmentAddress</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Malformed ULEB TIMES bind opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DO_BIND</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>skip</name> <operator>+</operator> <name>wordsize</name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DO_BIND</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ULEB</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLEB</name></cpp:undef>
<default>default:</default>
<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: unknown bind opcode 0x%02x in dyld_info\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>ur</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>opcodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>relocs</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>opcodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>symstr</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>indirectsyms</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>amount</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nundefsym</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>amount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relocs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>relocs</name> <operator>=</operator> <call><name>r_skiplist_new</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <operator>&amp;</operator><name>free</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <operator>&amp;</operator><name>reloc_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relocs</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>amount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>reloc_t</name></name> <modifier>*</modifier></type><name>reloc</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>reloc_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reloc</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parse_import_ptr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>reloc</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>iundefsym</name></name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reloc</name><operator>-&gt;</operator><name>ord</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_skiplist_insert</name> <argument_list>(<argument><expr><name>relocs</name></expr></argument>, <argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symtab</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>extreloff</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextrel</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relocs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>relocs</name> <operator>=</operator> <call><name>r_skiplist_new</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <operator>&amp;</operator><name>free</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <operator>&amp;</operator><name>reloc_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relocs</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>parse_relocation_info</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>relocs</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>extreloff</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dysymtab</name><operator>.</operator><name>nextrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>beach</name>:</label>
<return>return <expr><name>relocs</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>addr_t</name></name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_entrypoint</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>sects</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (!bin-&gt;entry) {
return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>addr_t</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>addr_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <call><name>entry_to_vaddr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>haddr</name></name> <operator>=</operator> <call><name>sdb_num_get</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry.offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry.vaddr"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry.paddr"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsects</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sectname</name></expr></argument>, <argument><expr><literal type="string">"__text"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"mach0.entry"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>sects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"entrypoint is 0...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>kv_loadlibs</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"libs.%d.name"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>lib_t</name></name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_libs</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lib_t</name></name> <modifier>*</modifier></type><name>libs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>libs</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>lib_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nlibs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"libs.%d.name"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>libs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>libs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>R_BIN_MACH0_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>libs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>R_BIN_MACH0_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>libs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>libs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>libs</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>get_baddr</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>filetype</name></name> <operator>!=</operator> <name>MH_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>filetype</name></name> <operator>!=</operator> <name>MH_DYLINKER</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>nsegs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fileoff</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>filesize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>segs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vmaddr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_class</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<return>return <expr><call><name>r_str_new</name> <argument_list>(<argument><expr><literal type="string">"MACH064"</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>r_str_new</name> <argument_list>(<argument><expr><literal type="string">"MACH0"</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>int</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>get_bits</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_bits_from_hdr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>cputype</name></name> <operator>==</operator> <name>CPU_TYPE_ARM</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">16</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>bits</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>int</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>get_bits_from_hdr</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><name>hdr</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>MH_MAGIC_64</name> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>MH_CIGAM_64</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">64</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>cputype</name></name> <operator>==</operator> <name>CPU_TYPE_ARM64_32</name></expr>)</condition> <block>{<block_content> 
<return>return <expr><literal type="number">64</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>cpusubtype</name></name> <operator>&amp;</operator> <name>CPU_SUBTYPE_MASK</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>CPU_SUBTYPE_ARM_V7K</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">16</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>is_big_endian</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cpu</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>cputype</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>cpu</name> <operator>==</operator> <name>CPU_TYPE_POWERPC</name> <operator>||</operator> <name>cpu</name> <operator>==</operator> <name>CPU_TYPE_POWERPC64</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_intrp</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>bin</name></expr>?</condition><then> <expr><name><name>bin</name><operator>-&gt;</operator><name>intrp</name></name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_os</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>os</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"macos"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"ios"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"watchos"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"tvos"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="string">"darwin"</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_cputype_from_hdr</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><name>hdr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>archstr</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>cputype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_TYPE_VAX</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"vax"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_MC680x0</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"mc680x0"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_I386</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_X86_64</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"x86"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_MC88000</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"mc88000"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_MC98000</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"mc98000"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_HPPA</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"hppa"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_ARM</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_ARM64</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_ARM64_32</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"arm"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_SPARC</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"sparc"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_MIPS</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"mips"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_I860</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"i860"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_POWERPC64</name></expr>:</case>
<expr_stmt><expr><name>archstr</name> <operator>=</operator> <literal type="string">"ppc"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown arch %d\n"</literal></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>cputype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>archstr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_cputype</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>bin</name></expr>?</condition><then> <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_cputype_from_hdr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpusubtype_tostring</name> <parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>cputype</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>cpusubtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>cputype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_TYPE_VAX</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_VAX_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX780</name></expr>:</case> <return>return <expr><literal type="string">"vax780"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX785</name></expr>:</case> <return>return <expr><literal type="string">"vax785"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX750</name></expr>:</case> <return>return <expr><literal type="string">"vax750"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX730</name></expr>:</case> <return>return <expr><literal type="string">"vax730"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_UVAXI</name></expr>:</case> <return>return <expr><literal type="string">"uvaxI"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_UVAXII</name></expr>:</case> <return>return <expr><literal type="string">"uvaxII"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX8200</name></expr>:</case> <return>return <expr><literal type="string">"vax8200"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX8500</name></expr>:</case> <return>return <expr><literal type="string">"vax8500"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX8600</name></expr>:</case> <return>return <expr><literal type="string">"vax8600"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX8650</name></expr>:</case> <return>return <expr><literal type="string">"vax8650"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_VAX8800</name></expr>:</case> <return>return <expr><literal type="string">"vax8800"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_UVAXIII</name></expr>:</case> <return>return <expr><literal type="string">"uvaxIII"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown vax subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_MC680x0</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_MC68030</name></expr>:</case> <return>return <expr><literal type="string">"mc68030"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MC68040</name></expr>:</case> <return>return <expr><literal type="string">"mc68040"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MC68030_ONLY</name></expr>:</case> <return>return <expr><literal type="string">"mc68030 only"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown mc680x0 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_I386</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_386</name></expr>:</case> <return>return <expr><literal type="string">"386"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_486</name></expr>:</case> <return>return <expr><literal type="string">"486"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_486SX</name></expr>:</case> <return>return <expr><literal type="string">"486sx"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENT</name></expr>:</case> <return>return <expr><literal type="string">"Pentium"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTPRO</name></expr>:</case> <return>return <expr><literal type="string">"Pentium Pro"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTII_M3</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 3 M3"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTII_M5</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 3 M5"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_CELERON</name></expr>:</case> <return>return <expr><literal type="string">"Celeron"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_CELERON_MOBILE</name></expr>:</case> <return>return <expr><literal type="string">"Celeron Mobile"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_3</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 3"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_3_M</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 3 M"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_3_XEON</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 3 Xeon"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_M</name></expr>:</case> <return>return <expr><literal type="string">"Pentium Mobile"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_4</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 4"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_PENTIUM_4_M</name></expr>:</case> <return>return <expr><literal type="string">"Pentium 4 M"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ITANIUM</name></expr>:</case> <return>return <expr><literal type="string">"Itanium"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ITANIUM_2</name></expr>:</case> <return>return <expr><literal type="string">"Itanium 2"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_XEON</name></expr>:</case> <return>return <expr><literal type="string">"Xeon"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_XEON_MP</name></expr>:</case> <return>return <expr><literal type="string">"Xeon MP"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown i386 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_X86_64</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_X86_64_ALL</name></expr>:</case> <return>return <expr><literal type="string">"x86 64 all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_X86_ARCH1</name></expr>:</case> <return>return <expr><literal type="string">"x86 arch 1"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown x86 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_MC88000</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_MC88000_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MC88100</name></expr>:</case> <return>return <expr><literal type="string">"mc88100"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MC88110</name></expr>:</case> <return>return <expr><literal type="string">"mc88110"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown mc88000 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_MC98000</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_MC98000_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MC98601</name></expr>:</case> <return>return <expr><literal type="string">"mc98601"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown mc98000 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_HPPA</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_HPPA_7100</name></expr>:</case> <return>return <expr><literal type="string">"hppa7100"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_HPPA_7100LC</name></expr>:</case> <return>return <expr><literal type="string">"hppa7100LC"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown hppa subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_ARM64</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_ARM64_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM64_V8</name></expr>:</case> <return>return <expr><literal type="string">"arm64v8"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM64E</name></expr>:</case> <return>return <expr><literal type="string">"arm64e"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown arm64 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="string">"v8"</literal></expr>;</return>
<case>case <expr><name>CPU_TYPE_ARM</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_ARM_ALL</name></expr>:</case>
<return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V4T</name></expr>:</case>
<return>return <expr><literal type="string">"v4t"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V5</name></expr>:</case>
<return>return <expr><literal type="string">"v5"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V6</name></expr>:</case>
<return>return <expr><literal type="string">"v6"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_XSCALE</name></expr>:</case>
<return>return <expr><literal type="string">"xscale"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7</name></expr>:</case>
<return>return <expr><literal type="string">"v7"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7F</name></expr>:</case>
<return>return <expr><literal type="string">"v7f"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7S</name></expr>:</case>
<return>return <expr><literal type="string">"v7s"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7K</name></expr>:</case>
<return>return <expr><literal type="string">"v7k"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7M</name></expr>:</case>
<return>return <expr><literal type="string">"v7m"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_ARM_V7EM</name></expr>:</case>
<return>return <expr><literal type="string">"v7em"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown arm subtype %d\n"</literal></expr></argument>, <argument><expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="string">"unknown arm subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_SPARC</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_SPARC_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown sparc subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_MIPS</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_MIPS_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R2300</name></expr>:</case> <return>return <expr><literal type="string">"r2300"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R2600</name></expr>:</case> <return>return <expr><literal type="string">"r2600"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R2800</name></expr>:</case> <return>return <expr><literal type="string">"r2800"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R2000a</name></expr>:</case> <return>return <expr><literal type="string">"r2000a"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R2000</name></expr>:</case> <return>return <expr><literal type="string">"r2000"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R3000a</name></expr>:</case> <return>return <expr><literal type="string">"r3000a"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_MIPS_R3000</name></expr>:</case> <return>return <expr><literal type="string">"r3000"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown mips subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_I860</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_I860_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_I860_860</name></expr>:</case> <return>return <expr><literal type="string">"860"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown i860 subtype"</literal></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_POWERPC64</name></expr>:</case>
<switch>switch <condition>(<expr><name>cpusubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_ALL</name></expr>:</case> <return>return <expr><literal type="string">"all"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_601</name></expr>:</case> <return>return <expr><literal type="string">"601"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_602</name></expr>:</case> <return>return <expr><literal type="string">"602"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_603</name></expr>:</case> <return>return <expr><literal type="string">"603"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_603e</name></expr>:</case> <return>return <expr><literal type="string">"603e"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_603ev</name></expr>:</case> <return>return <expr><literal type="string">"603ev"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_604</name></expr>:</case> <return>return <expr><literal type="string">"604"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_604e</name></expr>:</case> <return>return <expr><literal type="string">"604e"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_620</name></expr>:</case> <return>return <expr><literal type="string">"620"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_750</name></expr>:</case> <return>return <expr><literal type="string">"750"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_7400</name></expr>:</case> <return>return <expr><literal type="string">"7400"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_7450</name></expr>:</case> <return>return <expr><literal type="string">"7450"</literal></expr>;</return>
<case>case <expr><name>CPU_SUBTYPE_POWERPC_970</name></expr>:</case> <return>return <expr><literal type="string">"970"</literal></expr>;</return>
<default>default:</default> <return>return <expr><literal type="string">"Unknown ppc subtype"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></switch>
<return>return <expr><literal type="string">"Unknown cputype"</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_cpusubtype_from_hdr</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><name>hdr</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>cpusubtype_tostring</name> <argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>cputype</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>cpusubtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_cpusubtype</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>bin</name></expr>?</condition><then> <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_cpusubtype_from_hdr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Unknown"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>is_pie</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>filetype</name></name> <operator>==</operator> <name>MH_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MH_PIE</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>has_nx</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>filetype</name></name> <operator>==</operator> <name>MH_EXECUTE</name> <operator>&amp;&amp;</operator>
<name><name>bin</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>MH_NO_HEAP_EXECUTION</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_filetype_from_hdr</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call> <operator>*</operator><name>hdr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mhtype</name> <init>= <expr><literal type="string">"Unknown"</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>filetype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>MH_OBJECT</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Relocatable object"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_EXECUTE</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Executable file"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_FVMLIB</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Fixed VM shared library"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_CORE</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Core file"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_PRELOAD</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Preloaded executable file"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_DYLIB</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Dynamically bound shared library"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_DYLINKER</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Dynamic link editor"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_BUNDLE</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Dynamically bound bundle file"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_DYLIB_STUB</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Shared library stub for static linking (no sections)"</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>MH_DSYM</name></expr>:</case> <expr_stmt><expr><name>mhtype</name> <operator>=</operator> <literal type="string">"Companion file with only debug sections"</literal></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>mhtype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><name>MACH0_</name></type><argument_list>(<argument><expr><name>get_filetype</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>bin</name></expr>?</condition><then> <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_filetype_from_hdr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Unknown"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ut64</name> <name>MACH0_</name></type><argument_list>(<argument><expr><name>get_main</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FEATURE_SYMLIST</name></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_symbols_list</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_entrypoint</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>main_cmd</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <name>LC_MAIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>b</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><call><name>addr_to_offset</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>entry</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">80</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xe8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>b</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>entry</name></name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>main_addr</name></name> <operator>=</operator> <name>addr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name> <name>MACH0_</name></type>(<name>mach_headerfields</name>)<parameter_list>(<parameter><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>PrintfCallback</name></type> <name>cb_printf</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>rbin</name><operator>-&gt;</operator><name>cb_printf</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cb_printf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cb_printf</name> <operator>=</operator> <name>printf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>length</name> <init>= <expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>mh</name> <init>= <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_hdr</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mh</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>pvaddr</name> <init>= <expr><call><name>pa2va</name> <argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.mach0_header @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" Magic 0x%x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" CpuType 0x%x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" CpuSubType 0x%x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>cpusubtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" FileType 0x%x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>filetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" nCmds %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>ncmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" sizeOfCmds %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>sizeofcmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" Flags 0x%x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>mh</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is64</name> <init>= <expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><literal type="number">0x20</literal> <operator>-</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>word</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>wordbuf</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isBe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_POWERPC64</name></expr>:</case>
<expr_stmt><expr><name>isBe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READWORD</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>if (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { eprintf ("Invalid address in buffer."); break; } addr += 4; pvaddr += 4;word = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);</cpp:value></cpp:define>







<if_stmt><if>if <condition>(<expr><name>is64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>mh</name><operator>-&gt;</operator><name>ncmds</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>READWORD</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lcType</name> <init>= <expr><name>word</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pf_definition</name> <init>= <expr><call><name>cmd_to_pf_definition</name> <argument_list>(<argument><expr><name>lcType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pf_definition</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.%s @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pf_definition</name></expr></argument>, <argument><expr><name>pvaddr</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" cmd %7d 0x%x %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>lcType</name></expr></argument>, <argument><expr><call><name>cmd_to_string</name> <argument_list>(<argument><expr><name>lcType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>READWORD</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lcSize</name> <init>= <expr><name>word</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>word</name> <operator>&amp;=</operator> <literal type="number">0xFFFFFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" cmdsize %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lcSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid size for a load command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>lcType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_BUILD_VERSION</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" platform %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><call><name>build_version_platform_to_string</name> <argument_list>(<argument><expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" minos %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" sdk %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>ntools</name> <init>= <expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" ntools %d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>ntools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <operator>(</operator><name>lcSize</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>ntools</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.mach0_build_version_tool @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" tool %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><call><name>build_version_tool_to_string</name> <argument_list>(<argument><expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <operator>(</operator><name>lcSize</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" version %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_MAIN</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>data</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<decl_stmt><decl><type><name>ut64</name></type> <name>ep</name> <init>= <expr><call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" entry0 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ss</name> <init>= <expr><call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" stacksize 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>ut32</name></type> <name>ep</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT32x</name><literal type="string">" entry0 0x%"</literal> <name>PFMT32x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name>pvaddr</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>ss</name> <init>= <expr><call><name>r_read_ble32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT32x</name><literal type="string">" stacksize 0x%"</literal> <name>PFMT32x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name>pvaddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_SYMTAB</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
{
char *id = r_buf_get_string (buf, addr + 20);
cb_printf ("0x%08"PFMT64x" id 0x%x\n", addr + 20, id? id: "");
cb_printf ("0x%08"PFMT64x" symooff 0x%x\n", addr + 20, id? id: "");
cb_printf ("0x%08"PFMT64x" nsyms %d\n", addr + 20, id? id: "");
cb_printf ("0x%08"PFMT64x" stroff 0x%x\n", addr + 20, id? id: "");
cb_printf ("0x%08"PFMT64x" strsize 0x%x\n", addr + 20, id? id: "");
free (id);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>LC_ID_DYLIB</name></expr>:</case> <block>{<block_content> 
<decl_stmt><decl><type><name>ut32</name></type> <name>str_off</name> <init>= <expr><call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>isBe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><call><name>r_buf_get_string</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>str_off</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" current %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" compat %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">13</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" id %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <name>str_off</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>id</name></expr>?</condition><then> <expr><name>id</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_UUID</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name><name>uuid</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" uuid "</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>uuid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_SEGMENT</name></expr>:</case>
<case>case <expr><name>LC_SEGMENT_64</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>name</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" name %s\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>nsects</name> <init>= <expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>-</operator> <literal type="number">8</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>is64</name></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><literal type="number">48</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><ternary><condition><expr><name>is64</name></expr> ?</condition><then> <expr><literal type="number">72</literal></expr> </then><else>: <expr><literal type="number">56</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>lcSize</name> <operator>&amp;&amp;</operator> <name>nsects</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.mach0_section64 @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>-</operator> <literal type="number">8</literal> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">80</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.mach0_section @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>-</operator> <literal type="number">8</literal> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">68</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>LC_LOAD_DYLIB</name></expr>:</case>
<case>case <expr><name>LC_LOAD_WEAK_DYLIB</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>str_off</name> <init>= <expr><call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>isBe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>load_dylib</name> <init>= <expr><call><name>r_buf_get_string</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>str_off</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" current %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" compat %d.%d.%d\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><call><name>r_buf_read_le16_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">13</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>r_buf_read8_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" load_dylib %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <name>str_off</name> <operator>-</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>load_dylib</name></expr>?</condition><then> <expr><name>load_dylib</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>load_dylib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_RPATH</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rpath</name> <init>= <expr><call><name>r_buf_get_string</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" rpath %s\n"</literal></expr></argument>,
<argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>rpath</name></expr> ?</condition><then> <expr><name>rpath</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_ENCRYPTION_INFO</name></expr>:</case>
<case>case <expr><name>LC_ENCRYPTION_INFO_64</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>word</name> <init>= <expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" cryptoff 0x%08x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>word</name> <operator>=</operator> <call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" cryptsize %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>word</name> <operator>=</operator> <call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" cryptid %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_CODE_SIGNATURE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name><name>words</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>words</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" dataoff 0x%08x\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" datasize %d\n"</literal></expr></argument>, <argument><expr><name>pvaddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cb_printf</name> <argument_list>(<argument><expr><literal type="string">"#wtf mach0.sign %d @ 0x%x\n"</literal></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>word</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pvaddr</name> <operator>+=</operator> <name>word</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>RList</name> <modifier>*</modifier><name>MACH0_</name></type>(<name>mach_fields</name>)<parameter_list>(<parameter><decl><type><name>RBinFile</name> <modifier>*</modifier></type><name>bf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>bf</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>length</name> <init>= <expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>mh</name> <init>= <expr><call><call><name>MACH0_</name><argument_list>(<argument><expr><name>get_hdr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mh</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>pa2va</name> <argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>paddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_bin_field_new</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>, <argument><expr><literal type="string">"mach0_header"</literal></expr></argument>, <argument><expr><literal type="string">"mach0_header"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <literal type="number">0x20</literal> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>paddr</name> <operator>+=</operator> <literal type="number">0x20</literal> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is64</name> <init>= <expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>paddr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isBe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>mh</name><operator>-&gt;</operator><name>cputype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:</case>
<case>case <expr><name>CPU_TYPE_POWERPC64</name></expr>:</case>
<expr_stmt><expr><name>isBe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>mh</name><operator>-&gt;</operator><name>ncmds</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>lcType</name> <init>= <expr><call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>paddr</name></expr></argument>, <argument><expr><name>isBe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>word</name> <init>= <expr><call><name>r_buf_read_ble32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>paddr</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>isBe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>paddr</name> <operator>+</operator> <literal type="number">8</literal> <operator>&gt;</operator> <name>length</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>lcSize</name> <init>= <expr><name>word</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>word</name> <operator>&amp;=</operator> <literal type="number">0xFFFFFF</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lcSize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid size for a load command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pf_definition</name> <init>= <expr><call><name>cmd_to_pf_definition</name> <argument_list>(<argument><expr><name>lcType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pf_definition</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_bin_field_new</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"load_command_%d_%s"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>cmd_to_string</name> <argument_list>(<argument><expr><name>lcType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pf_definition</name></expr></argument>, <argument><expr><name>pf_definition</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>lcType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LC_BUILD_VERSION</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>ntools</name> <init>= <expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>paddr</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>lcSize</name> <operator>&amp;&amp;</operator> <name>ntools</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_bin_field_new</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"tool_%d"</literal></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mach0_build_version_tool"</literal></expr></argument>, <argument><expr><literal type="string">"mach0_build_version_tool"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LC_SEGMENT</name></expr>:</case>
<case>case <expr><name>LC_SEGMENT_64</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>nsects</name> <init>= <expr><call><name>r_buf_read_le32_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>is64</name></expr> ?</condition><then> <expr><literal type="number">64</literal></expr> </then><else>: <expr><literal type="number">48</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><ternary><condition><expr><name>is64</name></expr> ?</condition><then> <expr><literal type="number">72</literal></expr> </then><else>: <expr><literal type="number">56</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name>lcSize</name> <operator>&amp;&amp;</operator> <name>nsects</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_bin_field_new</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"section_%d"</literal></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mach0_section64"</literal></expr></argument>, <argument><expr><literal type="string">"mach0_section64"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">80</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>r_bin_field_new</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"section_%d"</literal></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"mach0_section"</literal></expr></argument>, <argument><expr><literal type="string">"mach0_section"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">68</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>word</name></expr>;</expr_stmt>
<expr_stmt><expr><name>paddr</name> <operator>+=</operator> <name>word</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>MACH0_</name><argument_list>(<argument><expr><name>get_hdr</name></expr></argument>)</argument_list><argument_list>(<argument><expr><name>RBuffer</name> <operator>*</operator><name>buf</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>magicbytes</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>machohdrbytes</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MACH0_</name></name></type><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list> <modifier>*</modifier><name>macho_hdr</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>big_endian</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>macho_hdr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>magicbytes</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>macho_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedface</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedface</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAT_MAGIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAT_MAGIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedfacf</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>magicbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xfeedfacf</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>big_endian</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
free (macho_hdr);
return NULL;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>machohdrbytes</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>machohdrbytes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <call><name>MACH0_</name><argument_list>(<argument><expr><name>mach_header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>macho_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>cputype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>cpusubtype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>filetype</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>ncmds</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>sizeofcmds</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_MACH064</name></expr></cpp:if>
<expr_stmt><expr><name><name>macho_hdr</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <call><name>r_read_ble</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>machohdrbytes</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>big_endian</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>macho_hdr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</unit>
