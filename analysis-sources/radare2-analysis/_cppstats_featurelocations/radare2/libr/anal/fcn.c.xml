<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\anal\fcn.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_parse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_list.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_AHEAD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDB_KEY_BB</name></cpp:macro> <cpp:value>"bb.0x%"PFMT64x ".0x%"PFMT64x</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JMPTBLSZ</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JMPTBL_LEA_SEARCH_SZ</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JMPTBL_MAXFCNSIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BB_ALIGN</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JAYRO_04</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FLG_NAME_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_JMP_FWD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name></cpp:macro> <cpp:value>if (a-&gt;verbose)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FCN_SIZE</name></cpp:macro> <cpp:value>(1024 * 256)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB</name></cpp:macro> <cpp:value>a-&gt;sdb_fcns</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXISTS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (key, sizeof (key) - 1, x, ##__VA_ARGS__), sdb_exists (DB, key)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETKEY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (key, sizeof (key) - 1, x, ##__VA_ARGS__);</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>fcn_tree_iter_t</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBNode</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RBNode</name> <modifier>*</modifier></type><name><name>path</name><index>[<expr><name>R_RBTREE_MAX_HEIGHT</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>FcnTreeIter</name>;</typedef>

<function><type><name>R_API</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_anal_fcntype_tostring</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_FCN_TYPE_NULL</name></expr>:</case> <return>return <expr><literal type="string">"null"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_FCN_TYPE_FCN</name></expr>:</case> <return>return <expr><literal type="string">"fcn"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_FCN_TYPE_LOC</name></expr>:</case> <return>return <expr><literal type="string">"loc"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_FCN_TYPE_SYM</name></expr>:</case> <return>return <expr><literal type="string">"sym"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_FCN_TYPE_IMP</name></expr>:</case> <return>return <expr><literal type="string">"imp"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_FCN_TYPE_INT</name></expr>:</case> <return>return <expr><literal type="string">"int"</literal></expr>;</return> 
<case>case <expr><name>R_ANAL_FCN_TYPE_ROOT</name></expr>:</case> <return>return <expr><literal type="string">"root"</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="string">"unk"</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>READ_AHEAD</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>cache_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_ahead</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut8</name></type> <name><name>cache</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cache_len</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>cache_len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cache_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cache_addr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr_end</name> <init>= <expr><ternary><condition><expr><call><name>UT64_ADD_OVFCHK</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><name>UT64_MAX</name></expr></then><else>: <expr><name>addr</name> <operator>+</operator> <name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>cache_addr_end</name> <init>= <expr><ternary><condition><expr><call><name>UT64_ADD_OVFCHK</name> <argument_list>(<argument><expr><name>cache_addr</name></expr></argument>, <argument><expr><name>cache_len</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><name>UT64_MAX</name></expr></then><else>: <expr><name>cache_addr</name> <operator>+</operator> <name>cache_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isCached</name> <init>= <expr><operator>(</operator><operator>(</operator><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name>cache_addr</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr_end</name> <operator>&lt;</operator> <name>cache_addr_end</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>isCached</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cache</name> <operator>+</operator> <operator>(</operator><name>addr</name> <operator>-</operator> <name>cache_addr</name><operator>)</operator></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cache_addr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_ahead</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_fcn_invalidate_read_ahead_cache</name><parameter_list>()</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>READ_AHEAD</name></expr></cpp:if>
<expr_stmt><expr><name>cache_addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>_a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_function_resize</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>is_arm</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arm</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>eof</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>newsize</name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name>eof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name>eof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_set_size</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>eof</name> <operator>-</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>&gt;=</operator> <name>eof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>&gt;=</operator> <name>eof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>fcn_append_basic_block</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_create_block</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bb</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_function_add_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
<return>return <expr><name>bb</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gotoBeach</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ret = x; goto beach;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isInvalidMemory</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nonull</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nonull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\xff\xff\xff\xff"</literal></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isSymbolNextInstruction</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>get_at</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>get_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>fi</name> <operator>&amp;&amp;</operator> <name><name>fi</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strstr</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"imp."</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"entry"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_delta_pointer_table</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>lea_ptr</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>jmptbl_addr</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>jmp_aop</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st32</name></type> <name><name>jmptbl</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><name>JMPTBL_LEA_SEARCH_SZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>aop</name> <init>= <expr><name>jmp_aop</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>mov_aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>add_aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>read_ahead</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">8</literal> <operator>&lt;</operator> <name>JMPTBL_LEA_SEARCH_SZ</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name>addr</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><name>JMPTBL_LEA_SEARCH_SZ</name> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>aop</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_UJMP</name> <operator>||</operator> <name><name>aop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_RJMP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mov_aop</name> <operator>=</operator> <operator>*</operator><name>aop</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_ADD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>add_aop</name> <operator>=</operator> <operator>*</operator><name>aop</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isValid</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>mov_aop</name><operator>.</operator><name>type</name></name> <operator>&amp;&amp;</operator> <name><name>add_aop</name><operator>.</operator><name>type</name></name> <operator>&amp;&amp;</operator> <name><name>mov_aop</name><operator>.</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>add_aop</name><operator>.</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name><name>add_aop</name><operator>.</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>jmp_aop</name><operator>-&gt;</operator><name>addr</name></name>
<operator>&amp;&amp;</operator> <name><name>mov_aop</name><operator>.</operator><name>disp</name></name> <operator>&amp;&amp;</operator> <name><name>mov_aop</name><operator>.</operator><name>disp</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>jmptbl_addr</name> <operator>+=</operator> <name><name>mov_aop</name><operator>.</operator><name>disp</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (mov_aop.type &amp;&amp; mov_aop.ptr) {
*jmptbl_addr += mov_aop.ptr;

lea_ptr = mov_aop.ptr;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>read_ahead</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>*</operator><name>jmptbl_addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>jmptbl</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>lea_ptr</name> <operator>+</operator> <operator>(</operator><name>st32</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>jmptbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&gt;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>JMPTBL_MAXFCNSIZE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpabove</name></name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>JMPTBL_MAXFCNSIZE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>JMPTBL_MAXFCNSIZE</name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>try_get_cmpval_from_parents</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type> <name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>my_bb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>cmp_reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>fcn</name> <operator>&amp;&amp;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name> <operator>&amp;&amp;</operator> <name>cmp_reg</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>tmp_bb</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>tmp_bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tmp_bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name><name>my_bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>||</operator> <name><name>tmp_bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>==</operator> <name><name>my_bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tmp_bb</name><operator>-&gt;</operator><name>cmpreg</name></name> <operator>==</operator> <name>cmp_reg</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>tmp_bb</name><operator>-&gt;</operator><name>cmpval</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>UT64_MAX</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>regs_exist</name><parameter_list>(<parameter><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>src</name> <operator>&amp;&amp;</operator> <name>dst</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>src</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>dst</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_hp</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oplen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>un_idx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>+</operator> <name>un_idx</name> <operator>-</operator> <name>oplen</name><operator>)</operator> <operator>==</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>exist_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><literal type="string">"skip"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>tmp_buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>MAX_FLG_NAME_SIZE</name> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PFMT64u</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>set</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_block_relocate</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>idx</name> <operator>=</operator> <name>un_idx</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>purity_checked</name><parameter_list>(<parameter><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>checked</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ht_up_find</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>checked</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>check_purity</name><parameter_list>(<parameter><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ht_up_insert</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>is_pure</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CALL</name> <operator>||</operator> <name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>called_fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called_fcn</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>purity_checked</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>called_fcn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>check_purity</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>called_fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>called_fcn</name><operator>-&gt;</operator><name>is_pure</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>is_pure</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_DATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>is_pure</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>ut64</name></type> <name>op_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>leaddr</name></decl>;</decl_stmt>
}</block></struct></type> <name>leaddr_pair</name>;</typedef>

<function><type><specifier>static</specifier> <name>RAnalBlock</name> <modifier>*</modifier></type><name>bbget</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>jumpmid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>intersecting</name> <init>= <expr><call><name>r_anal_get_blocks_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>intersecting</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>eaddr</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name>eaddr</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>==</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator>
<operator>||</operator> <call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>jumpmid</name> <operator>||</operator> <call><name>r_anal_bb_op_starts_at</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>bb</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>intersecting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>fcn_takeover_block_recursive_cb</name><parameter_list>(<parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>our_fcn</name> <init>= <expr><name>user</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_block_ref</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>other_fcn</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>other_fcn</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>r_anal_function_add_block</name> <argument_list>(<argument><expr><name>our_fcn</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_block_unref</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fcn_takeover_block_recursive</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>start_block</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_recurse</name> <argument_list>(<argument><expr><name>start_block</name></expr></argument>, <argument><expr><name>fcn_takeover_block_recursive_cb</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>retpoline_reg</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>flag_get</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><literal type="string">"x86_indirect_thunk_"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thunk</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>thunk</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>thunk</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>





[0x00000a65]&gt; pid 6
0x00000a65 sym.__x86_indirect_thunk_rax:
0x00000a65 .------- e807000000 call 0xa71
0x00000a6a | f390 pause
0x00000a6c | 0faee8 lfence
0x00000a6f | ebf9 jmp 0xa6a
0x00000a71 `----&gt; 48890424 mov qword [rsp], rax
0x00000a75 c3 ret
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>analyze_retpoline</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>retpoline</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rr</name> <init>= <expr><call><name>retpoline_reg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_RJMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <name>rr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcn_recurse</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>continue_after_jump</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>afterjmp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>addrbytes</name> <init>= <expr><ternary><condition><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr> ?</condition><then> <expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name><operator>-&gt;</operator><name>addrbytes</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>last_reg_mov_lea_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bbg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>R_ANAL_RET_END</name></expr></init></decl>, <decl><type ref="prev"/><name>skip_ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>overlapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oplen</name></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>cmpval</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bool</name></type> <name>varset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>after</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pending</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>adjust</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>un_idx</name></decl>;</decl_stmt> 
}</block> <decl><name>delay</name> <init>= <expr><block>{
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>bool</name></type> <name>is_arm</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tmp_buf</name><index>[<expr><name>MAX_FLG_NAME_SIZE</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name> <init>= <expr><literal type="string">"skip"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_x86</name> <init>= <expr><ternary><condition><expr><name>is_arm</name></expr>?</condition><then> <expr><name>false</name></expr></then><else>: <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_dalvik</name> <init>= <expr><ternary><condition><expr><name>is_x86</name></expr>?</condition><then> <expr><name>false</name></expr></then><else>: <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"dalvik"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_RET_END</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>sleep</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_sys_usleep</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sleep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Anal went too deep at address 0x%"</literal><name>PFMT64x</name> <literal type="string">".\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>R_ANAL_RET_ERROR</name></expr>;</return> 
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid address 0x%"</literal><name>PFMT64x</name> <literal type="string">". Try with io.va=true\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>R_ANAL_RET_ERROR</name></expr>;</return> 
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn_at_addr</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fcn_at_addr</name> <operator>&amp;&amp;</operator> <name>fcn_at_addr</name> <operator>!=</operator> <name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_RET_ERROR</name></expr>;</return> 
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>existing_bb</name> <init>= <expr><call><name>bbget</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpmid</name></name> <operator>&amp;&amp;</operator> <name>is_x86</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>existing_bb</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>existing_in_fcn</name> <init>= <expr><call><name>r_list_contains</name> <argument_list>(<argument><expr><name><name>existing_bb</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>existing_bb</name> <operator>=</operator> <call><name>r_anal_block_split</name> <argument_list>(<argument><expr><name>existing_bb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing_in_fcn</name> <operator>&amp;&amp;</operator> <name>existing_bb</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>existing_bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fcn_takeover_block_recursive</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>existing_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>existing_bb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_unref</name> <argument_list>(<argument><expr><name>existing_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>recont</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_RET_END</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_anal_fcn_bb() fails at 0x%"</literal><name>PFMT64x</name> <literal type="string">".\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>R_ANAL_RET_ERROR</name></expr>;</return> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bb</name> <operator>=</operator> <call><name>fcn_append_basic_block</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>R_ANAL_RET_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create leaddr list\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ut64</name></type> <name>lea_jmptbl_ip</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>last_reg_mov_lea_val</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>last_is_reg_mov_lea</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>last_is_push</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>last_is_mov_lr_pc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>last_push_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>limit</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>+</operator> <name>idx</name> <operator>&lt;</operator> <name><name>anal</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>from</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>tmp_fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp_fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>tmp_fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>varset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>movdisp</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>maxlen</name> <init>= <expr><name>len</name> <operator>*</operator> <name>addrbytes</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>is_dalvik</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>skipAnalysis</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"imp."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>skipAnalysis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"field"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>skipAnalysis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>skipAnalysis</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>addrbytes</name> <operator>*</operator> <name>idx</name> <operator>&lt;</operator> <name>maxlen</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_is_reg_mov_lea</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>last_reg_mov_lea_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_reg_mov_lea_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>limit</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>limit</name><operator>-&gt;</operator><name>to</name></name> <operator>&lt;=</operator> <name>addr</name> <operator>+</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<label><name>repeat</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>at_delta</name> <init>= <expr><name>addrbytes</name> <operator>*</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name>addr</name> <operator>+</operator> <name>at_delta</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bytes_read</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>at_delta</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>read_ahead</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to read\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isInvalidMemory</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: FFFF opcode at 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>gotoBeach</name> <argument_list>(<argument>R_ANAL_RET_ERROR</argument>)</argument_list></macro>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>oplen</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid instruction at 0x%"</literal><name>PFMT64x</name><literal type="string">" with %d bits\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nopskip</name></name> <operator>&amp;&amp;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>at</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>get_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fi</name> <operator>||</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"sym."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>+</operator> <name><name>delay</name><operator>.</operator><name>un_idx</name></name> <operator>-</operator> <name>oplen</name><operator>)</operator> <operator>==</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_block_relocate</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>oplen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>un_idx</name></name></expr>;</expr_stmt>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_TRAP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ILL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_NOP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_block_relocate</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>at</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>hint</name><operator>.</operator><name>new_bits</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_hint_set_bits</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>hint</name><operator>.</operator><name>new_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>overlapped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bbg</name> <operator>=</operator> <call><name>bbget</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpmid</name></name> <operator>&amp;&amp;</operator> <name>is_x86</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bbg</name> <operator>&amp;&amp;</operator> <name>bbg</name> <operator>!=</operator> <name>bb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpmid</name></name> <operator>&amp;&amp;</operator> <name>is_x86</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>split</name> <init>= <expr><call><name>r_anal_block_split</name> <argument_list>(<argument><expr><name>bbg</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_block_unref</name> <argument_list>(<argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>overlapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Overlapped at 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlapped</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>newbbsize</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <name>oplen</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newbbsize</name> <operator>&gt;</operator> <name>MAX_FCN_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_bb_set_offset</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>ninstr</name></name><operator>++</operator></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_block_set_size</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>newbbsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>ninstr</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>trycatch</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>getName</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"try."</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>r_str_endswith</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".from"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from_addr</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>numGet</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">".from"</literal></expr></argument>, <argument><expr><literal type="string">".catch"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>handle_addr</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>numGet</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>at</name> <operator>+</operator> <name>oplen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>from_addr</name> <operator>!=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>handle_addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>handle_addr</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"(%s) 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>handle_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_block_unref</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bb</name> <operator>=</operator> <call><name>fcn_append_basic_block</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>un_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>delay</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>delay</name><operator>.</operator><name>pending</name></name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name><argument_list>(<argument><expr><literal type="string">"Enter branch delay at 0x%08"</literal><name>PFMT64x</name> <literal type="string">". bb-&gt;sz=%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name>idx</name> <operator>-</operator> <name>oplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>cnt</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>delay</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>pending</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>adjust</name></name> <operator>=</operator> <operator>!</operator><name>overlapped</name></expr>;</expr_stmt> 
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>delay</name><operator>.</operator><name>cnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>cnt</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>delay</name><operator>.</operator><name>cnt</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name><argument_list>(<argument><expr><literal type="string">"Last branch delayed opcode at 0x%08"</literal><name>PFMT64x</name> <literal type="string">". bb-&gt;sz=%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>idx</name> <operator>-</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>after</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>idx</name></name></expr>;</expr_stmt>





</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>delay</name><operator>.</operator><name>pending</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Revisit branch delay jump at 0x%08"</literal><name>PFMT64x</name> <literal type="string">". bb-&gt;sz=%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>idx</name> <operator>-</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>delay</name><operator>.</operator><name>adjust</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_set_size</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>addrbytes</name> <operator>*</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>delay</name><operator>.</operator><name>after</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>ninstr</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Correct for branch delay @ %08"</literal><name>PFMT64x</name> <literal type="string">" bb.addr=%08"</literal><name>PFMT64x</name> <literal type="string">" corrected.bb=%"</literal><name>PFMT64u</name><literal type="string">" f.uncorr=%"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>addr</name> <operator>+</operator> <name>idx</name> <operator>-</operator> <name>oplen</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>after</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>delay</name><operator>.</operator><name>pending</name></name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>after</name></name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name><name>delay</name><operator>.</operator><name>adjust</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>stackop</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_STACK_INC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>stackptr</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">8096</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>stackptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>&gt;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>stackptr</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_STACK_RESET</name></expr>:</case>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>vars</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>varset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_extract_vars</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>analyze_retpoline</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_CMOV</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>
<expr_stmt><expr><name>last_is_reg_mov_lea</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arm</name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_str_cmp</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="string">"pc,lr,="</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_is_mov_lr_pc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>dst</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>val</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>last_reg_mov_lea_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>last_reg_mov_lea_name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_reg_mov_lea_val</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_is_reg_mov_lea</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmptbl</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>scale</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>movdisp</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>disp</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>hpskip</name></name> <operator>&amp;&amp;</operator> <call><name>regs_exist</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>dst</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>skip_ret</name> <operator>=</operator> <call><name>skip_hp</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>, <argument><expr><name><name>delay</name><operator>.</operator><name>un_idx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_ret</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>
<expr_stmt><expr><name>last_is_reg_mov_lea</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xfe</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>leaddr_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>R_NEW</name> <argument_list>(<argument><expr><name>leaddr_pair</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pair</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create leaddr_pair\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>op_addr</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>leaddr</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>dst</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>last_reg_mov_lea_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>last_reg_mov_lea_name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_reg_mov_lea_val</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_is_reg_mov_lea</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>hpskip</name></name> <operator>&amp;&amp;</operator> <call><name>regs_exist</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>dst</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>skip_ret</name> <operator>=</operator> <call><name>skip_hp</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>, <argument><expr><name><name>delay</name><operator>.</operator><name>un_idx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>repeat</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_ret</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmptbl</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>jmp_aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>jmptbl_addr</name> <init>= <expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_delta_pointer_table</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmptbl_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmp_aop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>default_case</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>try_get_jmptbl_info</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>jmp_aop</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_case</name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>try_get_delta_jmptbl_info</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>jmp_aop</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_case</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>jmp_aop</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>jmptbl_addr</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lea_jmptbl_ip</name> <operator>=</operator> <name><name>jmp_aop</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>jmp_aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_LOAD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>loads</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_meta_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_META_TYPE_DATA</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>R_ANAL_OP_TYPE_ADD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>ijmp</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>.</operator><name>size</name></name> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>bytes_read</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="string">"\x00\x00\x00\x00"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_set_size</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_ILL</name></expr>:</case>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>R_ANAL_OP_TYPE_TRAP</name></expr>:</case>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>R_ANAL_OP_TYPE_NOP</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>get_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fi</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"imp."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpref</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpabove</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&lt;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_noreturn_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>must_eob</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>map_get</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>must_eob</name> <operator>=</operator> <operator>(</operator><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>||</operator> <name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>must_eob</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FIX_JMP_FWD</name></expr></cpp:if>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FITFCNSZ</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlapped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tc</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tailcall</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>-</operator> <name><name>op</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_is_prelude</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcn_recurse</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>tc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcn_recurse</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>beach</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_SUB</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>val</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CMP</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>val</name> <init>= <expr><ternary><condition><expr><name>is_x86</name></expr> ?</condition><then> <expr><name><name>op</name><operator>.</operator><name>val</name></name></expr> </then><else>: <expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>cmpval</name></name> <operator>=</operator> <name>cmpval</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>cmpreg</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_MCJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UCJMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>cjmpref</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlapped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>fail</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmptbl</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>default_case</name></decl>;</decl_stmt>
<expr_stmt><expr><name>table_size</name> <operator>=</operator> <name>cmpval</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>default_case</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>fail</name></name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>default_case</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>.</operator><name>reg</name></name> <operator>||</operator> <name><name>op</name><operator>.</operator><name>ireg</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>walkthrough_arm_jmptbl_style</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>==</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>==</operator> <name><name>op</name><operator>.</operator><name>ptr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>fail</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saved_stack</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>continue_after_jump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>saved_stack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>fail</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>saved_stack</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>saved_stack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>fail</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>saved_stack</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&lt;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlapped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>






<goto>goto <name>beach</name>;</goto>

<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_noreturn_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_noreturn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_noreturn_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>is_noreturn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RJMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>is_arm</name> <operator>&amp;&amp;</operator> <name>last_is_mov_lr_pc</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>R_ANAL_OP_TYPE_MJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_IRJMP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>ijmp</name></name> <operator>&amp;&amp;</operator> <call><name>isSymbolNextInstruction</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmptbl</name></name> <operator>&amp;&amp;</operator> <name>lea_jmptbl_ip</name> <operator>!=</operator> <name><name>op</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>default_case</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>try_get_jmptbl_info</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_case</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>reg</name></name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>default_case</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>try_get_jmptbl_info</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_case</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>movdisp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>jmptbl_base</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>lea_op_off</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>lea_op_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>leaddr_pair</name> <modifier>*</modifier></type><name>pair</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>anal-&gt;leaddrs</argument>, <argument>iter</argument>, <argument>pair</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>op_addr</name></name> <operator>&gt;=</operator> <name><name>op</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lea_op_off</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>lea_op_off</name> <operator>&gt;</operator> <name><name>op</name><operator>.</operator><name>addr</name></name> <operator>-</operator> <name><name>pair</name><operator>-&gt;</operator><name>op_addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lea_op_off</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>addr</name></name> <operator>-</operator> <name><name>pair</name><operator>-&gt;</operator><name>op_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>jmptbl_base</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>leaddr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lea_op_iter</name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>lea_op_iter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_list_delete</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>leaddrs</name></name></expr></argument>, <argument><expr><name>lea_op_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name> <init>= <expr><name>cmpval</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>jmptbl_base</name></expr></argument>, <argument><expr><name>jmptbl_base</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>movdisp</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>table_size</name></decl>, <decl><type ref="prev"/><name>default_case</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>try_get_jmptbl_info</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_case</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>movdisp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>table_size</name></expr></argument>, <argument><expr><name>default_case</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>movdisp</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>is_arm</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptrsize</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>pred_cmpval</name> <init>= <expr><call><name>try_get_cmpval_from_parents</name><argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tablesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pred_cmpval</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tablesize</name> <operator>+=</operator> <name>pred_cmpval</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tablesize</name> <operator>+=</operator> <name>cmpval</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tablesize</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>(</operator><name>tablesize</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>ptrsize</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>pred_cmpval</name> <init>= <expr><call><name>try_get_cmpval_from_parents</name><argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>ireg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tablesize</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pred_cmpval</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tablesize</name> <operator>+=</operator> <name>pred_cmpval</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tablesize</name> <operator>+=</operator> <name>cmpval</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>try_walkthrough_jmptbl</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr></argument>,
<argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tablesize</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>(</operator><name>tablesize</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lea_jmptbl_ip</name> <operator>==</operator> <name><name>op</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lea_jmptbl_ip</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>ijmp</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>continue_after_jump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>fail</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>overlapped</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>analopfinish</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_noreturn_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>op</name><operator>.</operator><name>eob</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>analopfinish</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<label><name>analopfinish</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_RJMP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>R_ANAL_OP_TYPE_PUSH</name></expr>:</case>
<expr_stmt><expr><name>last_is_push</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_push_addr</name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>last_push_addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>last_push_addr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UPUSH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>.</operator><name>type</name></name> <operator>&amp;</operator> <name>R_ANAL_OP_TYPE_REG</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>last_is_reg_mov_lea</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>reg</name>
<operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>last_reg_mov_lea_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_is_push</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_push_addr</name> <operator>=</operator> <name>last_reg_mov_lea_val</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>last_push_addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_xrefs_set</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name>last_push_addr</name></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>family</name></name> <operator>==</operator> <name>R_ANAL_OP_FAMILY_PRIV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_FCN_TYPE_INT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>last_is_push</name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>pushret</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_JMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>=</operator> <name>last_push_addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>.</operator><name>jump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>op</name><operator>.</operator><name>jump</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>.</operator><name>cond</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"RET 0x%08"</literal><name>PFMT64x</name> <literal type="string">". overlap=%s %"</literal><name>PFMT64u</name><literal type="string">" %"</literal><name>PFMT64u</name><literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>addr</name> <operator>+</operator> <name><name>delay</name><operator>.</operator><name>un_idx</name></name> <operator>-</operator> <name>oplen</name></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name>overlapped</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><call><name>r_anal_function_linear_size</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gotoBeach</name> <argument_list>(<argument><expr><name>R_ANAL_RET_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_MOV</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_CMOV</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_LEA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_is_reg_mov_lea</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_PUSH</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RPUSH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_is_push</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_arm</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_MOV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last_is_mov_lr_pc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>last_reg_mov_lea_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bb</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_remove_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_block_unref</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn_bb</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>fcn_recurse</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_check_fcn</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>ut16</name></type> <name>bufsz</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>low</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>high</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name> <init>= <expr><block>{
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>oplen</name></decl>, <decl><type ref="prev"/><name>opcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pushcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>movcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>brcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_is_prelude</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name> <operator>&amp;&amp;</operator> <name>opcnt</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>oplen</name></expr><operator>,</operator> <expr><name>opcnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>oplen</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bufsz</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_PUSH</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_UPUSH</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_RPUSH</name></expr>:</case>
<expr_stmt><expr><name>pushcnt</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CMOV</name></expr>:</case>
<expr_stmt><expr><name>movcnt</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&lt;</operator> <name>low</name> <operator>||</operator> <name><name>op</name><operator>.</operator><name>jump</name></name> <operator>&gt;=</operator> <name>high</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>brcnt</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_UNK</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>pushcnt</name> <operator>+</operator> <name>movcnt</name> <operator>+</operator> <name>brcnt</name> <operator>&gt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_trim_jmprefs</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_x86</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name> <operator>&amp;&amp;</operator> <call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_x86</name> <operator>||</operator> <operator>!</operator><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_deln</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_del_jmprefs</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_xrefs_deln</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>at</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reftype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalMetaItem</name> <modifier>*</modifier></type><name>meta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_meta_find_list_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>meta</argument>)</argument_list></macro> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_META_TYPE_DATA</name></expr>:</case>
<case>case <expr><name>R_META_TYPE_STRING</name></expr>:</case>
<case>case <expr><name>R_META_TYPE_FORMAT</name></expr>:</case>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>norevisit</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name> <operator>=</operator> <call><name>set_u_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>set_u_contains</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_anal_fcn: anal.norevisit at 0x%08"</literal><name>PFMT64x</name><literal type="string">" %c\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>reftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>R_ANAL_RET_END</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_u_add</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_u_free</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>anal</name><operator>-&gt;</operator><name>visited</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>reftype</name> <operator>==</operator> <name>R_ANAL_REF_TYPE_CODE</name><operator>)</operator></expr> ?</condition><then> <expr><name>R_ANAL_FCN_TYPE_LOC</name></expr> </then><else>: <expr><name>R_ANAL_FCN_TYPE_FCN</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>=</operator> <literal type="number">0x28</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_anal_fcn_bb</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>depth</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to analyze basic block at 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>endsize</name></name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <name>R_ANAL_RET_END</name> <operator>&amp;&amp;</operator> <call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>endaddr</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_x86</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>endaddr</name> <operator>==</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>endaddr</name> <operator>+=</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>endaddr</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name>endaddr</name> <operator>&lt;</operator> <name>BB_ALIGN</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpmid</name></name> <operator>&amp;&amp;</operator> <name>is_x86</name> <operator>&amp;&amp;</operator> <name>endaddr</name> <operator>&gt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name>
<operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name>endaddr</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>endaddr</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JAYRO_04</name></expr></cpp:if>

<expr_stmt><expr><call><name>r_anal_function_resize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>endaddr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>r_anal_trim_jmprefs</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn_del_locs</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_ROOT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>iter2</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_FCN_TYPE_LOC</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_delete</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>r_anal_fcn_del</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn_del</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter_tmp</name></decl>;</decl_stmt>
<macro><name>r_list_foreach_safe</name> <argument_list>(<argument>a-&gt;fcns</argument>, <argument>iter</argument>, <argument>iter_tmp</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>D</name></type> <name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"fcn at %llx %llx\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_function_delete</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalFunction</name> <modifier>*</modifier></type><name>r_anal_get_fcn_in</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_get_functions_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_ROOT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>fcn</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_list_first</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalFunction</name> <modifier>*</modifier></type><name>r_anal_get_fcn_in_bounds</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_ANAL_FCN_TYPE_ROOT</name></expr>)</condition> <block>{<block_content>
<macro><name>r_list_foreach</name> <argument_list>(<argument>anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>fcn</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name> <operator>||</operator> <operator>(</operator><name>fcn</name> <operator>&amp;&amp;</operator> <name><name>fcn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_function_contains</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>fcn</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalFunction</name> <modifier>*</modifier></type><name>r_anal_get_function_byname</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>ht_pp_find</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>ht_name_fun</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <name>found</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_fcn_add_bb</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>jump</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>fail</name></decl></parameter>, <parameter><decl><type><name>R_BORROW</name> <name>RAnalDiff</name> <modifier>*</modifier></type><name>diff</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>D</name></type> <name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Add bb\n"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: empty basic block at 0x%08"</literal><name>PFMT64x</name><literal type="string">" is not allowed. pending discussion.\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>bb_max_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: can't allocate such big bb of %"</literal><name>PFMT64d</name><literal type="string">" bytes at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>st64</name><operator>)</operator><name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_delete_block</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>block</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_x86</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_x86</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_fcn_invalidate_read_ahead_cache</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fcn_recurse</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_block_set_size</name> <argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>r_anal_create_block</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>D</name></type> <name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: r_anal_fcn_add_bb failed in fcn 0x%08"</literal><name>PFMT64x</name><literal type="string">" at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_function_add_block</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>jump</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>fail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>fail</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>block</name><operator>-&gt;</operator><name>diff</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>diff</name></name> <operator>=</operator> <call><name>r_anal_diff_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>diff</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>diff</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>diff</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>block</name><operator>-&gt;</operator><name>diff</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>diff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_function_loops</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>loops</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>loops</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>loops</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>loops</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_function_complexity</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>






<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>P</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>N</name><operator>++</operator></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>anal</name> <operator>||</operator> <name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: invalid bb jump/fail pair at 0x%08"</literal><name>PFMT64x</name><literal type="string">" (fcn 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>P</name><operator>++</operator></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>E</name><operator>++</operator></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>E</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name></name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>cases</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>E</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name><operator>-&gt;</operator><name>cases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>E</name> <operator>-</operator> <name>N</name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>P</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>anal</name> <operator>||</operator> <name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: CC = E(%d) - N(%d) + (2 * P(%d)) &lt; 1 at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_anal_function_get_json</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>function</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_ret</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.ret"</literal></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_args</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argc_str</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><ternary><condition><expr><name>argc_str</name></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>argc_str</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>no_return</name> <init>= <expr><call><name>r_anal_noreturn_at_addr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"noreturn"</literal></expr></argument>, <argument><expr><name>no_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ret"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>ret_type</name></expr>?</condition><then><expr><name>ret_type</name></expr></then><else>: <expr><literal type="string">"void"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_arg_i</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.arg.%d"</literal></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_i</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_arg_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg_i</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>comma</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>comma</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc_arg</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>r_reg_get_name_idx</name> <argument_list>(<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"A%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cc_arg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"cc"</literal></expr></argument>, <argument><expr><name>cc_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_arg_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>pj_drain</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_anal_function_get_signature</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>function</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>realname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>import_substring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name><name>a</name><operator>-&gt;</operator><name>flag_get</name></name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>flb</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>space</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"imports"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>import_substring</name> <operator>=</operator> <call><name>r_str_rchr</name> <argument_list>(<argument><expr><name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>import_substring</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>realname</name> <operator>=</operator> <name>import_substring</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>realname</name> <operator>=</operator> <name><name>function</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_ret</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.ret"</literal></expr></argument>, <argument><expr><name>realname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_args</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name>realname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argc_str</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><ternary><condition><expr><name>argc_str</name></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>argc_str</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sdb_arg_i</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"func.%s.arg.%d"</literal></expr></argument>, <argument><expr><name>realname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_i</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>sdb_arg_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_i_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>arg_i_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>arg_i</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arg_i</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>arg_i</name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>arg_i</name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>arg_i</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>arg_i</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_args</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>argc</name><operator>)</operator></expr>
?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s, "</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>args</name> <operator>=</operator> <name>new_args</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_arg_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s (%s);"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>ret_type</name></expr>?</condition><then> <expr><name>ret_type</name></expr></then><else>: <expr><literal type="string">"void"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>realname</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sdb_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_str_to_fcn</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>a</name> <operator>||</operator> <name>f</name> <operator>||</operator> <name>sig</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_string</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_save_parsed_type</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>error_msg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalFunction</name> <modifier>*</modifier></type><name>r_anal_fcn_next</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>closer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;</operator> <name>addr</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>closer</name> <operator>||</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name><name>closer</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>closer</name> <operator>=</operator> <name>fcni</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>closer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn_count</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&gt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>RAnalBlock</name> <modifier>*</modifier></type><name>r_anal_fcn_bbget_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>fcn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_x86</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&gt;=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <operator>(</operator><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>jmpmid</name></name> <operator>||</operator> <operator>!</operator><name>is_x86</name> <operator>||</operator> <call><name>r_anal_bb_op_starts_at</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>bb</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalBlock</name> <modifier>*</modifier></type><name>r_anal_fcn_bbget_at</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>fcn</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>bb</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>ut32</name></type> <name>r_anal_function_cost</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>totalCycles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>end</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>totalCycles</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>cycles</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>totalCycles</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_function_count_edges</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <name>int</name> <modifier>*</modifier></type><name>ebbs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edges</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ebbs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ebbs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ebbs</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ebbs</name> <operator>=</operator> <operator>*</operator><name>ebbs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>edges</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>edges</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<return>return <expr><name>edges</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_function_purity</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fcn</name><operator>-&gt;</operator><name>has_changed</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><call><name>ht_up_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ht</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>check_purity</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>fcn</name><operator>-&gt;</operator><name>is_pure</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>can_affect_bp</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name><modifier>*</modifier></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opdreg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dst</name> <operator>&amp;&amp;</operator> <name><name>dst</name><operator>-&gt;</operator><name>reg</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opsreg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>src</name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>reg</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>src</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp_name</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_bp_dst</name> <init>= <expr><name>opdreg</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>memref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>bp_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_bp_src</name> <init>= <expr><name>opsreg</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>memref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>opsreg</name></expr></argument>, <argument><expr><name>bp_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_XCHG</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>is_bp_src</name> <operator>||</operator> <name>is_bp_dst</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>is_bp_dst</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>__anal_fcn_check_bp_use</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>str_to_find</name><index>[<expr><literal type="number">40</literal></expr>]</index></name> <init>= <expr><literal type="string">"\"type\":\"reg\",\"value\":\""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>str_to_find</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">39</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalOp</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>end</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_VAL</name> <operator>|</operator> <name>R_ANAL_OP_MASK_OPEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>op</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>can_affect_bp</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>reg</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name>
<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>can_affect_bp</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_ADD</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_AND</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_CMOV</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_NOT</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_OR</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ROL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_ROR</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SAL</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SAR</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SHR</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SUB</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_XOR</name></expr>:</case>
<case>case <expr><name>R_ANAL_OP_TYPE_SHL</name></expr>:</case>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>.</operator><name>opex</name><operator>.</operator><name>ptr</name></name></expr> ?</condition><then> <expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>opex</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>str_to_find</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&amp;&amp;</operator> <name>pos</name> <operator>-</operator> <name><name>op</name><operator>.</operator><name>opex</name><operator>.</operator><name>ptr</name></name> <operator>&lt;</operator> <literal type="number">60</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_XCHG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>.</operator><name>opex</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>op</name><operator>.</operator><name>opex</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>str_to_find</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>R_ANAL_OP_TYPE_POP</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>op</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_function_check_bp_use</name><parameter_list>(<parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>__anal_fcn_check_bp_use</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
