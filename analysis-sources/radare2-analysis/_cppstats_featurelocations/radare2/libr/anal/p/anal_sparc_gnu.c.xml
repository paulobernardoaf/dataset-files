<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\anal\p\anal_sparc_gnu.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_asm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>

<enum>enum <block>{
<decl><name>GPR_G0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>GPR_G1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>GPR_G2</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>GPR_G3</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>GPR_G4</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>GPR_G5</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,
<decl><name>GPR_G6</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>,
<decl><name>GPR_G7</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,
<decl><name>GPR_O0</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>,
<decl><name>GPR_O1</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>,
<decl><name>GPR_O2</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>,
<decl><name>GPR_O3</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>,
<decl><name>GPR_O4</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>,
<decl><name>GPR_O5</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>,
<decl><name>GPR_O6</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>,
<decl><name>GPR_O7</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>,
<decl><name>GPR_L0</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>,
<decl><name>GPR_L1</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>,
<decl><name>GPR_L2</name> <init>= <expr><literal type="number">18</literal></expr></init></decl>,
<decl><name>GPR_L3</name> <init>= <expr><literal type="number">19</literal></expr></init></decl>,
<decl><name>GPR_L4</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>,
<decl><name>GPR_L5</name> <init>= <expr><literal type="number">21</literal></expr></init></decl>,
<decl><name>GPR_L6</name> <init>= <expr><literal type="number">22</literal></expr></init></decl>,
<decl><name>GPR_L7</name> <init>= <expr><literal type="number">23</literal></expr></init></decl>,
<decl><name>GPR_I0</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>,
<decl><name>GPR_I1</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>,
<decl><name>GPR_I2</name> <init>= <expr><literal type="number">26</literal></expr></init></decl>,
<decl><name>GPR_I3</name> <init>= <expr><literal type="number">27</literal></expr></init></decl>,
<decl><name>GPR_I4</name> <init>= <expr><literal type="number">28</literal></expr></init></decl>,
<decl><name>GPR_I5</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>,
<decl><name>GPR_I6</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>,
<decl><name>GPR_I7</name> <init>= <expr><literal type="number">31</literal></expr></init></decl>,
}</block>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name><name>gpr_regs</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"g0"</literal></expr>, <expr><literal type="string">"g1"</literal></expr>, <expr><literal type="string">"g2"</literal></expr>, <expr><literal type="string">"g3"</literal></expr>, <expr><literal type="string">"g4"</literal></expr>, <expr><literal type="string">"g5"</literal></expr>, <expr><literal type="string">"g6"</literal></expr>, <expr><literal type="string">"g7"</literal></expr>,
<expr><literal type="string">"o0"</literal></expr>, <expr><literal type="string">"o1"</literal></expr>, <expr><literal type="string">"o2"</literal></expr>, <expr><literal type="string">"o3"</literal></expr>, <expr><literal type="string">"o4"</literal></expr>, <expr><literal type="string">"o5"</literal></expr>, <expr><literal type="string">"o6"</literal></expr>, <expr><literal type="string">"o7"</literal></expr>,
<expr><literal type="string">"l0"</literal></expr>, <expr><literal type="string">"l1"</literal></expr>, <expr><literal type="string">"l2"</literal></expr>, <expr><literal type="string">"l3"</literal></expr>, <expr><literal type="string">"l4"</literal></expr>, <expr><literal type="string">"l5"</literal></expr>, <expr><literal type="string">"l6"</literal></expr>, <expr><literal type="string">"l7"</literal></expr>,
<expr><literal type="string">"i0"</literal></expr>, <expr><literal type="string">"i1"</literal></expr>, <expr><literal type="string">"i2"</literal></expr>, <expr><literal type="string">"i3"</literal></expr>, <expr><literal type="string">"i4"</literal></expr>, <expr><literal type="string">"i5"</literal></expr>, <expr><literal type="string">"i6"</literal></expr>,<expr><literal type="string">"i7"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<enum>enum <block>{
<decl><name>ICC_A</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>ICC_CC</name> <init>= <expr><literal type="number">0xd</literal></expr></init></decl>,
<decl><name>ICC_CS</name> <init>= <expr><literal type="number">0x5</literal></expr></init></decl>,
<decl><name>ICC_E</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>ICC_G</name> <init>= <expr><literal type="number">0xa</literal></expr></init></decl>,
<decl><name>ICC_GE</name> <init>= <expr><literal type="number">0xb</literal></expr></init></decl>,
<decl><name>ICC_GU</name> <init>= <expr><literal type="number">0xc</literal></expr></init></decl>,
<decl><name>ICC_L</name> <init>= <expr><literal type="number">0x3</literal></expr></init></decl>,
<decl><name>ICC_LE</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>ICC_LEU</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>ICC_N</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
<decl><name>ICC_NE</name> <init>= <expr><literal type="number">0x9</literal></expr></init></decl>,
<decl><name>ICC_NEG</name> <init>= <expr><literal type="number">0x6</literal></expr></init></decl>,
<decl><name>ICC_POS</name> <init>= <expr><literal type="number">0xe</literal></expr></init></decl>,
<decl><name>ICC_VC</name> <init>= <expr><literal type="number">0xf</literal></expr></init></decl>,
<decl><name>ICC_VS</name> <init>= <expr><literal type="number">0x7</literal></expr></init></decl>,
}</block>;</enum>

<enum>enum <block>{
<decl><name>FCC_A</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>FCC_E</name> <init>= <expr><literal type="number">0x9</literal></expr></init></decl>,
<decl><name>FCC_G</name> <init>= <expr><literal type="number">0x6</literal></expr></init></decl>,
<decl><name>FCC_GE</name> <init>= <expr><literal type="number">0xb</literal></expr></init></decl>,
<decl><name>FCC_L</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>FCC_LE</name> <init>= <expr><literal type="number">0xd</literal></expr></init></decl>,
<decl><name>FCC_LG</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>FCC_N</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
<decl><name>FCC_NE</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>FCC_O</name> <init>= <expr><literal type="number">0xf</literal></expr></init></decl>,
<decl><name>FCC_U</name> <init>= <expr><literal type="number">0x7</literal></expr></init></decl>,
<decl><name>FCC_UE</name> <init>= <expr><literal type="number">0xa</literal></expr></init></decl>,
<decl><name>FCC_UG</name> <init>= <expr><literal type="number">0x5</literal></expr></init></decl>,
<decl><name>FCC_UGE</name> <init>= <expr><literal type="number">0xc</literal></expr></init></decl>,
<decl><name>FCC_UL</name> <init>= <expr><literal type="number">0x3</literal></expr></init></decl>,
<decl><name>FCC_ULE</name> <init>= <expr><literal type="number">0xe</literal></expr></init></decl>,
}</block>;</enum>



<enum>enum <block>{
<decl><name>R_ANAL_COND_ALWAYS</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>R_ANAL_COND_NEVER</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>,
<decl><name>R_ANAL_COND_UNKNOWN</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type> <name>icc_to_r_cond</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch<condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ICC_A</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_ALWAYS</name></expr>;</return>
<case>case <expr><name>ICC_CC</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GE</name></expr>;</return>
<case>case <expr><name>ICC_CS</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LT</name></expr>;</return>
<case>case <expr><name>ICC_E</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_EQ</name></expr>;</return>
<case>case <expr><name>ICC_G</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GT</name></expr>;</return>
<case>case <expr><name>ICC_GE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GE</name></expr>;</return>
<case>case <expr><name>ICC_GU</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GT</name></expr>;</return>
<case>case <expr><name>ICC_L</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LT</name></expr>;</return>
<case>case <expr><name>ICC_LE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LE</name></expr>;</return>
<case>case <expr><name>ICC_LEU</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LE</name></expr>;</return>
<case>case <expr><name>ICC_N</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_NEVER</name></expr>;</return>
<case>case <expr><name>ICC_NE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_NE</name></expr>;</return>
<case>case <expr><name>ICC_NEG</name></expr>:</case>
<case>case <expr><name>ICC_POS</name></expr>:</case>
<case>case <expr><name>ICC_VC</name></expr>:</case>
<case>case <expr><name>ICC_VS</name></expr>:</case>
<default>default:</default> <return>return <expr><name>R_ANAL_COND_UNKNOWN</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcc_to_r_cond</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>FCC_A</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_ALWAYS</name></expr>;</return>
<case>case <expr><name>FCC_E</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_EQ</name></expr>;</return>
<case>case <expr><name>FCC_G</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GT</name></expr>;</return>
<case>case <expr><name>FCC_GE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_GE</name></expr>;</return>
<case>case <expr><name>FCC_L</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LT</name></expr>;</return>
<case>case <expr><name>FCC_LE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_LE</name></expr>;</return>
<case>case <expr><name>FCC_LG</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_NE</name></expr>;</return>
<case>case <expr><name>FCC_N</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_NEVER</name></expr>;</return>
<case>case <expr><name>FCC_NE</name></expr>:</case> <return>return <expr><name>R_ANAL_COND_NE</name></expr>;</return>
<case>case <expr><name>FCC_O</name></expr>:</case>
<case>case <expr><name>FCC_U</name></expr>:</case>
<case>case <expr><name>FCC_UE</name></expr>:</case>
<case>case <expr><name>FCC_UG</name></expr>:</case>
<case>case <expr><name>FCC_UGE</name></expr>:</case>
<case>case <expr><name>FCC_UL</name></expr>:</case>
<case>case <expr><name>FCC_ULE</name></expr>:</case>
<default>default:</default>
<return>return <expr><name>R_ANAL_COND_UNKNOWN</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OP</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 30) &amp; 0x3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OP2</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 22) &amp; 0x7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_OP3</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 19) &amp; 0x3f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_COND</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 25) &amp; 0x1f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_RD</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 25) &amp; 0x1f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_RS1</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 14) &amp; 0x1f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_LDST_I</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 13) &amp; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_ASI</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 5) &amp; 0xff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_RS2</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 0) &amp; 0x1f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_IMM</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 0) &amp; ((1 &lt;&lt; (n)) - 1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_SIMM</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SEX (X_IMM ((i), (n)), (n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_DISP22</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 0) &amp; 0x3fffff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_IMM22</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>X_DISP22 (i)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_DISP30</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 0) &amp; 0x3fffffff)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_DISP16</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((((i) &gt;&gt; 20) &amp; 3) &lt;&lt; 14) | (((i) &gt;&gt; 0) &amp; 0x3fff))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_DISP19</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((i) &gt;&gt; 0) &amp; 0x7ffff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>X_MEMBAR</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((i) &amp; 0x7f)</cpp:value></cpp:define>

<enum>enum <block>{
<decl><name>OP_0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>OP_1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>OP_2</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>OP_3</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
}</block>;</enum>

<enum>enum <block>{
<decl><name>OP2_ILLTRAP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>OP2_BPcc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>OP2_Bicc</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>OP2_BPr</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>OP2_SETHI</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>OP2_FBPfcc</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,
<decl><name>OP2_FBfcc</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>,
<decl><name>OP2_INV</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,
}</block>;</enum>

<enum>enum <block>{
<decl><name>OP32_ADD</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,
<decl><name>OP32_ADDcc</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>OP32_TADDcc</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
<decl><name>OP32_WRY</name> <init>= <expr><literal type="number">0x30</literal></expr></init></decl>, 
<decl><name>OP32_AND</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<decl><name>OP32_ANDcc</name> <init>= <expr><literal type="number">0x11</literal></expr></init></decl>,
<decl><name>OP32_TSUBcc</name> <init>= <expr><literal type="number">0x21</literal></expr></init></decl>,
<decl><name>OP32_SAVED</name> <init>= <expr><literal type="number">0x31</literal></expr></init></decl>, 
<decl><name>OP32_OR</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>OP32_ORcc</name> <init>= <expr><literal type="number">0x12</literal></expr></init></decl>,
<decl><name>OP32_TADDccTV</name> <init>= <expr><literal type="number">0x22</literal></expr></init></decl>,
<decl><name>OP32_WRPR</name> <init>= <expr><literal type="number">0x32</literal></expr></init></decl>,
<decl><name>OP32_XOR</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>,
<decl><name>OP32_XORcc</name> <init>= <expr><literal type="number">0x13</literal></expr></init></decl>,
<decl><name>OP32_TSUBccTV</name> <init>= <expr><literal type="number">0x23</literal></expr></init></decl>,
<decl><name>OP32_SUB</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>OP32_SUBcc</name> <init>= <expr><literal type="number">0x14</literal></expr></init></decl>,
<decl><name>OP32_MULSccD</name> <init>= <expr><literal type="number">0x24</literal></expr></init></decl>,
<decl><name>OP32_FPop1</name> <init>= <expr><literal type="number">0x34</literal></expr></init></decl>,
<decl><name>OP32_ANDN</name> <init>= <expr><literal type="number">0x05</literal></expr></init></decl>,
<decl><name>OP32_ANDNcc</name> <init>= <expr><literal type="number">0x15</literal></expr></init></decl>,
<decl><name>OP32_SLL</name> <init>= <expr><literal type="number">0x25</literal></expr></init></decl>, 
<decl><name>OP32_FPop2</name> <init>= <expr><literal type="number">0x35</literal></expr></init></decl>,
<decl><name>OP32_ORN</name> <init>= <expr><literal type="number">0x06</literal></expr></init></decl>,
<decl><name>OP32_ORNcc</name> <init>= <expr><literal type="number">0x16</literal></expr></init></decl>,
<decl><name>OP32_SRL</name> <init>= <expr><literal type="number">0x26</literal></expr></init></decl>, 
<decl><name>OP32_XNOR</name> <init>= <expr><literal type="number">0x07</literal></expr></init></decl>,
<decl><name>OP32_XNORcc</name> <init>= <expr><literal type="number">0x17</literal></expr></init></decl>,
<decl><name>OP32_SRA</name> <init>= <expr><literal type="number">0x27</literal></expr></init></decl>, 
<decl><name>OP32_ADDC</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
<decl><name>OP32_ADDCcc</name> <init>= <expr><literal type="number">0x18</literal></expr></init></decl>,
<decl><name>OP32_RDY</name> <init>= <expr><literal type="number">0x28</literal></expr></init></decl>, 

<decl><name>OP32_JMPL</name> <init>= <expr><literal type="number">0x38</literal></expr></init></decl>,
<decl><name>OP32_MULX</name> <init>= <expr><literal type="number">0x09</literal></expr></init></decl>,
<decl><name>OP32_RETURN</name> <init>= <expr><literal type="number">0x39</literal></expr></init></decl>,
<decl><name>OP32_UMUL</name> <init>= <expr><literal type="number">0x0a</literal></expr></init></decl>,
<decl><name>OP32_UMULcc</name> <init>= <expr><literal type="number">0x1a</literal></expr></init></decl>,
<decl><name>OP32_RDPR</name> <init>= <expr><literal type="number">0x2a</literal></expr></init></decl>,
<decl><name>OP32_Tcc</name> <init>= <expr><literal type="number">0x3a</literal></expr></init></decl>,
<decl><name>OP32_SMULD</name> <init>= <expr><literal type="number">0x0b</literal></expr></init></decl>,
<decl><name>OP32_SMULcc</name> <init>= <expr><literal type="number">0x1b</literal></expr></init></decl>,
<decl><name>OP32_FLUSHW</name> <init>= <expr><literal type="number">0x2b</literal></expr></init></decl>,
<decl><name>OP32_FLUSH</name> <init>= <expr><literal type="number">0x3b</literal></expr></init></decl>,
<decl><name>OP32_SUBC</name> <init>= <expr><literal type="number">0x0c</literal></expr></init></decl>,
<decl><name>OP32_SUBCcc</name> <init>= <expr><literal type="number">0x1c</literal></expr></init></decl>,
<decl><name>OP32_MOVcc</name> <init>= <expr><literal type="number">0x2c</literal></expr></init></decl>,
<decl><name>OP32_SAVE</name> <init>= <expr><literal type="number">0x3c</literal></expr></init></decl>,
<decl><name>OP32_UDIVX</name> <init>= <expr><literal type="number">0x0d</literal></expr></init></decl>,
<decl><name>OP32_SDIVX</name> <init>= <expr><literal type="number">0x2d</literal></expr></init></decl>,
<decl><name>OP32_RESTORE</name> <init>= <expr><literal type="number">0x3d</literal></expr></init></decl>,
<decl><name>OP32_UDIV</name> <init>= <expr><literal type="number">0x0e</literal></expr></init></decl>,
<decl><name>OP32_UDIVcc</name> <init>= <expr><literal type="number">0x1e</literal></expr></init></decl>,
<decl><name>OP32_POPC</name> <init>= <expr><literal type="number">0x2e</literal></expr></init></decl>,
<decl><name>OP32_DONE</name> <init>= <expr><literal type="number">0x3e</literal></expr></init></decl>, 
<decl><name>OP32_SDIV</name> <init>= <expr><literal type="number">0x0f</literal></expr></init></decl>,
<decl><name>OP32_SDIVcc</name> <init>= <expr><literal type="number">0x1f</literal></expr></init></decl>,
<decl><name>OP32_MOVr</name> <init>= <expr><literal type="number">0x2f</literal></expr></init></decl>,

<decl><name>OP32_INV1</name> <init>= <expr><literal type="number">0x33</literal></expr></init></decl>,
<decl><name>OP32_INV2</name> <init>= <expr><literal type="number">0x19</literal></expr></init></decl>,
<decl><name>OP32_INV3</name> <init>= <expr><literal type="number">0x29</literal></expr></init></decl>,
<decl><name>OP32_INV4</name> <init>= <expr><literal type="number">0x1d</literal></expr></init></decl>,
<decl><name>OP32_INV5</name> <init>= <expr><literal type="number">0x3f</literal></expr></init></decl>,

<decl><name>OP32_CONDINV1</name> <init>= <expr><literal type="number">0x30</literal></expr></init></decl>,
<decl><name>OP32_CONDINV2</name> <init>= <expr><literal type="number">0x28</literal></expr></init></decl>,
<decl><name>OP32_CONDINV3</name> <init>= <expr><literal type="number">0x2e</literal></expr></init></decl>,
}</block>;</enum>

<enum>enum <block>{
<decl><name>OP33_INV1</name> <init>= <expr><literal type="number">0x31</literal></expr></init></decl>,
<decl><name>OP33_INV2</name> <init>= <expr><literal type="number">0x35</literal></expr></init></decl>,
<decl><name>OP33_INV3</name> <init>= <expr><literal type="number">0x28</literal></expr></init></decl>,
<decl><name>OP33_INV4</name> <init>= <expr><literal type="number">0x38</literal></expr></init></decl>,
<decl><name>OP33_INV5</name> <init>= <expr><literal type="number">0x29</literal></expr></init></decl>,
<decl><name>OP33_INV6</name> <init>= <expr><literal type="number">0x39</literal></expr></init></decl>,
<decl><name>OP33_INV7</name> <init>= <expr><literal type="number">0x2a</literal></expr></init></decl>,
<decl><name>OP33_INV8</name> <init>= <expr><literal type="number">0x3a</literal></expr></init></decl>,
<decl><name>OP33_INV9</name> <init>= <expr><literal type="number">0x2b</literal></expr></init></decl>,
<decl><name>OP33_INV10</name> <init>= <expr><literal type="number">0x3b</literal></expr></init></decl>,
<decl><name>OP33_INV11</name> <init>= <expr><literal type="number">0x0c</literal></expr></init></decl>,
<decl><name>OP33_INV12</name> <init>= <expr><literal type="number">0x1c</literal></expr></init></decl>,
<decl><name>OP33_INV13</name> <init>= <expr><literal type="number">0x2c</literal></expr></init></decl>,
<decl><name>OP33_INV14</name> <init>= <expr><literal type="number">0x2e</literal></expr></init></decl>,
<decl><name>OP33_INV15</name> <init>= <expr><literal type="number">0x2f</literal></expr></init></decl>,
<decl><name>OP33_INV16</name> <init>= <expr><literal type="number">0x3f</literal></expr></init></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name>st64</name></type> <name>get_immed_sgnext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>nbit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>mask</name> <init>= <expr><operator>~</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nbit</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>st64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>insn</name> <operator>&amp;</operator> <operator>~</operator><name>mask</name><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>insn</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>ut64</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>nbit</name><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <name>nbit</name><operator>)</operator> <operator>*</operator> <name>mask</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RAnalValue</name> <modifier>*</modifier></type> <name>value_fill_addr_pc_disp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>st64</name></type> <name>disp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>r_anal_value_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>disp</name></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RAnalValue</name> <modifier>*</modifier></type> <name>value_fill_addr_reg_regdelta</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>anal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ireg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>iregdelta</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>r_anal_value_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <call><name>r_reg_get</name><argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>gpr_regs</name><index>[<expr><name>ireg</name></expr>]</index></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <call><name>r_reg_get</name><argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>gpr_regs</name><index>[<expr><name>iregdelta</name></expr>]</index></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RAnalValue</name> <modifier>*</modifier></type> <name>value_fill_addr_reg_disp</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>anal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ireg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>st64</name></type> <name>disp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>r_anal_value_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <call><name>r_reg_get</name><argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>gpr_regs</name><index>[<expr><name>ireg</name></expr>]</index></name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>disp</name></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>anal_call</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>st64</name></type> <name>disp</name> <init>= <expr><operator>(</operator><call><name>get_immed_sgnext</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <call><name>value_fill_addr_pc_disp</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>disp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>anal_jmpl</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <specifier>const</specifier> <modifier>*</modifier> <specifier>const</specifier></type> <name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>st64</name></type> <name>disp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>X_LDST_I</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>disp</name> <operator>=</operator> <call><name>get_immed_sgnext</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>X_RD</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GPR_O7</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_UCALL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>X_RD</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GPR_G0</name>
<operator>&amp;&amp;</operator> <call><name>X_LDST_I</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GPR_I7</name> <operator>||</operator> <call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GPR_O7</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>disp</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>eob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_UJMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>eob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>X_LDST_I</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <call><name>value_fill_addr_reg_disp</name><argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <call><name>value_fill_addr_reg_regdelta</name><argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>X_RS2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>anal_branch</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>st64</name></type> <name>disp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r_cond</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>eob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_Bicc</name> <operator>||</operator> <call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_BPcc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r_cond</name> <operator>=</operator> <call><name>icc_to_r_cond</name> <argument_list>(<argument><expr><call><name>X_COND</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_FBfcc</name> <operator>||</operator> <call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_FBPfcc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r_cond</name> <operator>=</operator> <call><name>fcc_to_r_cond</name> <argument_list>(<argument><expr><call><name>X_COND</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_BPr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r_cond</name> <operator>=</operator> <name>R_ANAL_COND_UNKNOWN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r_cond</name> <operator>==</operator> <name>R_ANAL_COND_ALWAYS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_JMP</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>r_cond</name> <operator>==</operator> <name>R_ANAL_COND_NEVER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_NOP</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_CJMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>X_OP2</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_Bicc</name> <operator>||</operator> <call><name>X_OP2</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_FBfcc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>disp</name> <operator>=</operator> <call><name>get_immed_sgnext</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_BPcc</name> <operator>||</operator> <call><name>X_OP2</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_FBPfcc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>disp</name> <operator>=</operator> <call><name>get_immed_sgnext</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP2_BPr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>disp</name> <operator>=</operator> <call><name>get_immed_sgnext</name> <argument_list>(<argument><expr><call><name>X_DISP16</name> <argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <call><name>value_fill_addr_pc_disp</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name>disp</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>sparc_op</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>RAnalOpMask</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>insn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RAnalOp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>family</name></name> <operator>=</operator> <name>R_ANAL_OP_FAMILY_CPU</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>insn</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>insn</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>insn</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>insn</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>insn</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>X_OP</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_0</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><call><name>X_OP2</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OP2_ILLTRAP</name></expr>:</case>
<case>case <expr><name>OP2_INV</name></expr>:</case>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><name>OP2_BPcc</name></expr>:</case>
<case>case <expr><name>OP2_Bicc</name></expr>:</case>
<case>case <expr><name>OP2_BPr</name></expr>:</case>
<case>case <expr><name>OP2_FBPfcc</name></expr>:</case>
<case>case <expr><name>OP2_FBfcc</name></expr>:</case>
<expr_stmt><expr><call><name>anal_branch</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>X_OP</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>anal_call</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>X_OP</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_2</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><call><name>X_OP3</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>OP32_INV1</name></expr>:</case>
<case>case <expr><name>OP32_INV2</name></expr>:</case>
<case>case <expr><name>OP32_INV3</name></expr>:</case>
<case>case <expr><name>OP32_INV4</name></expr>:</case>
<case>case <expr><name>OP32_INV5</name></expr>:</case>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<break>break;</break>
<case>case <expr><name>OP32_CONDINV1</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><call><name>X_RD</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>OP32_CONDINV2</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>OP32_CONDINV3</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><call><name>X_RS1</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>OP32_JMPL</name></expr>:</case>
<expr_stmt><expr><call><name>anal_jmpl</name><argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>X_OP</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_3</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><call><name>X_OP3</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OP33_INV1</name></expr>:</case>
<case>case <expr><name>OP33_INV2</name></expr>:</case>
<case>case <expr><name>OP33_INV3</name></expr>:</case>
<case>case <expr><name>OP33_INV4</name></expr>:</case>
<case>case <expr><name>OP33_INV5</name></expr>:</case>
<case>case <expr><name>OP33_INV6</name></expr>:</case>
<case>case <expr><name>OP33_INV7</name></expr>:</case>
<case>case <expr><name>OP33_INV8</name></expr>:</case>
<case>case <expr><name>OP33_INV9</name></expr>:</case>
<case>case <expr><name>OP33_INV10</name></expr>:</case>
<case>case <expr><name>OP33_INV11</name></expr>:</case>
<case>case <expr><name>OP33_INV12</name></expr>:</case>
<case>case <expr><name>OP33_INV13</name></expr>:</case>
<case>case <expr><name>OP33_INV14</name></expr>:</case>
<case>case <expr><name>OP33_INV15</name></expr>:</case>
<case>case <expr><name>OP33_INV16</name></expr>:</case>
<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_ANAL_OP_TYPE_ILL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_reg_profile</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>)</parameter_list> <block>{<block_content>







<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>=
<expr><literal type="string">"=PC pc\n"</literal>
<literal type="string">"=SP o6\n"</literal>
<literal type="string">"=BP i6\n"</literal>

<literal type="string">"gpr g0 .64 0 0\n"</literal>
<literal type="string">"gpr g1 .64 8 0\n"</literal>
<literal type="string">"gpr g2 .64 16 0\n"</literal>
<literal type="string">"gpr g3 .64 24 0\n"</literal>
<literal type="string">"gpr g4 .64 32 0\n"</literal>
<literal type="string">"gpr g5 .64 40 0\n"</literal>
<literal type="string">"gpr g6 .64 48 0\n"</literal>
<literal type="string">"gpr g7 .64 56 0\n"</literal>
<literal type="string">"gpr o0 .64 64 0\n"</literal>
<literal type="string">"gpr o1 .64 72 0\n"</literal>
<literal type="string">"gpr o2 .64 80 0\n"</literal>
<literal type="string">"gpr o3 .64 88 0\n"</literal>
<literal type="string">"gpr o4 .64 96 0\n"</literal>
<literal type="string">"gpr o5 .64 104 0\n"</literal>
<literal type="string">"gpr o6 .64 112 0\n"</literal>
<literal type="string">"gpr o7 .64 120 0\n"</literal>
<literal type="string">"gpr l0 .64 128 0\n"</literal>
<literal type="string">"gpr l1 .64 136 0\n"</literal>
<literal type="string">"gpr l2 .64 144 0\n"</literal>
<literal type="string">"gpr l3 .64 152 0\n"</literal>
<literal type="string">"gpr l4 .64 160 0\n"</literal>
<literal type="string">"gpr l5 .64 168 0\n"</literal>
<literal type="string">"gpr l6 .64 176 0\n"</literal>
<literal type="string">"gpr l7 .64 184 0\n"</literal>
<literal type="string">"gpr i0 .64 192 0\n"</literal>
<literal type="string">"gpr i1 .64 200 0\n"</literal>
<literal type="string">"gpr i2 .64 208 0\n"</literal>
<literal type="string">"gpr i3 .64 216 0\n"</literal>
<literal type="string">"gpr i4 .64 224 0\n"</literal>
<literal type="string">"gpr i5 .64 232 0\n"</literal>
<literal type="string">"gpr i6 .64 240 0\n"</literal>
<literal type="string">"gpr i7 .64 248 0\n"</literal>
<literal type="string">"gpr ccr .64 256 0\n"</literal>
<literal type="string">"gpr pc .64 264 0\n"</literal>
<literal type="string">"gpr ncp .64 272 0\n"</literal>
<literal type="string">"gpr y .64 280 0\n"</literal>
<literal type="string">"gpr asi .64 288 0\n"</literal>
<literal type="string">"gpr fprs .64 296 0\n"</literal>

<literal type="string">"fpu sf0 .32 304 0\n"</literal>
<literal type="string">"fpu sf1 .32 308 0\n"</literal>
<literal type="string">"fpu sf2 .32 312 0\n"</literal>
<literal type="string">"fpu sf3 .32 316 0\n"</literal>
<literal type="string">"fpu sf4 .32 320 0\n"</literal>
<literal type="string">"fpu sf5 .32 324 0\n"</literal>
<literal type="string">"fpu sf6 .32 328 0\n"</literal>
<literal type="string">"fpu sf7 .32 332 0\n"</literal>
<literal type="string">"fpu sf8 .32 336 0\n"</literal>
<literal type="string">"fpu sf9 .32 340 0\n"</literal>
<literal type="string">"fpu sf10 .32 344 0\n"</literal>
<literal type="string">"fpu sf11 .32 348 0\n"</literal>
<literal type="string">"fpu sf12 .32 352 0\n"</literal>
<literal type="string">"fpu sf13 .32 356 0\n"</literal>
<literal type="string">"fpu sf14 .32 360 0\n"</literal>
<literal type="string">"fpu sf15 .32 364 0\n"</literal>
<literal type="string">"fpu sf16 .32 368 0\n"</literal>
<literal type="string">"fpu sf17 .32 372 0\n"</literal>
<literal type="string">"fpu sf18 .32 376 0\n"</literal>
<literal type="string">"fpu sf19 .32 380 0\n"</literal>
<literal type="string">"fpu sf20 .32 384 0\n"</literal>
<literal type="string">"fpu sf21 .32 388 0\n"</literal>
<literal type="string">"fpu sf22 .32 392 0\n"</literal>
<literal type="string">"fpu sf23 .32 396 0\n"</literal>
<literal type="string">"fpu sf24 .32 400 0\n"</literal>
<literal type="string">"fpu sf25 .32 404 0\n"</literal>
<literal type="string">"fpu sf26 .32 408 0\n"</literal>
<literal type="string">"fpu sf27 .32 412 0\n"</literal>
<literal type="string">"fpu sf28 .32 416 0\n"</literal>
<literal type="string">"fpu sf29 .32 420 0\n"</literal>
<literal type="string">"fpu sf30 .32 424 0\n"</literal>
<literal type="string">"fpu sf31 .32 428 0\n"</literal>
<literal type="string">"fpu df0 .64 304 0\n"</literal> 
<literal type="string">"fpu df2 .64 312 0\n"</literal> 
<literal type="string">"fpu df4 .64 320 0\n"</literal> 
<literal type="string">"fpu df6 .64 328 0\n"</literal> 
<literal type="string">"fpu df8 .64 336 0\n"</literal> 
<literal type="string">"fpu df10 .64 344 0\n"</literal> 
<literal type="string">"fpu df12 .64 352 0\n"</literal> 
<literal type="string">"fpu df14 .64 360 0\n"</literal> 
<literal type="string">"fpu df16 .64 368 0\n"</literal> 
<literal type="string">"fpu df18 .64 376 0\n"</literal> 
<literal type="string">"fpu df20 .64 384 0\n"</literal> 
<literal type="string">"fpu df22 .64 392 0\n"</literal> 
<literal type="string">"fpu df24 .64 400 0\n"</literal> 
<literal type="string">"fpu df26 .64 408 0\n"</literal> 
<literal type="string">"fpu df28 .64 416 0\n"</literal> 
<literal type="string">"fpu df30 .64 424 0\n"</literal> 
<literal type="string">"fpu df32 .64 432 0\n"</literal>
<literal type="string">"fpu df34 .64 440 0\n"</literal>
<literal type="string">"fpu df36 .64 448 0\n"</literal>
<literal type="string">"fpu df38 .64 456 0\n"</literal>
<literal type="string">"fpu df40 .64 464 0\n"</literal>
<literal type="string">"fpu df42 .64 472 0\n"</literal>
<literal type="string">"fpu df44 .64 480 0\n"</literal>
<literal type="string">"fpu df46 .64 488 0\n"</literal>
<literal type="string">"fpu df48 .64 496 0\n"</literal>
<literal type="string">"fpu df50 .64 504 0\n"</literal>
<literal type="string">"fpu df52 .64 512 0\n"</literal>
<literal type="string">"fpu df54 .64 520 0\n"</literal>
<literal type="string">"fpu df56 .64 528 0\n"</literal>
<literal type="string">"fpu df58 .64 536 0\n"</literal>
<literal type="string">"fpu df60 .64 544 0\n"</literal>
<literal type="string">"fpu df62 .64 552 0\n"</literal>
<literal type="string">"fpu qf0 .128 304 0\n"</literal> 
<literal type="string">"fpu qf4 .128 320 0\n"</literal> 
<literal type="string">"fpu qf8 .128 336 0\n"</literal> 
<literal type="string">"fpu qf12 .128 352 0\n"</literal> 
<literal type="string">"fpu qf16 .128 368 0\n"</literal> 
<literal type="string">"fpu qf20 .128 384 0\n"</literal> 
<literal type="string">"fpu qf24 .128 400 0\n"</literal> 
<literal type="string">"fpu qf28 .128 416 0\n"</literal> 
<literal type="string">"fpu qf32 .128 432 0\n"</literal> 
<literal type="string">"fpu qf36 .128 448 0\n"</literal> 
<literal type="string">"fpu qf40 .128 464 0\n"</literal> 
<literal type="string">"fpu qf44 .128 480 0\n"</literal> 
<literal type="string">"fpu qf48 .128 496 0\n"</literal> 
<literal type="string">"fpu qf52 .128 512 0\n"</literal> 
<literal type="string">"fpu qf56 .128 528 0\n"</literal> 
<literal type="string">"fpu qf60 .128 544 0\n"</literal> 
<literal type="string">"gpr fsr .64 560 0\n"</literal></expr></init></decl>;</decl_stmt> 

<return>return <expr><call><name>r_reg_set_profile_string</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>archinfo</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>q</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">4</literal></expr>;</return> 
</block_content>}</block></function>

<decl_stmt><decl><type><name>RAnalPlugin</name></type> <name>r_anal_plugin_sparc_gnu</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"sparc.gnu"</literal></expr>,
<expr><operator>.</operator><name>desc</name> <operator>=</operator> <literal type="string">"SPARC analysis plugin"</literal></expr>,
<expr><operator>.</operator><name>license</name> <operator>=</operator> <literal type="string">"LGPL3"</literal></expr>,
<expr><operator>.</operator><name>arch</name> <operator>=</operator> <literal type="string">"sparc"</literal></expr>,
<expr><operator>.</operator><name>bits</name> <operator>=</operator> <literal type="number">32</literal> <operator>|</operator> <literal type="number">64</literal></expr>,
<expr><operator>.</operator><name>op</name> <operator>=</operator> <operator>&amp;</operator><name>sparc_op</name></expr>,
<expr><operator>.</operator><name>archinfo</name> <operator>=</operator> <name>archinfo</name></expr>,
<expr><operator>.</operator><name>set_reg_profile</name> <operator>=</operator> <name>set_reg_profile</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>R2_PLUGIN_INCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>R_API</name> <name>RLibStruct</name></type> <name>radare_plugin</name> <init>= <expr><block>{
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>R_LIB_TYPE_ANAL</name></expr>,
<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>r_anal_plugin_sparc_gnu</name></expr>,
<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>R2_VERSION</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
