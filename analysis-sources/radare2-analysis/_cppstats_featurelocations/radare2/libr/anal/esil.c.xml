<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats_featurelocations\radare2\libr\anal\esil.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_bind.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFDBG</name></cpp:macro> <cpp:value>if (esil &amp;&amp; esil-&gt;verbose &gt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFVBS</name></cpp:macro> <cpp:value>if (esil &amp;&amp; esil-&gt;verbose &gt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>R_ANAL_ESIL_FLAG_##x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cpuflag</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (esil) {if (y) { R_BIT_SET (&amp;esil-&gt;flags, FLG (x));} else { R_BIT_UNSET (&amp;esil-&gt;flags, FLG (x));} }</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ut64</name></type> <name>genmask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>m</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bits</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><literal type="number">2</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (esil-&gt;verbose) { eprintf ("%s\n", x); }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isnum</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>ispackedreg</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>ri</name></expr>?</condition><then> <expr><name><name>ri</name><operator>-&gt;</operator><name>packed_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isregornum</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>popRN</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>RAnalEsil</name> <modifier>*</modifier></type><name>r_anal_esil_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stacksize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iotrap</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalEsil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>=</operator> <name>stacksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto_count</name></name> <operator>=</operator> <name>R_ANAL_ESIL_GOTO_LIMIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name> <operator>=</operator> <name>iotrap</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_sources_init</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_interrupts_init</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>sessions</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>r_anal_esil_session_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name> <operator>=</operator> <call><name>genmask</name> <argument_list>(<argument><expr><name>addrsize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>esil</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_set_op</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RAnalEsilOpCb</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>push</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>pop</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name><argument_list>(<argument><expr><name>code</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>t</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><call><name>sdb_hash</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RAnalEsilOp</name> <modifier>*</modifier></type><name>eop</name> <init>= <expr><operator>(</operator><name>RAnalEsilOp</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eop</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eop</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr><name>RAnalEsilOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eop</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate esil-operation %s\n"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>eop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdb_num_exists</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot set esil-operation %s\n"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>eop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>eop</name><operator>-&gt;</operator><name>push</name></name> <operator>=</operator> <name>push</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eop</name><operator>-&gt;</operator><name>pop</name></name> <operator>=</operator> <name>pop</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eop</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>eop</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>r_anal_esil_fire_trap</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>trap_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>trap_code</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr></argument>, <argument><expr><name>trap_type</name></expr></argument>, <argument><expr><name>trap_code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalPlugin</name> <modifier>*</modifier></type><name>ap</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>-&gt;</operator><name>esil_trap</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>ap</name><operator>-&gt;</operator><name>esil_trap</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>trap_type</name></expr></argument>, <argument><expr><name>trap_code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
RAnalEsilTrapCB icb;
icb = (RAnalEsilTrapCB)sdb_ptr_get (esil-&gt;traps, i, 0);
return icb (esil, trap_type, trap_code);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_set_pc</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>esil_ops_free_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalEsilOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>RAnalEsilOp</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sdb_atoi</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_esil_free</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name>esil</name> <operator>==</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>esil_ops_free_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_interrupts_fini</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_sources_fini</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>db_trace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_fini</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_fini</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>sessions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_intr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_trap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_mdev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_todo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut8</name></type> <name>esil_internal_sizeof_reg</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>ri</name></expr>?</condition><then> <expr><name><name>ri</name><operator>-&gt;</operator><name>size</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>alignCheck</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>dataAlign</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_DATA_ALIGN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>!</operator><operator>(</operator><name>dataAlign</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>addr</name> <operator>%</operator> <name>dataAlign</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_mem_read</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alignCheck</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_mdev</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>mdev_range</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_range_in</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>mdev_range</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_mdev</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_mem_read_no_null</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alignCheck</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_mem_read</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>buf</name> <operator>&amp;&amp;</operator> <name>esil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alignCheck</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_read</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<macro><name>IFDBG</name></macro> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" R&gt; "</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_mem_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name> <operator>||</operator> <name><name>esil</name><operator>-&gt;</operator><name>nowrite</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>alignCheck</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_READ_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_mdev</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>mdev_range</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_str_range_in</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>mdev_range</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_mdev</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>write_at</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_WRITE_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_ioer</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_mem_write_no_null</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name> <operator>||</operator> <operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>nowrite</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>write_at</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>is_valid_offset</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>iotrap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_WRITE_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_mem_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>&amp;=</operator> <name><name>esil</name><operator>-&gt;</operator><name>addrmask</name></name></expr>;</expr_stmt>
<macro><name>IFDBG</name></macro> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" &lt;W "</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_write</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_write</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_write</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_write</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_reg_read</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_reg_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>internal_esil_reg_write_no_null</name> <parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: RReg profile does not contain PC register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: RReg profile does not contain SP register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: RReg profile does not contain BP register\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reg</name> <operator>&amp;&amp;</operator> <name><name>reg</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument> , <argument><expr><name>pc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>num</name><operator>)</operator></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_pushnum</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_push</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name> <operator>||</operator> <operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>str</name> <operator>||</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_anal_esil_pop</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><operator>--</operator><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_get_parm_type</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_ESIL_PARM_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_ESIL_PARM_NUM</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>not_a_number</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IS_DIGIT</name> <argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<goto>goto <name>not_a_number</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>R_ANAL_ESIL_PARM_NUM</name></expr>;</return>
<label><name>not_a_number</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>R_ANAL_ESIL_PARM_REG</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>R_ANAL_ESIL_PARM_INVALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_get_parm_size</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parm_type</name> <init>= <expr><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name> <operator>||</operator> <operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>parm_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_ESIL_PARM_NUM</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><name>R_ANAL_ESIL_PARM_REG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid arg (%s)\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_get_parm</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_reg_write</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>IFDBG</name></macro> <block>{<block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s=0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_write</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_write</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_write</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_write</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_reg_read_nocallback</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>old_hook_reg_read</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name> <operator>=</operator> <name>old_hook_reg_read</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_reg_read</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>localnum</name></decl>;</decl_stmt> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name>regname</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>&amp;</operator><name>localnum</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0LL</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_reg_read</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_read</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_zf</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <call><name>genmask</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_cf</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>src</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_ANAL_ESIL_PARM_NUM</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bit</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>mask</name> <init>= <expr><call><name>genmask</name> <argument_list>(<argument><expr><name>bit</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_bf</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>src</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_ANAL_ESIL_PARM_NUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bit</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>mask</name> <init>= <expr><call><name>genmask</name> <argument_list>(<argument><expr><operator>(</operator><name>bit</name> <operator>+</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_pf</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>c1</name> <init>= <expr><literal type="number">0x0101010101010101ULL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>c2</name> <init>= <expr><literal type="number">0x8040201008040201ULL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>c3</name> <init>= <expr><literal type="number">0x1FF</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>lsb</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>lsb</name> <operator>*</operator> <name>c1</name><operator>)</operator> <operator>&amp;</operator> <name>c2</name><operator>)</operator> <operator>%</operator> <name>c3</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_of</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_bit</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_bit</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>p_bit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_ANAL_ESIL_PARM_NUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bit</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>p_bit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_of: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><call><name>genmask</name> <argument_list>(<argument><expr><name>bit</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>, <macro><name>genmask</name> <argument_list>(<argument>(bit + <literal type="number">0x3f</literal>) &amp; <literal type="number">0x3f</literal></argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>result</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>&amp;</operator> <name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;</operator> <name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>&amp;</operator> <name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_sf</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_size</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>p_size</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>p_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_ANAL_ESIL_PARM_NUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>p_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>&gt;&gt;</operator> <name>size</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_ds</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>delay</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_jt</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>jump_target</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_js</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>jump_target_set</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_rs</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_address</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_weak_eq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>dst</name> <operator>&amp;&amp;</operator> <name>src</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>r_anal_esil_get_parm_type</name><argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>R_ANAL_ESIL_PARM_REG</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>src_num</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_eq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>src</name> <operator>||</operator> <operator>!</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing elements in the esil stack for '=' at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ispackedreg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src2</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newreg</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%sl"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>newreg</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>newreg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>beach</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read_nocallback</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_eq: invalid src"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_eq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>beach</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_neg</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>!</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>!</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" esil_neg: unknown reg %s\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_neg: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_negeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>!</operator><name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_negeq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_nop</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_andeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>&amp;</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name> <operator>&amp;</operator> <name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_andeq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_oreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>|</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name> <operator>|</operator> <name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_ordeq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_xoreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>^</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name> <operator>^</operator> <name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_xoreq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int esil_interrupt_linux_i386(RAnalEsil *esil) { 
ut32 sn, ret = 0;
char *usn = r_anal_esil_pop (esil);
if (usn) {
sn = (ut32) r_num_get (NULL, usn);
} else sn = 0x80;

if (sn == 3) {

esil-&gt;trap = R_ANAL_TRAP_BREAKPOINT;
esil-&gt;trap_code = 3;
return -1;
}

if (sn != 0x80) {
eprintf ("Interrupt 0x%x not handled.", sn);
esil-&gt;trap = R_ANAL_TRAP_UNHANDLED;
esil-&gt;trap_code = sn;
return -1;
}
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>r</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_reg_getv (esil-&gt;anal-&gt;reg, "##x##")</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rs</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rs</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_reg_setv (esil-&gt;anal-&gt;reg, "##x##", y)</cpp:value></cpp:define>
switch (r(eax)) {
case 1:
printf ("exit(%d)\n", (int)r(ebx));
rs(eax, -1);

break;
case 3:
ret = r(edx);
printf ("ret:%d = read(fd:%"PFMT64d", ptr:0x%08"PFMT64x", len:%"PFMT64d")\n",
(int)ret, r(ebx), r(ecx), r(edx));
rs(eax, ret);
break;
case 4:
ret = r(edx);
printf ("ret:%d = write(fd:%"PFMT64d", ptr:0x%08"PFMT64x", len:%"PFMT64d")\n",
(int)ret, r(ebx), r(ecx), r(edx));
rs(eax, ret);
break;
case 5:
ret = -1;
printf ("fd:%d = open(file:0x%08"PFMT64x", mode:%"PFMT64d", perm:%"PFMT64d")\n",
(int)ret, r(ebx), r(ecx), r(edx));
rs(eax, ret);
break;
}
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>r</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rs</name></cpp:undef>
return 0;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_trap</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>popRN</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>popRN</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_fire_trap</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_trap: missing parameters in stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_bits</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>popRN</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>setab</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>setab</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_bits: missing parameters in stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_interrupt</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>interrupt</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>popRN</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interrupt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>r_anal_esil_fire_interrupt</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name>interrupt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_cmp</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>-</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
x86 documentation:
CF - carry flag -- Set on high-order bit carry or borrow; cleared otherwise
num&gt;&gt;63
PF - parity flag
(num&amp;0xff)
Set if low-order eight bits of result contain an even number of "1" bits; cleared otherwise
ZF - zero flags
Set if result is zero; cleared otherwise
zf = num?0:1;
SF - sign flag
Set equal to high-order bit of result (0 if positive 1 if negative)
sf = ((st64)num)&lt;0)?1:0;
OF - overflow flag
if (a&gt;0&amp;&amp;b&gt;0 &amp;&amp; (a+b)&lt;0)
Set if result is too large a positive number or too small a negative number (excluding sign bit) to fit in destination operand; cleared otherwise

JBE: CF = 1 || ZF = 1

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int esil_ifset(RAnalEsil *esil) {
char *s, *src = r_anal_esil_pop (esil);
for (s=src; *s; s++) {
switch (*s) {
case 'z':
r_anal_esil_reg_write (esil, "zf", R_BIT_CHK(&amp;esil-&gt;flags, FLG(ZERO)));
break;
case 'c':
r_anal_esil_reg_write (esil, "cf", R_BIT_CHK(&amp;esil-&gt;flags, FLG(CARRY)));
break;
case 'o':
r_anal_esil_reg_write (esil, "of", R_BIT_CHK(&amp;esil-&gt;flags, FLG(OVERFLOW)));
break;
case 'p':
r_anal_esil_reg_write (esil, "pf", R_BIT_CHK(&amp;esil-&gt;flags, FLG(PARITY)));
break;
}
}
free (src);
return 0;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_if</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name> <init>= <expr><literal type="number">0LL</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_lsl</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsl: shift is too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name> <operator>&lt;&lt;</operator> <name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsl: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_lsleq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsleq: shift is too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>&lt;&lt;=</operator> <name>num2</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsleq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_lsr</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><name>num</name> <operator>&gt;&gt;</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsr: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_lsreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num2</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid shift at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>num2</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>&gt;&gt;=</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_lsreq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_asreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>op_num</name></decl>, <decl><type ref="prev"/><name>param_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>param</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param_num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>param_num</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isNegative</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>regsize</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isNegative</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>st32</name><operator>)</operator><name>op_num</name><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>st32</name></type> <name>snum</name> <init>= <expr><name>op_num</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <name>snum</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>isNegative</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>st64</name><operator>)</operator><name>op_num</name><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isNegative</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>regsize</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>st64</name><operator>)</operator><name>op_num</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>op_num</name> <operator>&gt;&gt;</operator> <name>param_num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op_num</name> <operator>&gt;&gt;=</operator> <name>param_num</name></expr>;</expr_stmt>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>st64</name><operator>)</operator><name>op_num</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>param_num</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>left_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name> <init>= <expr><name>regsize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>shift</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>shift</name></expr></argument> &gt;</argument_list></name> <name>regsize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid asreq shift of %d at 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>param_num</name> <operator>&gt;</operator> <name>regsize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid asreq shift of %"</literal><name>PFMT64d</name><literal type="string">" at 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>param_num</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>param_num</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;=</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid asreq shift of %d at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op_num</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>left_bits</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>param_num</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>left_bits</name> <operator>&lt;&lt;=</operator> <name>regsize</name> <operator>-</operator> <name>param_num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <name>left_bits</name> <operator>|</operator> <operator>(</operator><name>op_num</name> <operator>&gt;&gt;</operator> <name>param_num</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>op_num</name> <operator>&gt;&gt;=</operator> <name>param_num</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><name>op_num</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"esil_asr: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_asr</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>op_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>param_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>param</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param_num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>param_num</name> <operator>&gt;</operator> <name>regsize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid asr shift of %"</literal><name>PFMT64d</name><literal type="string">" at 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>param_num</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>param_num</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isNegative</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>regsize</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isNegative</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>st32</name><operator>)</operator><name>op_num</name><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>st32</name></type> <name>snum</name> <init>= <expr><name>op_num</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <name>snum</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>isNegative</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>st64</name><operator>)</operator><name>op_num</name><operator>)</operator><operator>&lt;</operator><literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isNegative</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>param_num</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>left_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>op_num</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>left_bits</name> <operator>=</operator> <operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <name>param_num</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>left_bits</name> <operator>&lt;&lt;=</operator> <name>regsize</name> <operator>-</operator> <name>param_num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>op_num</name> <operator>=</operator> <name>left_bits</name> <operator>|</operator> <operator>(</operator><name>op_num</name> <operator>&gt;&gt;</operator> <name>param_num</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>op_num</name> <operator>&gt;&gt;=</operator> <name>param_num</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><name>op_num</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_asr: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_ror</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num2</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><operator>(</operator><name>num</name> <operator>&gt;&gt;</operator> <name>num2</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>num</name> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>st64</name><operator>)</operator><name>num2</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_ror: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_rol</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>regsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>num2</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>res</name> <init>= <expr><operator>(</operator><name>num</name> <operator>&lt;&lt;</operator> <name>num2</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>num</name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>st64</name><operator>)</operator><name>num2</name><operator>)</operator> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_rol: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_and</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>&amp;=</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_and: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_xor</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>^=</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_xor: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_or</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>|=</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_xor: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r_anal_esil_trapstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>R_ANAL_TRAP_READ_ERR</name></expr>:</case>
<return>return <expr><literal type="string">"read-err"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_WRITE_ERR</name></expr>:</case>
<return>return <expr><literal type="string">"write-err"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_BREAKPOINT</name></expr>:</case>
<return>return <expr><literal type="string">"breakpoint"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_UNHANDLED</name></expr>:</case>
<return>return <expr><literal type="string">"unhandled"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_DIVBYZERO</name></expr>:</case>
<return>return <expr><literal type="string">"divbyzero"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_INVALID</name></expr>:</case>
<return>return <expr><literal type="string">"invalid"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_UNALIGNED</name></expr>:</case>
<return>return <expr><literal type="string">"unaligned"</literal></expr>;</return>
<case>case <expr><name>R_ANAL_TRAP_TODO</name></expr>:</case>
<return>return <expr><literal type="string">"todo"</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_dumpstack</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ESIL TRAP type %d code 0x%08x %s\n"</literal></expr></argument>,
<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name></expr></argument>,
<argument><expr><call><name>r_anal_esil_trapstr</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_break</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_clear</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_todo</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_goto</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_repeat</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_pop</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mod</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" esil_mod: Division by zero!\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name> <operator>%</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mod: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_modeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>d</name> <operator>%</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name> <operator>%</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_modeq: Division by zero!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_modeq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_modeq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_div</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_div: Division by zero!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name> <operator>/</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_div: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_diveq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>d</name> <operator>/</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name> <operator>/</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_diveq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_diveq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mul</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name> <operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mul: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mul: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_muleq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>d</name> <operator>*</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>s</name> <operator>*</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_muleq: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_muleq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_add</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_add: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_addeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>d</name> <operator>+</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_addeq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_inc</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_inc: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_inceq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>sd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src_dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_dst</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>R_ANAL_ESIL_PARM_REG</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>sd</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>sd</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>, <argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_inceq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_sub</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_sub: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_subeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_reg_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>d</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>d</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_subeq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_dec</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_dec: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_deceq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>sd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src_dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src_dst</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>r_anal_esil_get_parm_type</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>R_ANAL_ESIL_PARM_REG</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>sd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sd</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>sd</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>, <argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_deceq: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src_dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>bitmask</name> <init>= <expr><call><name>genmask</name> <argument_list>(<argument><expr><name>bits</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>, <decl><type ref="prev"/><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>bits</name> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>%</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>src2</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_write_ble</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_mem_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_write_ble</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_mem_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type> <name>oldhook</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_mem_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_mem_read</name></name> <operator>=</operator> <name>oldhook</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_read_ble64</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>&amp;</operator> <name>bitmask</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_write_ble</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_mem_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke3</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke16</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_poke_some</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>regsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr</name></decl>, <decl><type ref="prev"/><name>regs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>count</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>regs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>num64</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>foo</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_get_parm_size</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>foo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>foo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_write_ble</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>num64</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>, <argument><expr><name>regsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size_bytes</name> <init>= <expr><name>regsize</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>written</name> <init>= <expr><call><name>r_anal_esil_mem_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>size_bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <name>size_bytes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>size_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>res</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut32</name></type> <name>bytes</name> <init>= <expr><name>bits</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ESIL-ERROR at 0x%08"</literal><name>PFMT64x</name><literal type="string">": Cannot peek memory without specifying an address\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>a</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_esil_mem_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ut64</name></type> <name>c</name> <init>= <expr><call><name>r_read_ble64</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>bitmask</name> <init>= <expr><call><name>genmask</name> <argument_list>(<argument><expr><name>bits</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>a</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>!</operator><operator>!</operator><call><name>r_anal_esil_mem_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>b</name> <init>= <expr><call><name>r_read_ble64</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_mem_swapendian</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>b</name> <operator>&amp;</operator> <name>bitmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek3</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek16</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_peek_some</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>ptr</name></decl>, <decl><type ref="prev"/><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>count</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>regs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut32</name></type> <name>num32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut8</name></type> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>foo</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"Cannot pop in peek"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>read</name> <init>= <expr><call><name>r_anal_esil_mem_read</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>read</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>num32</name> <operator>=</operator> <call><name>r_read_ble32</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_reg_write</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>foo</name></expr></argument>, <argument><expr><name>num32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot peek from 0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>foo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>d</name> <operator>|=</operator> <name>s</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> 
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_oreq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_oreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_oreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_oreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_oreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_oreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_oreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>^=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_xoreq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_xoreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_xoreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_xoreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_xoreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_xoreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_xoreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&amp;=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_andeq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_andeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_andeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_andeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_andeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_andeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_andeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_addeq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_addeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_addeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_addeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_addeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_addeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_addeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>-=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_subeq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_subeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_subeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_subeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_subeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_subeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_subeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_modeq4: Division by zero!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>s</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name> <operator>%</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>d</name> <operator>%</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_modeq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_modeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_modeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_modeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_modeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_modeq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_modeq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_diveq8: Division by zero!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <name>R_ANAL_TRAP_DIVBYZERO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <name>d</name> <operator>/</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_diveq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_diveq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_diveq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_diveq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_diveq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_diveq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_diveq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>bitmask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>*=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_muleq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_muleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>UT8_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_muleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>UT16_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_muleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>UT32_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_muleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_muleq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">64</literal></expr>:</case> <return>return <expr><call><name>esil_mem_muleq8</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">32</literal></expr>:</case> <return>return <expr><call><name>esil_mem_muleq4</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><call><name>esil_mem_muleq2</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><call><name>esil_mem_muleq1</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>off</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_inceq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_inceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_inceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_inceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_inceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_inceq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_inceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>off</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>off</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_deceq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_deceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_deceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_deceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_deceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_deceq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_deceq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_lsleq_n: shift is too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_lsleq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsleq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsleq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq_n</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src0</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src0</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_peek_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>src1</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&gt;&gt;=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>&amp;=</operator> <operator>(</operator><operator>!</operator><operator>!</operator><call><name>esil_poke_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_mem_lsreq_n: invalid parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq1</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq2</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq4</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq8</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_mem_lsreq</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>esil_mem_lsreq_n</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_num</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dup_me</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>dup</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>dup_me</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dup_me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dup</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dup_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dup_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_dup</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>stack</name></name> <operator>||</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>esil</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_swap</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>stack</name></name> <operator>||</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>signed_compare_gt</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>st8</name><operator>)</operator> <name>a</name> <operator>&gt;</operator> <operator>(</operator><name>st8</name><operator>)</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>st16</name><operator>)</operator> <name>a</name> <operator>&gt;</operator> <operator>(</operator><name>st16</name><operator>)</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>st32</name><operator>)</operator> <name>a</name> <operator>&gt;</operator> <operator>(</operator><name>st32</name><operator>)</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">64</literal></expr>:</case>
<default>default:</default> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>st64</name><operator>)</operator> <name>a</name> <operator>&gt;</operator> <operator>(</operator><name>st64</name><operator>)</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_smaller</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>-</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name>num</name> <operator>!=</operator> <name>num2</name><operator>)</operator> <operator>&amp;</operator>
<operator>!</operator><call><name>signed_compare_gt</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_bigger</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>-</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><call><name>signed_compare_gt</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_smaller_equal</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>-</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>!</operator><call><name>signed_compare_gt</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_bigger_equal</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content> 
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <name>num</name> <operator>-</operator> <name>num2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <call><name>esil_internal_sizeof_reg</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><operator>(</operator><name>num</name> <operator>==</operator> <name>num2</name><operator>)</operator> <operator>|</operator>
<call><name>signed_compare_gt</name> <argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>lastsz</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_set_jump_target</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>jump_target</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>jump_target_set</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_set_jump_target: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_set_jump_target_set</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>jump_target_set</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_set_jump_target_set: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_set_delay_slot</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ut64</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>delay</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"esil_set_delay_slot: empty stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>iscommand</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>RAnalEsilOp</name> <modifier>*</modifier><modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>t</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>sdb_itoa</name> <argument_list>(<argument><expr><call><name>sdb_hash</name> <argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdb_num_exists</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>op</name> <operator>=</operator> <operator>(</operator><name>RAnalEsilOp</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>runword</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>RAnalEsilOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto_count</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto_count</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"ESIL infinite loop detected\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="string">"?{"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>Reil</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <ternary><condition><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>skip</name></name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>cmd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>if_buf</name> <init>= <expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>if_buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>if_buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>if_buf</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>if_buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>cmd_count</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>if_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>iscommand</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>Reil</name><operator>-&gt;</operator><name>cmd_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="string">"}{"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="string">"?{"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>iscommand</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_command</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>hook_command</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>current_opstr</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>ret</name> <init>= <expr><call><name><name>op</name><operator>-&gt;</operator><name>code</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>current_opstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>current_opstr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s returned 0\n"</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>word</name> <operator>||</operator> <operator>*</operator><name>word</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_push</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"ESIL stack is full"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gotoWord</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ostr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ostr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ostr</name> <operator>=</operator> <name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>evalWord</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ostr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>str</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>str</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <call><name>gotoWord</name> <argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find word %d\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[esil at 0x%08"</literal><name>PFMT64x</name><literal type="string">"] TODO: %s\n"</literal></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><operator>*</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__stepOut</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>inCmdStep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <name>esil</name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inCmdStep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inCmdStep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inCmdStep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>inCmdStep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_parse</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>wordi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dorunword</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>word</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ostr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>esil</name> <operator>&amp;&amp;</operator> <call><name>R_STR_ISNOTEMPTY</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashbang</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"#!"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>cmd_todo</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"TODO"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>cmd</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_todo</name></name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>loop</name>:</label>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_stop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto_count</name></name> <operator>=</operator> <ternary><condition><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name></expr>?</condition><then> <expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil_goto_limit</name></name></expr></then><else>: <expr><name>R_ANAL_ESIL_GOTO_LIMIT</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>ostr</name></expr>;</expr_stmt>
<label><name>repeat</name>:</label>
<expr_stmt><expr><name>wordi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>hashbang</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>&amp;&amp;</operator> <name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>setab</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>cmd</name></name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>str</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wordi</name> <operator>&gt;</operator> <literal type="number">62</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name> <argument_list>(<argument><expr><literal type="string">"Invalid esil string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dorunword</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordi</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dorunword</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordi</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dorunword</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dorunword</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>runword</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordi</name></expr>]</index></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wordi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>evalWord</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>ostr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <goto>goto <name>loop</name>;</goto>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <continue>continue;</continue>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>dorunword</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>str</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordi</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>runword</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>evalWord</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>ostr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <goto>goto <name>loop</name>;</goto>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <goto>goto <name>repeat</name>;</goto>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>__stepOut</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>esil</name><operator>-&gt;</operator><name>cmd_step_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_runword</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>runword</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>runword</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ew</name> <init>= <expr><call><name>evalWord</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ew %d\n"</literal></expr></argument>, <argument><expr><name>ew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"--&gt; %s\n"</literal></expr></argument>, <argument><expr><call><name>r_str_get</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_esil_stack_free</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>stack</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_esil_condition</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>popped</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt> 
</block_content>}</block></while>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>popped</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>popped</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ut64</name></type> <name>num</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isregornum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>popped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>!</operator><operator>!</operator><name>num</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Cannot pop because The ESIL stack is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_anal_esil_setup_ops</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>w</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_anal_esil_set_op (esil, v, w, x, y, z)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_UNK</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_UNKNOWN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_CTR</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_CONTROL_FLOW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_MATH</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_MATH</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_REGW</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_REG_WRITE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_MEMW</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_MEM_WRITE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OT_MEMR</name></cpp:macro> <cpp:value>R_ANAL_ESIL_OP_TYPE_MEM_READ</cpp:value></cpp:define>

<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$"</literal></expr></argument>, <argument><expr><name>esil_interrupt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$z"</literal></expr></argument>, <argument><expr><name>esil_zf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$c"</literal></expr></argument>, <argument><expr><name>esil_cf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$b"</literal></expr></argument>, <argument><expr><name>esil_bf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$p"</literal></expr></argument>, <argument><expr><name>esil_pf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$s"</literal></expr></argument>, <argument><expr><name>esil_sf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$o"</literal></expr></argument>, <argument><expr><name>esil_of</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$ds"</literal></expr></argument>, <argument><expr><name>esil_ds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$jt"</literal></expr></argument>, <argument><expr><name>esil_jt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$js"</literal></expr></argument>, <argument><expr><name>esil_js</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$r"</literal></expr></argument>, <argument><expr><name>esil_rs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"$$"</literal></expr></argument>, <argument><expr><name>esil_address</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>esil_cmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;"</literal></expr></argument>, <argument><expr><name>esil_smaller</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><name>esil_bigger</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;="</literal></expr></argument>, <argument><expr><name>esil_smaller_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;="</literal></expr></argument>, <argument><expr><name>esil_bigger_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"?{"</literal></expr></argument>, <argument><expr><name>esil_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>esil_lsl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;="</literal></expr></argument>, <argument><expr><name>esil_lsleq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>, <argument><expr><name>esil_lsr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;="</literal></expr></argument>, <argument><expr><name>esil_lsreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt;&gt;"</literal></expr></argument>, <argument><expr><name>esil_asr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt;&gt;="</literal></expr></argument>, <argument><expr><name>esil_asreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;&gt;"</literal></expr></argument>, <argument><expr><name>esil_ror</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;&lt;"</literal></expr></argument>, <argument><expr><name>esil_rol</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;"</literal></expr></argument>, <argument><expr><name>esil_and</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;="</literal></expr></argument>, <argument><expr><name>esil_andeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"}"</literal></expr></argument>, <argument><expr><name>esil_nop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"}{"</literal></expr></argument>, <argument><expr><name>esil_nop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|"</literal></expr></argument>, <argument><expr><name>esil_or</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|="</literal></expr></argument>, <argument><expr><name>esil_oreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"!"</literal></expr></argument>, <argument><expr><name>esil_neg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"!="</literal></expr></argument>, <argument><expr><name>esil_negeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>esil_eq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">":="</literal></expr></argument>, <argument><expr><name>esil_weak_eq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>esil_mul</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*="</literal></expr></argument>, <argument><expr><name>esil_muleq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>esil_xor</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^="</literal></expr></argument>, <argument><expr><name>esil_xoreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>esil_add</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+="</literal></expr></argument>, <argument><expr><name>esil_addeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++"</literal></expr></argument>, <argument><expr><name>esil_inc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++="</literal></expr></argument>, <argument><expr><name>esil_inceq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>esil_sub</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-="</literal></expr></argument>, <argument><expr><name>esil_subeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><name>esil_dec</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--="</literal></expr></argument>, <argument><expr><name>esil_deceq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>esil_div</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/="</literal></expr></argument>, <argument><expr><name>esil_diveq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><name>esil_mod</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%="</literal></expr></argument>, <argument><expr><name>esil_modeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_REGW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[]"</literal></expr></argument>, <argument><expr><name>esil_poke</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[1]"</literal></expr></argument>, <argument><expr><name>esil_poke1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[2]"</literal></expr></argument>, <argument><expr><name>esil_poke2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[3]"</literal></expr></argument>, <argument><expr><name>esil_poke3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[4]"</literal></expr></argument>, <argument><expr><name>esil_poke4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[8]"</literal></expr></argument>, <argument><expr><name>esil_poke8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[16]"</literal></expr></argument>, <argument><expr><name>esil_poke16</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_oreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_oreq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_oreq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_oreq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"|=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_oreq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_xoreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_xoreq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_xoreq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_xoreq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"^=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_xoreq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_andeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_andeq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_andeq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_andeq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&amp;=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_andeq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_addeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_addeq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_addeq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_addeq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"+=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_addeq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_subeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_subeq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_subeq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_subeq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"-=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_subeq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_modeq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_modeq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_modeq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_modeq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"%=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_modeq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_diveq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_diveq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_diveq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_diveq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"/=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_diveq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_muleq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_muleq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_muleq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_muleq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"*=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_muleq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_inceq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_inceq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_inceq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_inceq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"++=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_inceq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_deceq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_deceq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_deceq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_deceq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"--=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_deceq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsleq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsleq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsleq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsleq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&lt;&lt;=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsleq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;=[]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsreq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;=[1]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsreq1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;=[2]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsreq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;=[4]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsreq4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"&gt;&gt;=[8]"</literal></expr></argument>, <argument><expr><name>esil_mem_lsreq8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_MATH</name> <operator>|</operator> <name>OT_MEMR</name> <operator>|</operator> <name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>esil_peek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[*]"</literal></expr></argument>, <argument><expr><name>esil_peek_some</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"=[*]"</literal></expr></argument>, <argument><expr><name>esil_poke_some</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_MEMW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[1]"</literal></expr></argument>, <argument><expr><name>esil_peek1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[2]"</literal></expr></argument>, <argument><expr><name>esil_peek2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[3]"</literal></expr></argument>, <argument><expr><name>esil_peek3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[4]"</literal></expr></argument>, <argument><expr><name>esil_peek4</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[8]"</literal></expr></argument>, <argument><expr><name>esil_peek8</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"[16]"</literal></expr></argument>, <argument><expr><name>esil_peek16</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_MEMR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"STACK"</literal></expr></argument>, <argument><expr><name>r_anal_esil_dumpstack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"REPEAT"</literal></expr></argument>, <argument><expr><name>esil_repeat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"POP"</literal></expr></argument>, <argument><expr><name>esil_pop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"TODO"</literal></expr></argument>, <argument><expr><name>esil_todo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"GOTO"</literal></expr></argument>, <argument><expr><name>esil_goto</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"BREAK"</literal></expr></argument>, <argument><expr><name>esil_break</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_CTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"CLEAR"</literal></expr></argument>, <argument><expr><name>esil_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"DUP"</literal></expr></argument>, <argument><expr><name>esil_dup</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"NUM"</literal></expr></argument>, <argument><expr><name>esil_num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"SWAP"</literal></expr></argument>, <argument><expr><name>esil_swap</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"TRAP"</literal></expr></argument>, <argument><expr><name>esil_trap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"BITS"</literal></expr></argument>, <argument><expr><name>esil_bits</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"SETJT"</literal></expr></argument>, <argument><expr><name>esil_set_jump_target</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"SETJTS"</literal></expr></argument>, <argument><expr><name>esil_set_jump_target_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP</name> <argument_list>(<argument><expr><literal type="string">"SETD"</literal></expr></argument>, <argument><expr><name>esil_set_delay_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>OT_UNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_esil_setup</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>, <parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>romem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nonull</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name></name> <operator>=</operator> <name>anal</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>parse_goto_count</name></name> <operator>=</operator> <name><name>anal</name><operator>-&gt;</operator><name>esil_goto_limit</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>trap_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_read</name></name> <operator>=</operator> <name>internal_esil_reg_read</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_read</name></name> <operator>=</operator> <name>internal_esil_mem_read</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nonull</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_write</name></name> <operator>=</operator> <name>internal_esil_reg_write_no_null</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_read</name></name> <operator>=</operator> <name>internal_esil_mem_read_no_null</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_write</name></name> <operator>=</operator> <name>internal_esil_mem_write_no_null</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>reg_write</name></name> <operator>=</operator> <name>internal_esil_reg_write</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_read</name></name> <operator>=</operator> <name>internal_esil_mem_read</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>mem_write</name></name> <operator>=</operator> <name>internal_esil_mem_write</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>r_anal_esil_mem_ro</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>romem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_stats</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>r_anal_esil_setup_ops</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_init</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_fini</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>esil_init</name></name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
