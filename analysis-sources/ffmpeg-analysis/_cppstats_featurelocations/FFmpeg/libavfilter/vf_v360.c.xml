<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavfilter\vf_v360.c">


































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/imgutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avfilter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"formats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"video.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"v360.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>ThreadData</name> <block>{
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
}</block></struct></type> <name>ThreadData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(V360Context, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS</name></cpp:macro> <cpp:value>AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TFLAGS</name></cpp:macro> <cpp:value>AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_RUNTIME_PARAM</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>v360_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"input"</literal></expr>, <expr><literal type="string">"set input projection"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIRECTANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_PROJECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"e"</literal></expr>, <expr><literal type="string">"equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIRECTANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"equirect"</literal></expr>, <expr><literal type="string">"equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIRECTANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c3x2"</literal></expr>, <expr><literal type="string">"cubemap 3x2"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_3_2</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c6x1"</literal></expr>, <expr><literal type="string">"cubemap 6x1"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_6_1</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"eac"</literal></expr>, <expr><literal type="string">"equi-angular cubemap"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"dfisheye"</literal></expr>, <expr><literal type="string">"dual fisheye"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>DUAL_FISHEYE</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"flat"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"rectilinear"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gnomonic"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"barrel"</literal></expr>, <expr><literal type="string">"barrel facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"fb"</literal></expr>, <expr><literal type="string">"barrel facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c1x6"</literal></expr>, <expr><literal type="string">"cubemap 1x6"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_1_6</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sg"</literal></expr>, <expr><literal type="string">"stereographic"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREOGRAPHIC</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"mercator"</literal></expr>, <expr><literal type="string">"mercator"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MERCATOR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"ball"</literal></expr>, <expr><literal type="string">"ball"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BALL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"hammer"</literal></expr>, <expr><literal type="string">"hammer"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HAMMER</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"sinusoidal"</literal></expr>, <expr><literal type="string">"sinusoidal"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>SINUSOIDAL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"fisheye"</literal></expr>, <expr><literal type="string">"fisheye"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FISHEYE</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"cylindrical"</literal></expr>, <expr><literal type="string">"cylindrical"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CYLINDRICAL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"tetrahedron"</literal></expr>, <expr><literal type="string">"tetrahedron"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>TETRAHEDRON</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"barrelsplit"</literal></expr>, <expr><literal type="string">"barrel split facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL_SPLIT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"tsp"</literal></expr>, <expr><literal type="string">"truncated square pyramid"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>TSPYRAMID</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"hequirect"</literal></expr>, <expr><literal type="string">"half equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HEQUIRECTANGULAR</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"he"</literal></expr>, <expr><literal type="string">"half equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HEQUIRECTANGULAR</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"output"</literal></expr>, <expr><literal type="string">"set output projection"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_3_2</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_PROJECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"e"</literal></expr>, <expr><literal type="string">"equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIRECTANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"equirect"</literal></expr>, <expr><literal type="string">"equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIRECTANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c3x2"</literal></expr>, <expr><literal type="string">"cubemap 3x2"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_3_2</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c6x1"</literal></expr>, <expr><literal type="string">"cubemap 6x1"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_6_1</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"eac"</literal></expr>, <expr><literal type="string">"equi-angular cubemap"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>EQUIANGULAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"dfisheye"</literal></expr>, <expr><literal type="string">"dual fisheye"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>DUAL_FISHEYE</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"flat"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"rectilinear"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gnomonic"</literal></expr>, <expr><literal type="string">"regular video"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FLAT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"barrel"</literal></expr>, <expr><literal type="string">"barrel facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"fb"</literal></expr>, <expr><literal type="string">"barrel facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"c1x6"</literal></expr>, <expr><literal type="string">"cubemap 1x6"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CUBEMAP_1_6</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sg"</literal></expr>, <expr><literal type="string">"stereographic"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREOGRAPHIC</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"mercator"</literal></expr>, <expr><literal type="string">"mercator"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MERCATOR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"ball"</literal></expr>, <expr><literal type="string">"ball"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BALL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"hammer"</literal></expr>, <expr><literal type="string">"hammer"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HAMMER</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"sinusoidal"</literal></expr>, <expr><literal type="string">"sinusoidal"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>SINUSOIDAL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"fisheye"</literal></expr>, <expr><literal type="string">"fisheye"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FISHEYE</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pannini"</literal></expr>, <expr><literal type="string">"pannini"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>PANNINI</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"cylindrical"</literal></expr>, <expr><literal type="string">"cylindrical"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>CYLINDRICAL</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"perspective"</literal></expr>, <expr><literal type="string">"perspective"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>PERSPECTIVE</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"tetrahedron"</literal></expr>, <expr><literal type="string">"tetrahedron"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>TETRAHEDRON</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"barrelsplit"</literal></expr>, <expr><literal type="string">"barrel split facebook's 360 format"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BARREL_SPLIT</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"tsp"</literal></expr>, <expr><literal type="string">"truncated square pyramid"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>TSPYRAMID</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"hequirect"</literal></expr>, <expr><literal type="string">"half equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HEQUIRECTANGULAR</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"he"</literal></expr>, <expr><literal type="string">"half equirectangular"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>HEQUIRECTANGULAR</name></expr>}</block></expr>,<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"interp"</literal></expr>, <expr><literal type="string">"set interpolation method"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BILINEAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_INTERP_METHODS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"near"</literal></expr>, <expr><literal type="string">"nearest neighbour"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>NEAREST</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"nearest"</literal></expr>, <expr><literal type="string">"nearest neighbour"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>NEAREST</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"line"</literal></expr>, <expr><literal type="string">"bilinear interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BILINEAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"linear"</literal></expr>, <expr><literal type="string">"bilinear interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BILINEAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"lagrange9"</literal></expr>, <expr><literal type="string">"lagrange9 interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>LAGRANGE9</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"cube"</literal></expr>, <expr><literal type="string">"bicubic interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BICUBIC</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"cubic"</literal></expr>, <expr><literal type="string">"bicubic interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>BICUBIC</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"lanc"</literal></expr>, <expr><literal type="string">"lanczos interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>LANCZOS</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"lanczos"</literal></expr>, <expr><literal type="string">"lanczos interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>LANCZOS</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sp16"</literal></expr>, <expr><literal type="string">"spline16 interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>SPLINE16</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"spline16"</literal></expr>, <expr><literal type="string">"spline16 interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>SPLINE16</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gauss"</literal></expr>, <expr><literal type="string">"gaussian interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>GAUSSIAN</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gaussian"</literal></expr>, <expr><literal type="string">"gaussian interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>GAUSSIAN</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"w"</literal></expr>, <expr><literal type="string">"output width"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT16_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"w"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"h"</literal></expr>, <expr><literal type="string">"output height"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT16_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"h"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"in_stereo"</literal></expr>, <expr><literal type="string">"input stereo format"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in_stereo</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREO_2D</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_STEREO_FMTS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"stereo"</literal></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"out_stereo"</literal></expr>, <expr><literal type="string">"output stereo format"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out_stereo</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREO_2D</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_STEREO_FMTS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"stereo"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"2d"</literal></expr>, <expr><literal type="string">"2d mono"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREO_2D</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"stereo"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sbs"</literal></expr>, <expr><literal type="string">"side by side"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREO_SBS</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"stereo"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"tb"</literal></expr>, <expr><literal type="string">"top bottom"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>STEREO_TB</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"stereo"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"in_forder"</literal></expr>, <expr><literal type="string">"input cubemap face order"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in_forder</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><literal type="string">"rludfb"</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_DIRECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in_forder"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"out_forder"</literal></expr>, <expr><literal type="string">"output cubemap face order"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out_forder</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><literal type="string">"rludfb"</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_DIRECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out_forder"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"in_frot"</literal></expr>, <expr><literal type="string">"input cubemap face rotation"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in_frot</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><literal type="string">"000000"</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_DIRECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in_frot"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"out_frot"</literal></expr>, <expr><literal type="string">"output cubemap face rotation"</literal></expr>,<expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out_frot</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><literal type="string">"000000"</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_DIRECTIONS</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out_frot"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"in_pad"</literal></expr>, <expr><literal type="string">"percent input cubemap pads"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in_pad</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><literal type="number">0.f</literal></expr>, <expr><literal type="number">1.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"in_pad"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"out_pad"</literal></expr>, <expr><literal type="string">"percent output cubemap pads"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out_pad</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><literal type="number">0.f</literal></expr>, <expr><literal type="number">1.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"out_pad"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"fin_pad"</literal></expr>, <expr><literal type="string">"fixed input cubemap pads"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>fin_pad</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"fin_pad"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"fout_pad"</literal></expr>, <expr><literal type="string">"fixed output cubemap pads"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>fout_pad</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"fout_pad"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"yaw"</literal></expr>, <expr><literal type="string">"yaw rotation"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>yaw</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">180.f</literal></expr>, <expr><literal type="number">180.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"yaw"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"pitch"</literal></expr>, <expr><literal type="string">"pitch rotation"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>pitch</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">180.f</literal></expr>, <expr><literal type="number">180.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"pitch"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"roll"</literal></expr>, <expr><literal type="string">"roll rotation"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>roll</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">180.f</literal></expr>, <expr><literal type="number">180.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"roll"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"rorder"</literal></expr>, <expr><literal type="string">"rotation order"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>rorder</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><literal type="string">"ypr"</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"rorder"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"h_fov"</literal></expr>, <expr><literal type="string">"output horizontal field of view"</literal></expr>,<expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>h_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">90.f</literal></expr>}</block></expr>, <expr><literal type="number">0.00001f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"h_fov"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"v_fov"</literal></expr>, <expr><literal type="string">"output vertical field of view"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>v_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">45.f</literal></expr>}</block></expr>, <expr><literal type="number">0.00001f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"v_fov"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"d_fov"</literal></expr>, <expr><literal type="string">"output diagonal field of view"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>d_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><literal type="number">0.f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"d_fov"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"h_flip"</literal></expr>, <expr><literal type="string">"flip out video horizontally"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>h_flip</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"h_flip"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"v_flip"</literal></expr>, <expr><literal type="string">"flip out video vertically"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>v_flip</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"v_flip"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"d_flip"</literal></expr>, <expr><literal type="string">"flip out video indepth"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>d_flip</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"d_flip"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"ih_flip"</literal></expr>, <expr><literal type="string">"flip in video horizontally"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>ih_flip</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"ih_flip"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"iv_flip"</literal></expr>, <expr><literal type="string">"flip in video vertically"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>iv_flip</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"iv_flip"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"in_trans"</literal></expr>, <expr><literal type="string">"transpose video input"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>in_transpose</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"in_transpose"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"out_trans"</literal></expr>, <expr><literal type="string">"transpose video output"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>out_transpose</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"out_transpose"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"ih_fov"</literal></expr>, <expr><literal type="string">"input horizontal field of view"</literal></expr>,<expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>ih_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">90.f</literal></expr>}</block></expr>, <expr><literal type="number">0.00001f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"ih_fov"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"iv_fov"</literal></expr>, <expr><literal type="string">"input vertical field of view"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>iv_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">45.f</literal></expr>}</block></expr>, <expr><literal type="number">0.00001f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"iv_fov"</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"id_fov"</literal></expr>, <expr><literal type="string">"input diagonal field of view"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>id_fov</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_FLOAT</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">0.f</literal></expr>}</block></expr>, <expr><literal type="number">0.f</literal></expr>, <expr><literal type="number">360.f</literal></expr>,<expr><name>TFLAGS</name></expr>, <expr><literal type="string">"id_fov"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"alpha_mask"</literal></expr>, <expr><literal type="string">"build mask in alpha plane"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"alpha"</literal></expr>}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AVFILTER_DEFINE_CLASS</name><argument_list>(<argument><expr><name>v360</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>query_formats</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>pix_fmts</name><index>[]</index></name> <init>= <expr><block>{

<expr><name>AV_PIX_FMT_YUVA444P</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA444P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P12</name></expr>,
<expr><name>AV_PIX_FMT_YUVA444P16</name></expr>,


<expr><name>AV_PIX_FMT_YUVA422P</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P12</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P16</name></expr>,


<expr><name>AV_PIX_FMT_YUVA420P</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA420P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P16</name></expr>,


<expr><name>AV_PIX_FMT_YUVJ444P</name></expr>, <expr><name>AV_PIX_FMT_YUVJ440P</name></expr>,
<expr><name>AV_PIX_FMT_YUVJ422P</name></expr>, <expr><name>AV_PIX_FMT_YUVJ420P</name></expr>,
<expr><name>AV_PIX_FMT_YUVJ411P</name></expr>,


<expr><name>AV_PIX_FMT_YUV444P</name></expr>, <expr><name>AV_PIX_FMT_YUV444P9</name></expr>,
<expr><name>AV_PIX_FMT_YUV444P10</name></expr>, <expr><name>AV_PIX_FMT_YUV444P12</name></expr>,
<expr><name>AV_PIX_FMT_YUV444P14</name></expr>, <expr><name>AV_PIX_FMT_YUV444P16</name></expr>,


<expr><name>AV_PIX_FMT_YUV440P</name></expr>, <expr><name>AV_PIX_FMT_YUV440P10</name></expr>,
<expr><name>AV_PIX_FMT_YUV440P12</name></expr>,


<expr><name>AV_PIX_FMT_YUV422P</name></expr>, <expr><name>AV_PIX_FMT_YUV422P9</name></expr>,
<expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><name>AV_PIX_FMT_YUV422P12</name></expr>,
<expr><name>AV_PIX_FMT_YUV422P14</name></expr>, <expr><name>AV_PIX_FMT_YUV422P16</name></expr>,


<expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><name>AV_PIX_FMT_YUV420P9</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P10</name></expr>, <expr><name>AV_PIX_FMT_YUV420P12</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P14</name></expr>, <expr><name>AV_PIX_FMT_YUV420P16</name></expr>,


<expr><name>AV_PIX_FMT_YUV411P</name></expr>,


<expr><name>AV_PIX_FMT_YUV410P</name></expr>,


<expr><name>AV_PIX_FMT_GBRP</name></expr>, <expr><name>AV_PIX_FMT_GBRP9</name></expr>,
<expr><name>AV_PIX_FMT_GBRP10</name></expr>, <expr><name>AV_PIX_FMT_GBRP12</name></expr>,
<expr><name>AV_PIX_FMT_GBRP14</name></expr>, <expr><name>AV_PIX_FMT_GBRP16</name></expr>,


<expr><name>AV_PIX_FMT_GBRAP</name></expr>, <expr><name>AV_PIX_FMT_GBRAP10</name></expr>,
<expr><name>AV_PIX_FMT_GBRAP12</name></expr>, <expr><name>AV_PIX_FMT_GBRAP16</name></expr>,


<expr><name>AV_PIX_FMT_GRAY8</name></expr>, <expr><name>AV_PIX_FMT_GRAY9</name></expr>,
<expr><name>AV_PIX_FMT_GRAY10</name></expr>, <expr><name>AV_PIX_FMT_GRAY12</name></expr>,
<expr><name>AV_PIX_FMT_GRAY14</name></expr>, <expr><name>AV_PIX_FMT_GRAY16</name></expr>,

<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>alpha_pix_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>AV_PIX_FMT_YUVA444P</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA444P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA444P12</name></expr>,
<expr><name>AV_PIX_FMT_YUVA444P16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA422P12</name></expr>,
<expr><name>AV_PIX_FMT_YUVA422P16</name></expr>,
<expr><name>AV_PIX_FMT_YUVA420P</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P9</name></expr>,
<expr><name>AV_PIX_FMT_YUVA420P10</name></expr>, <expr><name>AV_PIX_FMT_YUVA420P16</name></expr>,
<expr><name>AV_PIX_FMT_GBRAP</name></expr>, <expr><name>AV_PIX_FMT_GBRAP10</name></expr>,
<expr><name>AV_PIX_FMT_GBRAP12</name></expr>, <expr><name>AV_PIX_FMT_GBRAP16</name></expr>,
<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilterFormats</name> <modifier>*</modifier></type><name>fmts_list</name> <init>= <expr><call><name>ff_make_format_list</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>alpha</name></name></expr> ?</condition><then> <expr><name>alpha_pix_fmts</name></expr> </then><else>: <expr><name>pix_fmts</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmts_list</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ff_set_common_formats</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fmts_list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_REMAP1_LINE</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>, <parameter><type><name>div</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void remap1_##bits##bit_line_c(uint8_t *dst, int width, const uint8_t *const src, ptrdiff_t in_linesize, const int16_t *const u, const int16_t *const v, const int16_t *const ker) { const uint##bits##_t *const s = (const uint##bits##_t *const)src; uint##bits##_t *d = (uint##bits##_t *)dst; in_linesize /= div; for (int x = 0; x &lt; width; x++) d[x] = s[v[x] * in_linesize + u[x]]; }</cpp:value></cpp:define>














<macro><name>DEFINE_REMAP1_LINE</name><argument_list>( <argument><literal type="number">8</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP1_LINE</name><argument_list>(<argument><literal type="number">16</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_REMAP</name><parameter_list>(<parameter><type><name>ws</name></type></parameter>, <parameter><type><name>bits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int remap##ws##_##bits##bit_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { ThreadData *td = arg; const V360Context *s = ctx-&gt;priv; const AVFrame *in = td-&gt;in; AVFrame *out = td-&gt;out; for (int stereo = 0; stereo &lt; 1 + s-&gt;out_stereo &gt; STEREO_2D; stereo++) { for (int plane = 0; plane &lt; s-&gt;nb_planes; plane++) { const unsigned map = s-&gt;map[plane]; const int in_linesize = in-&gt;linesize[plane]; const int out_linesize = out-&gt;linesize[plane]; const int uv_linesize = s-&gt;uv_linesize[plane]; const int in_offset_w = stereo ? s-&gt;in_offset_w[plane] : 0; const int in_offset_h = stereo ? s-&gt;in_offset_h[plane] : 0; const int out_offset_w = stereo ? s-&gt;out_offset_w[plane] : 0; const int out_offset_h = stereo ? s-&gt;out_offset_h[plane] : 0; const uint8_t *const src = in-&gt;data[plane] + in_offset_h * in_linesize + in_offset_w * (bits &gt;&gt; 3); uint8_t *dst = out-&gt;data[plane] + out_offset_h * out_linesize + out_offset_w * (bits &gt;&gt; 3); const uint8_t *mask = plane == 3 ? s-&gt;mask : NULL; const int width = s-&gt;pr_width[plane]; const int height = s-&gt;pr_height[plane]; const int slice_start = (height * jobnr ) / nb_jobs; const int slice_end = (height * (jobnr + 1)) / nb_jobs; for (int y = slice_start; y &lt; slice_end &amp;&amp; !mask; y++) { const int16_t *const u = s-&gt;u[map] + y * uv_linesize * ws * ws; const int16_t *const v = s-&gt;v[map] + y * uv_linesize * ws * ws; const int16_t *const ker = s-&gt;ker[map] + y * uv_linesize * ws * ws; s-&gt;remap_line(dst + y * out_linesize, width, src, in_linesize, u, v, ker); } for (int y = slice_start; y &lt; slice_end &amp;&amp; mask; y++) { memcpy(dst + y * out_linesize, mask + y * width * (bits &gt;&gt; 3), width * (bits &gt;&gt; 3)); } } } return 0; }</cpp:value></cpp:define>












































<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_REMAP_LINE</name><parameter_list>(<parameter><type><name>ws</name></type></parameter>, <parameter><type><name>bits</name></type></parameter>, <parameter><type><name>div</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static void remap##ws##_##bits##bit_line_c(uint8_t *dst, int width, const uint8_t *const src, ptrdiff_t in_linesize, const int16_t *const u, const int16_t *const v, const int16_t *const ker) { const uint##bits##_t *const s = (const uint##bits##_t *const)src; uint##bits##_t *d = (uint##bits##_t *)dst; in_linesize /= div; for (int x = 0; x &lt; width; x++) { const int16_t *const uu = u + x * ws * ws; const int16_t *const vv = v + x * ws * ws; const int16_t *const kker = ker + x * ws * ws; int tmp = 0; for (int i = 0; i &lt; ws; i++) { for (int j = 0; j &lt; ws; j++) { tmp += kker[i * ws + j] * s[vv[i * ws + j] * in_linesize + uu[i * ws + j]]; } } d[x] = av_clip_uint##bits(tmp &gt;&gt; 14); } }</cpp:value></cpp:define>


























<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">3</literal></argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_REMAP_LINE</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>

<function><type><name>void</name></type> <name>ff_v360_init</name><parameter_list>(<parameter><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interp</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NEAREST</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_line</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap1_8bit_line_c</name></expr> </then><else>: <expr><name>remap1_16bit_line_c</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BILINEAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_line</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap2_8bit_line_c</name></expr> </then><else>: <expr><name>remap2_16bit_line_c</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LAGRANGE9</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_line</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap3_8bit_line_c</name></expr> </then><else>: <expr><name>remap3_16bit_line_c</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BICUBIC</name></expr>:</case>
<case>case <expr><name>LANCZOS</name></expr>:</case>
<case>case <expr><name>SPLINE16</name></expr>:</case>
<case>case <expr><name>GAUSSIAN</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_line</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap4_8bit_line_c</name></expr> </then><else>: <expr><name>remap4_16bit_line_c</name></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ARCH_X86</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_v360_init_x86</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>nearest_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name> <init>= <expr><call><name>lrintf</name><argument_list>(<argument><expr><name>dv</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><call><name>lrintf</name><argument_list>(<argument><expr><name>du</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>u</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bilinear_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>ker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>du</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>dv</name><operator>)</operator> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>( <argument><expr><name>du</name> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>dv</name><operator>)</operator> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>du</name><operator>)</operator> <operator>*</operator> <name>dv</name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>( <argument><expr><name>du</name> <operator>*</operator> <name>dv</name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>calculate_lagrange_coeffs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>coeffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">2.f</literal><operator>)</operator> <operator>*</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>t</name> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">2.f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>lagrange_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>du_coeffs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>dv_coeffs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>calculate_lagrange_coeffs</name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>du_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calculate_lagrange_coeffs</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>dv_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name><name>du_coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>dv_coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>calculate_bicubic_coeffs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>coeffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>tt</name> <init>= <expr><name>t</name> <operator>*</operator> <name>t</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ttt</name> <init>= <expr><name>t</name> <operator>*</operator> <name>t</name> <operator>*</operator> <name>t</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator> <name>t</name> <operator>/</operator> <literal type="number">3.f</literal> <operator>+</operator> <name>tt</name> <operator>/</operator> <literal type="number">2.f</literal> <operator>-</operator> <name>ttt</name> <operator>/</operator> <literal type="number">6.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <name>t</name> <operator>/</operator> <literal type="number">2.f</literal> <operator>-</operator> <name>tt</name> <operator>+</operator> <name>ttt</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>+</operator> <name>tt</name> <operator>/</operator> <literal type="number">2.f</literal> <operator>-</operator> <name>ttt</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator> <name>t</name> <operator>/</operator> <literal type="number">6.f</literal> <operator>+</operator> <name>ttt</name> <operator>/</operator> <literal type="number">6.f</literal></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bicubic_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>du_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>dv_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>calculate_bicubic_coeffs</name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>du_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calculate_bicubic_coeffs</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>dv_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name><name>du_coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>dv_coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>calculate_lanczos_coeffs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>coeffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><name>M_PI</name> <operator>*</operator> <operator>(</operator><name>t</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sinf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>sinf</name><argument_list>(<argument><expr><name>x</name> <operator>/</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>x</name> <operator>*</operator> <name>x</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/=</operator> <name>sum</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>lanczos_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>du_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>dv_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>calculate_lanczos_coeffs</name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>du_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calculate_lanczos_coeffs</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>dv_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name><name>du_coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>dv_coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>calculate_spline16_coeffs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>coeffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>-</operator><literal type="number">1.f</literal> <operator>/</operator> <literal type="number">3.f</literal> <operator>*</operator> <name>t</name> <operator>+</operator> <literal type="number">0.8f</literal><operator>)</operator> <operator>*</operator> <name>t</name> <operator>-</operator> <literal type="number">7.f</literal> <operator>/</operator> <literal type="number">15.f</literal><operator>)</operator> <operator>*</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>t</name> <operator>-</operator> <literal type="number">9.f</literal> <operator>/</operator> <literal type="number">5.f</literal><operator>)</operator> <operator>*</operator> <name>t</name> <operator>-</operator> <literal type="number">0.2f</literal><operator>)</operator> <operator>*</operator> <name>t</name> <operator>+</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">6.f</literal> <operator>/</operator> <literal type="number">5.f</literal> <operator>-</operator> <name>t</name><operator>)</operator> <operator>*</operator> <name>t</name> <operator>+</operator> <literal type="number">0.8f</literal><operator>)</operator> <operator>*</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><literal type="number">1.f</literal> <operator>/</operator> <literal type="number">3.f</literal> <operator>*</operator> <name>t</name> <operator>-</operator> <literal type="number">0.2f</literal><operator>)</operator> <operator>*</operator> <name>t</name> <operator>-</operator> <literal type="number">2.f</literal> <operator>/</operator> <literal type="number">15.f</literal><operator>)</operator> <operator>*</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>spline16_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>du_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>dv_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>calculate_spline16_coeffs</name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>du_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calculate_spline16_coeffs</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>dv_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name><name>du_coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>dv_coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>calculate_gaussian_coeffs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>coeffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><name>t</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>expf</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2.f</literal> <operator>*</operator> <name>x</name> <operator>*</operator> <name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>expf</name><argument_list>(<argument><expr><operator>-</operator><name>x</name> <operator>*</operator> <name>x</name> <operator>/</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/=</operator> <name>sum</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>gaussian_kernel</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>du</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>dv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XYRemap</name> <modifier>*</modifier></type><name>rmap</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name><name>du_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>dv_coeffs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>calculate_gaussian_coeffs</name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>du_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>calculate_gaussian_coeffs</name><argument_list>(<argument><expr><name>dv</name></expr></argument>, <argument><expr><name>dv_coeffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>u</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rmap</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ker</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">4</literal> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name><name>du_coeffs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name><name>dv_coeffs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">16385.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>mod</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>res</name> <init>= <expr><name>a</name> <operator>%</operator> <name>b</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>res</name> <operator>+</operator> <name>b</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>reflecty</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><name>y</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>y</name> <operator>&gt;=</operator> <name>h</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>h</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>y</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>y</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>ereflectx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>&gt;=</operator> <name>h</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>+=</operator> <name>w</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>mod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>reflectx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>&gt;=</operator> <name>h</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>w</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>x</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>mod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>get_direction</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<return>return <expr><name>RIGHT</name></expr>;</return>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<return>return <expr><name>LEFT</name></expr>;</return>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<return>return <expr><name>UP</name></expr>;</return>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<return>return <expr><name>DOWN</name></expr>;</return>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<return>return <expr><name>FRONT</name></expr>;</return>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<return>return <expr><name>BACK</name></expr>;</return>
<default>default:</default>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type> <name>get_rotation</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<return>return <expr><name>ROT_0</name></expr>;</return>
<case>case <expr><literal type="char">'1'</literal></expr>:</case>
<return>return <expr><name>ROT_90</name></expr>;</return>
<case>case <expr><literal type="char">'2'</literal></expr>:</case>
<return>return <expr><name>ROT_180</name></expr>;</return>
<case>case <expr><literal type="char">'3'</literal></expr>:</case>
<return>return <expr><name>ROT_270</name></expr>;</return>
<default>default:</default>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>get_rorder</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
<case>case <expr><literal type="char">'y'</literal></expr>:</case>
<return>return <expr><name>YAW</name></expr>;</return>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<return>return <expr><name>PITCH</name></expr>;</return>
<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<return>return <expr><name>ROLL</name></expr>;</return>
<default>default:</default>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_cube_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>face</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>face</name> <operator>&lt;</operator> <name>NB_FACES</name></expr>;</condition> <incr><expr><name>face</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>in_forder</name><index>[<expr><name>face</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete in_forder option. Direction for all 6 faces should be specified.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>direction</name> <operator>=</operator> <call><name>get_direction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incorrect direction symbol '%c' in in_forder option.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name> <operator>=</operator> <name>face</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>face</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>face</name> <operator>&lt;</operator> <name>NB_FACES</name></expr>;</condition> <incr><expr><name>face</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>in_frot</name><index>[<expr><name>face</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rotation</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete in_frot option. Rotation for all 6 faces should be specified.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rotation</name> <operator>=</operator> <call><name>get_rotation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rotation</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incorrect rotation symbol '%c' in in_frot option.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>face</name></expr>]</index></name> <operator>=</operator> <name>rotation</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_cube_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>face</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>face</name> <operator>&lt;</operator> <name>NB_FACES</name></expr>;</condition> <incr><expr><name>face</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>out_forder</name><index>[<expr><name>face</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete out_forder option. Direction for all 6 faces should be specified.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>direction</name> <operator>=</operator> <call><name>get_direction</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incorrect direction symbol '%c' in out_forder option.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>face</name></expr>]</index></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><decl><type><name>int</name></type> <name>face</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>face</name> <operator>&lt;</operator> <name>NB_FACES</name></expr>;</condition> <incr><expr><name>face</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>out_frot</name><index>[<expr><name>face</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rotation</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete out_frot option. Rotation for all 6 faces should be specified.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rotation</name> <operator>=</operator> <call><name>get_rotation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rotation</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Incorrect rotation symbol '%c' in out_frot option.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>face</name></expr>]</index></name> <operator>=</operator> <name>rotation</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>rotate_cube_face</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>uf</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>rotation</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ROT_0</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ROT_90</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ROT_180</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ROT_270</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>*</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>rotate_cube_face_inverse</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>uf</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>tmp</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>rotation</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ROT_0</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ROT_90</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>*</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ROT_180</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ROT_270</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><operator>*</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>normalize_vector</name><parameter_list>(<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>norm</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/=</operator> <name>norm</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/=</operator> <name>norm</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/=</operator> <name>norm</name></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type> <name>cube_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>float</name></type> <name>uf</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>vf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>face</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>scalew</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>scaleh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>direction</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>face</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>l_x</name></decl>, <decl><type ref="prev"/><name>l_y</name></decl>, <decl><type ref="prev"/><name>l_z</name></decl>;</decl_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rotate_cube_face_inverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>face</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>l_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>l_z</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>xyz_to_cube</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>uf</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>phi_norm</name></decl>, <decl><type ref="prev"/><name>theta_threshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>face</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>phi</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_4</name> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&lt;</operator> <name>M_PI_4</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>phi_norm</name> <operator>=</operator> <name>phi</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>phi</name> <operator>&gt;=</operator> <operator>-</operator><operator>(</operator><name>M_PI_2</name> <operator>+</operator> <name>M_PI_4</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&lt;</operator> <operator>-</operator><name>M_PI_4</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>phi_norm</name> <operator>=</operator> <name>phi</name> <operator>+</operator> <name>M_PI_2</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>phi</name> <operator>&gt;=</operator> <name>M_PI_4</name> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&lt;</operator> <name>M_PI_2</name> <operator>+</operator> <name>M_PI_4</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>phi_norm</name> <operator>=</operator> <name>phi</name> <operator>-</operator> <name>M_PI_2</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>phi_norm</name> <operator>=</operator> <name>phi</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>phi</name> <operator>&gt;</operator> <literal type="number">0.f</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><name>M_PI</name></expr> </then><else>: <expr><name>M_PI</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>theta_threshold</name> <operator>=</operator> <call><name>atanf</name><argument_list>(<argument><expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi_norm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>theta</name> <operator>&gt;</operator> <name>theta_threshold</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>theta</name> <operator>&lt;</operator> <operator>-</operator><name>theta_threshold</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>direction</name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><operator>*</operator><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rotate_cube_face</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>face</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>uf</name><operator>)</operator> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>vf</name><operator>)</operator> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type> <name>process_cube_coordinates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>float</name></type> <name>uf</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>vf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>new_uf</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>new_vf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>face</name></decl></parameter>)</parameter_list>
<block>{<block_content>

















<expr_stmt><expr><operator>*</operator><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rotate_cube_face_inverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><operator>*</operator><name>face</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uf</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1.f</literal> <operator>||</operator> <name>uf</name> <operator>&gt;=</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>vf</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1.f</literal> <operator>||</operator> <name>vf</name> <operator>&gt;=</operator> <literal type="number">1.f</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>uf</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>+=</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>uf</name> <operator>&gt;=</operator> <literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>-=</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vf</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vf</name> <operator>+=</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vf</name> <operator>&gt;=</operator> <literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vf</name> <operator>-=</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>new_uf</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>new_vf</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rotate_cube_face</name><argument_list>(<argument><expr><name>new_uf</name></expr></argument>, <argument><expr><name>new_vf</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><operator>*</operator><name>face</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>cube3x2_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">3.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>u_face</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>i</name> <operator>/</operator> <name>ew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>v_face</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>j</name> <operator>/</operator> <name>eh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>face</name> <init>= <expr><name>u_face</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>v_face</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>u_shift</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>u_face</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>v_shift</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>v_face</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ewi</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>u_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>u_shift</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ehi</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>v_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>v_shift</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>u_shift</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>ewi</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>j</name> <operator>-</operator> <name>v_shift</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>ehi</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cube_to_xyz</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>face</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>scalew</name></expr></argument>, <argument><expr><name>scaleh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_cube3x2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">3.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ewi</name></decl>, <decl><type ref="prev"/><name>ehi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>, <decl><type ref="prev"/><name>face</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_face</name></decl>, <decl><type ref="prev"/><name>v_face</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xyz_to_cube</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>u_face</name> <operator>=</operator> <name>face</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_face</name> <operator>=</operator> <name>face</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ewi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>u_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>u_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ehi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>v_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>v_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_ui</name> <init>= <expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_vi</name> <init>= <expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_shift</name></decl>, <decl><type ref="prev"/><name>v_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_ewi</name></decl>, <decl><type ref="prev"/><name>new_ehi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_ui</name> <operator>&lt;</operator> <name>ewi</name> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&lt;</operator> <name>ehi</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>u_face</name> <operator>=</operator> <name>face</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_face</name> <operator>=</operator> <name>face</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>u_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>v_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_ui</name> <operator>/</operator> <name>ewi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_vi</name> <operator>/</operator> <name>ehi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>process_cube_coordinates</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>u_face</name> <operator>=</operator> <name>face</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_face</name> <operator>=</operator> <name>face</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>u_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>v_face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ewi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>u_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>u_shift</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ehi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>v_face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>v_shift</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_ui</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>new_ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_ewi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_vi</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>new_ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_ehi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u_shift</name> <operator>+</operator> <name>new_ui</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v_shift</name> <operator>+</operator> <name>new_vi</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>cube1x6_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name><operator>)</operator> <operator>/</operator> <name>width</name></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">6.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name> <operator>/</operator> <literal type="number">6.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>face</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>j</name> <operator>/</operator> <name>eh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>v_shift</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ehi</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>v_shift</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>ew</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>j</name> <operator>-</operator> <name>v_shift</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>ehi</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cube_to_xyz</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>face</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>scalew</name></expr></argument>, <argument><expr><name>scaleh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>cube6x1_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">6.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name><operator>)</operator> <operator>/</operator> <name>height</name></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">6.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>face</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>i</name> <operator>/</operator> <name>ew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>u_shift</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ewi</name> <init>= <expr><call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>u_shift</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>u_shift</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>ewi</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>eh</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cube_to_xyz</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>face</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>scalew</name></expr></argument>, <argument><expr><name>scaleh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_cube1x6</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name><operator>)</operator> <operator>/</operator> <name>width</name></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">6.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name> <operator>/</operator> <literal type="number">6.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ewi</name> <init>= <expr><name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ehi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>, <decl><type ref="prev"/><name>face</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xyz_to_cube</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ehi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_ui</name> <init>= <expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_vi</name> <init>= <expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>v_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_ehi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_ui</name> <operator>&lt;</operator> <name>ewi</name> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&lt;</operator> <name>ehi</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_ui</name> <operator>/</operator> <name>ewi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_vi</name> <operator>/</operator> <name>ehi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>process_cube_coordinates</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ehi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>eh</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>v_shift</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_ui</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ewi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_vi</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>new_ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_ehi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>new_ui</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v_shift</name> <operator>+</operator> <name>new_vi</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_cube6x1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">6.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name><operator>)</operator> <operator>/</operator> <name>height</name></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">6.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ehi</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ewi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>, <decl><type ref="prev"/><name>face</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xyz_to_cube</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ewi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_ui</name> <init>= <expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_vi</name> <init>= <expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_ewi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_ui</name> <operator>&lt;</operator> <name>ewi</name> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>new_vi</name> <operator>&lt;</operator> <name>ehi</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_ui</name> <operator>/</operator> <name>ewi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>new_vi</name> <operator>/</operator> <name>ehi</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>process_cube_coordinates</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>scaleh</name></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ewi</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name> <operator>*</operator> <operator>(</operator><name>face</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>-</operator> <name>u_shift</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_ui</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>new_ewi</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_ewi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_vi</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><call><name>lrintf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name>ehi</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ehi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u_shift</name> <operator>+</operator> <name>new_ui</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>new_vi</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>equirect_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>hequirect_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_stereographic_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name></expr></argument>, <argument><expr><literal type="number">359.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">720.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name></expr></argument>, <argument><expr><literal type="number">359.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">720.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>stereographic_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>r</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>atanf</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x</name> <operator>/</operator> <name>r</name> <operator>*</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>y</name> <operator>/</operator> <name>r</name> <operator>*</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_stereographic_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>ih_fov</name></name></expr></argument>, <argument><expr><literal type="number">359.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">720.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name></expr></argument>, <argument><expr><literal type="number">359.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">720.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_stereographic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>acosf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>r</name> <init>= <expr><call><name>tanf</name><argument_list>(<argument><expr><name>theta</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>c</name> <init>= <expr><name>r</name> <operator>/</operator> <call><name>hypotf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>c</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>c</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>x</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>y</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>visible</name> <init>= <expr><call><name>isfinite</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isfinite</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vi</name> <operator>&lt;</operator> <name>height</name> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&lt;</operator> <name>width</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><name>uf</name> <operator>-</operator> <name>ui</name></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><name>vf</name> <operator>-</operator> <name>vi</name></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_equirect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>phi</name> <operator>/</operator> <name>M_PI</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>theta</name> <operator>/</operator> <name>M_PI_2</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>ereflectx</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>reflecty</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_hequirect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>phi</name> <operator>/</operator> <name>M_PI_2</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>theta</name> <operator>/</operator> <name>M_PI_2</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>visible</name> <init>= <expr><name>phi</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_2</name> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&lt;=</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_flat_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ih_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_flat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>acosf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>r</name> <init>= <expr><call><name>tanf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>rr</name> <init>= <expr><ternary><condition><expr><call><name>fabsf</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1e+6f</literal></expr> ?</condition><then> <expr><name>r</name></expr> </then><else>: <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>zf</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>h</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>c</name> <init>= <expr><ternary><condition><expr><name>h</name> <operator>&lt;=</operator> <literal type="number">1e-6f</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal></expr> </then><else>: <expr><name>rr</name> <operator>/</operator> <name>h</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>c</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>vf</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>c</name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>visible</name></decl>, <decl><type ref="prev"/><name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <ternary><condition><expr><name>zf</name> <operator>&gt;=</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <ternary><condition><expr><name>zf</name> <operator>&gt;=</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vi</name> <operator>&lt;</operator> <name>height</name> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&lt;</operator> <name>width</name> <operator>&amp;&amp;</operator> <name>zf</name> <operator>&gt;=</operator> <literal type="number">0.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_mercator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>phi</name> <operator>/</operator> <name>M_PI</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><call><name>av_clipf</name><argument_list>(<argument><expr><call><name>logf</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.f</literal> <operator>+</operator> <name>theta</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>theta</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>M_PI</name><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>mercator_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name> <operator>+</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>div</name> <init>= <expr><call><name>expf</name><argument_list>(<argument><expr><literal type="number">2.f</literal> <operator>*</operator> <name>y</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <call><name>expf</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>div</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><operator>(</operator><call><name>expf</name><argument_list>(<argument><expr><literal type="number">2.f</literal> <operator>*</operator> <name>y</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>div</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>sin_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_ball</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>l</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>r</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>M_SQRT2</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><literal type="number">1.f</literal> <operator>+</operator> <name>r</name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <name>width</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><literal type="number">1.f</literal> <operator>+</operator> <name>r</name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <name>height</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>ball_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>l</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;=</operator> <literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>z</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <name>l</name> <operator>*</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name>l</name> <operator>*</operator> <name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>z</name> <operator>*</operator> <name>x</name> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>z</name> <operator>*</operator> <name>y</name> <operator>/</operator> <operator>(</operator><ternary><condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>l</name> <operator>*</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.f</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>hammer_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>xx</name> <init>= <expr><name>x</name> <operator>*</operator> <name>x</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>yy</name> <init>= <expr><name>y</name> <operator>*</operator> <name>y</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>z</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name>xx</name> <operator>*</operator> <literal type="number">0.5f</literal> <operator>-</operator> <name>yy</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>a</name> <init>= <expr><name>M_SQRT2</name> <operator>*</operator> <name>x</name> <operator>*</operator> <name>z</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>b</name> <init>= <expr><literal type="number">2.f</literal> <operator>*</operator> <name>z</name> <operator>*</operator> <name>z</name> <operator>-</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>aa</name> <init>= <expr><name>a</name> <operator>*</operator> <name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>bb</name> <init>= <expr><name>b</name> <operator>*</operator> <name>b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>w</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>yy</name> <operator>*</operator> <name>z</name> <operator>*</operator> <name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>a</name> <operator>*</operator> <name>b</name> <operator>/</operator> <operator>(</operator><name>aa</name> <operator>+</operator> <name>bb</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>M_SQRT2</name> <operator>*</operator> <name>y</name> <operator>*</operator> <name>z</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>*</operator> <operator>(</operator><name>bb</name> <operator>-</operator> <name>aa</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>aa</name> <operator>+</operator> <name>bb</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_hammer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>z</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>+</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>theta</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>sinf</name><argument_list>(<argument><expr><name>theta</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <name>z</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>z</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>x</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>y</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>sinusoidal_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI_2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_sinusoidal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>phi</name> <operator>/</operator> <name>M_PI</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>theta</name> <operator>/</operator> <name>M_PI_2</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_eac_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_flip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>RIGHT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>LEFT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>UP</name></expr>]</index></name> <operator>=</operator> <name>TOP_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>DOWN</name></expr>]</index></name> <operator>=</operator> <name>TOP_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>FRONT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_MIDDLE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>BACK</name></expr>]</index></name> <operator>=</operator> <name>TOP_MIDDLE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>RIGHT</name></expr>]</index></name> <operator>=</operator> <name>TOP_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>LEFT</name></expr>]</index></name> <operator>=</operator> <name>TOP_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>UP</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>DOWN</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>FRONT</name></expr>]</index></name> <operator>=</operator> <name>TOP_MIDDLE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>BACK</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_MIDDLE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>iv_flip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>RIGHT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>LEFT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>UP</name></expr>]</index></name> <operator>=</operator> <name>TOP_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>DOWN</name></expr>]</index></name> <operator>=</operator> <name>TOP_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>FRONT</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_MIDDLE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>BACK</name></expr>]</index></name> <operator>=</operator> <name>TOP_MIDDLE</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>RIGHT</name></expr>]</index></name> <operator>=</operator> <name>TOP_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>LEFT</name></expr>]</index></name> <operator>=</operator> <name>TOP_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>UP</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>DOWN</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>FRONT</name></expr>]</index></name> <operator>=</operator> <name>TOP_MIDDLE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>BACK</name></expr>]</index></name> <operator>=</operator> <name>BOTTOM_MIDDLE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>iv_flip</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_90</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>TOP_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_90</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_eac_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>TOP_LEFT</name></expr>]</index></name> <operator>=</operator> <name>LEFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>TOP_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>FRONT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>TOP_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>RIGHT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>BOTTOM_LEFT</name></expr>]</index></name> <operator>=</operator> <name>DOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>BOTTOM_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>BACK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_direction_order</name><index>[<expr><name>BOTTOM_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>UP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>TOP_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>TOP_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>TOP_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_LEFT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_MIDDLE</name></expr>]</index></name> <operator>=</operator> <name>ROT_90</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_cubemap_face_rotation</name><index>[<expr><name>BOTTOM_RIGHT</name></expr>]</index></name> <operator>=</operator> <name>ROT_270</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>eac_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>pixel_pad</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>u_pad</name> <init>= <expr><name>pixel_pad</name> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>v_pad</name> <init>= <expr><name>pixel_pad</name> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>u_face</name></decl>, <decl><type ref="prev"/><name>v_face</name></decl>, <decl><type ref="prev"/><name>face</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>l_x</name></decl>, <decl><type ref="prev"/><name>l_y</name></decl>, <decl><type ref="prev"/><name>l_z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">3.f</literal> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>-</operator> <name>u_pad</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>u_pad</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uf</name> <operator>&lt;</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u_face</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>-=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>uf</name> <operator>&gt;=</operator> <literal type="number">3.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u_face</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>-=</operator> <literal type="number">2.5f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>u_face</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <call><name>fmodf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>v_face</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name> <operator>*</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>(</operator><name>vf</name> <operator>-</operator> <name>v_pad</name> <operator>-</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>v_face</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>v_pad</name><operator>)</operator> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>uf</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">0.5f</literal> <operator>&amp;&amp;</operator> <name>uf</name> <operator>&lt;</operator> <literal type="number">0.5f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><name>M_PI_2</name> <operator>*</operator> <name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>uf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>vf</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">0.5f</literal> <operator>&amp;&amp;</operator> <name>vf</name> <operator>&lt;</operator> <literal type="number">0.5f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><name>M_PI_2</name> <operator>*</operator> <name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>vf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name>u_face</name> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <name>v_face</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>face</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TOP_LEFT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TOP_MIDDLE</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TOP_RIGHT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BOTTOM_LEFT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BOTTOM_MIDDLE</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BOTTOM_RIGHT</name></expr>:</case>
<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>l_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>l_z</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_eac</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>pixel_pad</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>u_pad</name> <init>= <expr><name>pixel_pad</name> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>v_pad</name> <init>= <expr><name>pixel_pad</name> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>direction</name></decl>, <decl><type ref="prev"/><name>face</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_face</name></decl>, <decl><type ref="prev"/><name>v_face</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xyz_to_cube</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>face</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>in_cubemap_face_order</name><index>[<expr><name>direction</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>u_face</name> <operator>=</operator> <name>face</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_face</name> <operator>=</operator> <name>face</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <name>M_2_PI</name> <operator>*</operator> <call><name>atanf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>M_2_PI</name> <operator>*</operator> <call><name>atanf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <name>u_face</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>u_pad</name><operator>)</operator> <operator>/</operator> <literal type="number">3.f</literal> <operator>+</operator> <name>u_pad</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>vf</name> <operator>*</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>v_pad</name><operator>)</operator> <operator>+</operator> <name>v_pad</name> <operator>+</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>v_face</name></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>width</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>-=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>-=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_flat_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>flat_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>l_x</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>l_y</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>l_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_fisheye_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>fisheye_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name>vf</name></expr></argument>, <argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><name>M_PI_2</name> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <call><name>hypotf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_fisheye_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ih_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_fisheye</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>h</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>lh</name> <init>= <expr><ternary><condition><expr><name>h</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>h</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name>lh</name> <operator>*</operator> <name>phi</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>vf</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>lh</name> <operator>*</operator> <name>phi</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>visible</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0.5f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>*</operator> <name>width</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>*</operator> <name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><name>uf</name> <operator>-</operator> <name>ui</name></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><name>vf</name> <operator>-</operator> <name>vi</name></expr> </then><else>: <expr><literal type="number">0.f</literal></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>pannini_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>k</name> <init>= <expr><name>uf</name> <operator>*</operator> <name>uf</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>d</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>d</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>dscr</name> <init>= <expr><name>k</name> <operator>*</operator> <name>k</name> <operator>*</operator> <name>d</name> <operator>*</operator> <name>d</name> <operator>-</operator> <operator>(</operator><name>k</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>k</name> <operator>*</operator> <name>d</name> <operator>*</operator> <name>d</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>clon</name> <init>= <expr><operator>(</operator><operator>-</operator><name>k</name> <operator>*</operator> <name>d</name> <operator>+</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name>dscr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><name>k</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>S</name> <init>= <expr><operator>(</operator><name>d</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>d</name> <operator>+</operator> <name>clon</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>lon</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>S</name> <operator>*</operator> <name>clon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>lat</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name>vf</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sinf</name><argument_list>(<argument><expr><name>lon</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>lat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>sinf</name><argument_list>(<argument><expr><name>lat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>lon</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>lat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_cylindrical_out</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>M_PI</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>/</operator> <literal type="number">360.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>cylindrical_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>flat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><name>uf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>atanf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type> <name>prepare_cylindrical_in</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>M_PI</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>ih_fov</name></name> <operator>/</operator> <literal type="number">360.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_cylindrical</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>phi</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>width</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><call><name>tanf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>iflat_range</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ui</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vi</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>visible</name> <init>= <expr><name>vi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vi</name> <operator>&lt;</operator> <name>height</name> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ui</name> <operator>&lt;</operator> <name>width</name> <operator>&amp;&amp;</operator>
<name>theta</name> <operator>&lt;=</operator> <name>M_PI</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal> <operator>&amp;&amp;</operator>
<name>theta</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name> <operator>/</operator> <literal type="number">180.f</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>visible</name></expr> ?</condition><then> <expr><call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>perspective_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>width</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>height</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>rh</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sinzz</name> <init>= <expr><literal type="number">1.f</literal> <operator>-</operator> <name>rh</name> <operator>*</operator> <name>rh</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>h</name> <init>= <expr><literal type="number">1.f</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sinz</name> <init>= <expr><operator>(</operator><name>h</name> <operator>-</operator> <call><name>sqrtf</name><argument_list>(<argument><expr><name>sinzz</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><name>h</name> <operator>/</operator> <name>rh</name> <operator>+</operator> <name>rh</name> <operator>/</operator> <name>h</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sinz2</name> <init>= <expr><name>sinz</name> <operator>*</operator> <name>sinz</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sinz2</name> <operator>&lt;=</operator> <literal type="number">1.f</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cosz</name> <init>= <expr><call><name>sqrtf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name>sinz2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name>cosz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0.f</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>tetrahedron_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>i</name> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>float</name><operator>)</operator><name>j</name> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>uf</name> <operator>&lt;</operator> <literal type="number">0.5f</literal></expr> ?</condition><then> <expr><name>uf</name> <operator>*</operator> <literal type="number">4.f</literal> <operator>-</operator> <literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">3.f</literal> <operator>-</operator> <name>uf</name> <operator>*</operator> <literal type="number">4.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <name>vf</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <call><name>fabsf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <call><name>fabsf</name><argument_list>(<argument><expr><literal type="number">1.f</literal> <operator>-</operator> <name>uf</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>+</operator> <name>vf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_tetrahedron</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d0</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d1</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d2</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d3</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator><operator>-</operator><literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <literal type="number">1.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>d0</name></expr></argument>, <argument><expr><call><name>FFMAX3</name><argument_list>(<argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>, <argument><expr><name>d3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>d</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name>d</name></expr>;</expr_stmt>

<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>-</operator> <name>y</name> <operator>*</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>+</operator> <name>y</name> <operator>&gt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>+</operator> <name>z</name> <operator>&gt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <operator>-</operator><name>z</name> <operator>-</operator> <name>x</name> <operator>&lt;=</operator> <literal type="number">0.f</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>x</name> <operator>+</operator> <name>y</name> <operator>&lt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <operator>-</operator><name>y</name> <operator>+</operator> <name>z</name> <operator>&gt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name>z</name> <operator>-</operator> <name>x</name> <operator>&gt;=</operator> <literal type="number">0.f</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.25f</literal> <operator>*</operator> <name>x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">0.25f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.75f</literal> <operator>-</operator> <literal type="number">0.25f</literal> <operator>*</operator> <name>x</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>width</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>reflectx</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>reflecty</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>dfisheye_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">1.f</literal> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ei</name> <init>= <expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>ew</name></expr> ?</condition><then> <expr><name>i</name> <operator>-</operator> <name>ew</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>m</name> <init>= <expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>ew</name></expr> ?</condition><then> <expr><literal type="number">1.f</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1.f</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>ei</name><operator>)</operator> <operator>/</operator> <name>ew</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>scale</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <name>eh</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>scale</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>h</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>, <argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>lh</name> <init>= <expr><ternary><condition><expr><name>h</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>h</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><name>m</name> <operator>*</operator> <name>M_PI_2</name> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>h</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>m</name> <operator>*</operator> <name>uf</name> <operator>/</operator> <name>lh</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>vf</name> <operator>/</operator> <name>lh</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_dfisheye</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">2.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>eh</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>h</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>lh</name> <init>= <expr><ternary><condition><expr><name>h</name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><name>h</name></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>acosf</name><argument_list>(<argument><expr><call><name>fabsf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>/</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name> <init>= <expr><operator>(</operator><name>theta</name> <operator>*</operator> <operator>(</operator><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name>lh</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>*</operator> <name>ew</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>vf</name> <init>= <expr><operator>(</operator><name>theta</name> <operator>*</operator> <operator>(</operator><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>lh</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>*</operator> <name>eh</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_shift</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <call><name>ceilf</name><argument_list>(<argument><expr><name>ew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <name>ew</name> <operator>-</operator> <name>uf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>u_shift</name> <operator>+</operator> <name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>av_clip</name><argument_list>( <argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>barrel_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">0.99f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>l_x</name></decl>, <decl><type ref="prev"/><name>l_y</name></decl>, <decl><type ref="prev"/><name>l_z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta_range</name> <init>= <expr><name>M_PI_4</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ew</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>eh</name> <init>= <expr><name>height</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>i</name><operator>)</operator> <operator>/</operator> <name>ew</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <name>scale</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>j</name><operator>)</operator> <operator>/</operator> <name>eh</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>theta_range</name> <operator>/</operator> <name>scale</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ew</name> <init>= <expr><name>width</name> <operator>/</operator> <literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>eh</name> <init>= <expr><name>height</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>eh</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">4</literal> <operator>*</operator> <name>ew</name><operator>)</operator> <operator>/</operator> <name>ew</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>j</name> <operator>)</operator> <operator>/</operator> <name>eh</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scale</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>vf</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">4</literal> <operator>*</operator> <name>ew</name><operator>)</operator> <operator>/</operator> <name>ew</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>j</name> <operator>-</operator> <name>eh</name><operator>)</operator> <operator>/</operator> <name>eh</name> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>/=</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>/=</operator> <name>scale</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>-</operator><name>vf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>l_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>l_z</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_barrel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">0.99f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta_range</name> <init>= <expr><name>M_PI_4</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ew</name></decl>, <decl><type ref="prev"/><name>eh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_shift</name></decl>, <decl><type ref="prev"/><name>v_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>theta</name> <operator>&gt;</operator> <operator>-</operator><name>theta_range</name> <operator>&amp;&amp;</operator> <name>theta</name> <operator>&lt;</operator> <name>theta_range</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ew</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eh</name> <operator>=</operator> <name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr> ?</condition><then> <expr><name>width</name> <operator>/</operator> <literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>(</operator><name>phi</name> <operator>/</operator> <name>M_PI</name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>ew</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>(</operator><name>theta</name> <operator>/</operator> <name>theta_range</name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>eh</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ew</name> <operator>=</operator> <name>width</name> <operator>/</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eh</name> <operator>=</operator> <name>height</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">4</literal> <operator>*</operator> <name>ew</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>theta</name> <operator>&lt;</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content> 
<expr_stmt><expr><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <name>eh</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>ew</name> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>eh</name> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>*</operator> <name>scale</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u_shift</name> <operator>+</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ew</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v_shift</name> <operator>+</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eh</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_barrelsplit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><call><name>atan2f</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><call><name>asinf</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta_range</name> <init>= <expr><name>M_PI_4</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ew</name></decl>, <decl><type ref="prev"/><name>eh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u_shift</name></decl>, <decl><type ref="prev"/><name>v_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>theta</name> <operator>&gt;=</operator> <operator>-</operator><name>theta_range</name> <operator>&amp;&amp;</operator> <name>theta</name> <operator>&lt;=</operator> <name>theta_range</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ew</name> <operator>=</operator> <name>width</name> <operator>/</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eh</name> <operator>=</operator> <name>height</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr> ?</condition><then> <expr><name>width</name> <operator>/</operator> <literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <ternary><condition><expr><name>phi</name> <operator>&gt;=</operator> <name>M_PI_2</name> <operator>||</operator> <name>phi</name> <operator>&lt;</operator> <operator>-</operator><name>M_PI_2</name></expr> ?</condition><then> <expr><name>eh</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <call><name>fmodf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>, <argument><expr><name>M_PI_2</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>M_PI_2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>theta</name> <operator>/</operator> <name>M_PI_4</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v_shift</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <ternary><condition><expr><name>uf</name> <operator>&gt;=</operator> <literal type="number">0.f</literal></expr> ?</condition><then> <expr><call><name>fmodf</name><argument_list>(<argument><expr><name>uf</name> <operator>-</operator> <literal type="number">1.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>fmodf</name><argument_list>(<argument><expr><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>(</operator><name>uf</name> <operator>*</operator> <name>scalew</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">3.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>(</operator><name>vf</name> <operator>*</operator> <name>scaleh</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <name>height</name> <operator>/</operator> <literal type="number">4.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fin_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">4.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>in_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>v_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ew</name> <operator>=</operator> <name>width</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eh</name> <operator>=</operator> <name>height</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u_shift</name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal> <operator>*</operator> <name>ew</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>theta</name> <operator>&lt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name>theta</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_2</name> <operator>&amp;&amp;</operator>
<name>phi</name> <operator>&lt;=</operator> <name>M_PI_2</name> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_offset</name> <operator>=</operator> <operator>-</operator><name>eh</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>theta</name> <operator>&gt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name>theta</name> <operator>&lt;=</operator> <name>M_PI_2</name> <operator>&amp;&amp;</operator>
<name>phi</name> <operator>&lt;=</operator> <name>M_PI_2</name> <operator>&amp;&amp;</operator> <name>phi</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <name>height</name> <operator>*</operator> <literal type="number">0.25f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>theta</name> <operator>&lt;=</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name>theta</name> <operator>&gt;=</operator> <operator>-</operator><name>M_PI_2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <name>height</name> <operator>*</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v_offset</name> <operator>=</operator> <operator>-</operator><name>eh</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>-</operator><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>/</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_shift</name> <operator>=</operator> <name>height</name> <operator>*</operator> <literal type="number">0.75f</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>width</name> <operator>/</operator> <literal type="number">3.f</literal> <operator>*</operator> <operator>(</operator><name>uf</name> <operator>*</operator> <name>scalew</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>height</name> <operator>*</operator> <literal type="number">0.25f</literal> <operator>*</operator> <operator>(</operator><name>vf</name> <operator>*</operator> <name>scaleh</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>+</operator> <name>v_offset</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>u_shift</name> <operator>+</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ew</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v_shift</name> <operator>+</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>eh</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>barrelsplit_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>l_x</name></decl>, <decl><type ref="prev"/><name>l_y</name></decl>, <decl><type ref="prev"/><name>l_z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">2.f</literal> <operator>/</operator> <literal type="number">3.f</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>back</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y</name> <operator>*</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>phi</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">3.f</literal> <operator>/</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>x</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>scalew</name> <operator>-</operator> <name>back</name><operator>)</operator> <operator>*</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>theta</name> <init>= <expr><operator>(</operator><name>y</name> <operator>-</operator> <literal type="number">0.25f</literal> <operator>-</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>back</name><operator>)</operator> <operator>/</operator> <name>scaleh</name> <operator>*</operator> <name>M_PI</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_phi</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_phi</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>phi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_theta</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_theta</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>sin_phi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <name>sin_theta</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <name>cos_theta</name> <operator>*</operator> <name>cos_phi</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scalew</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>/</operator> <literal type="number">3.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scaleh</name> <init>= <expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>fout_pad</name></name> <operator>/</operator> <operator>(</operator><name>height</name> <operator>/</operator> <literal type="number">4.f</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">1.f</literal> <operator>-</operator> <name><name>s</name><operator>-&gt;</operator><name>out_pad</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>face</name> <init>= <expr><call><name>floorf</name><argument_list>(<argument><expr><name>y</name> <operator>*</operator> <literal type="number">4.f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">3.f</literal> <operator>-</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>face</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>y</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>-</operator> <name>vf</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>uf</name><operator>)</operator> <operator>/</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>vf</name><operator>)</operator> <operator>/</operator> <name>scaleh</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>y</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <name>uf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><name>vf</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>uf</name><operator>)</operator> <operator>/</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>(</operator><operator>-</operator><literal type="number">0.5f</literal> <operator>+</operator> <name>vf</name><operator>)</operator> <operator>/</operator> <name>scaleh</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>y</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>-</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>vf</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>uf</name><operator>)</operator> <operator>/</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <operator>-</operator><literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>vf</name><operator>)</operator> <operator>/</operator> <name>scaleh</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <name>y</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>-</operator> <literal type="number">1.5f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>l_x</name> <operator>=</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>uf</name><operator>)</operator> <operator>/</operator> <name>scalew</name></expr>;</expr_stmt>
<expr_stmt><expr><name>l_y</name> <operator>=</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l_z</name> <operator>=</operator> <operator>(</operator><operator>-</operator><literal type="number">0.5f</literal> <operator>+</operator> <name>vf</name><operator>)</operator> <operator>/</operator> <name>scaleh</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l_x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>l_y</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>l_z</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type> <name>tspyramid_to_xyz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>width</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y</name> <init>= <expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <name>height</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0.5f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x</name> <operator>*</operator> <literal type="number">4.f</literal> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>*</operator> <literal type="number">2.f</literal> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>x</name> <operator>&gt;=</operator> <literal type="number">0.6875f</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0.8125f</literal> <operator>&amp;&amp;</operator>
<name>y</name> <operator>&gt;=</operator> <literal type="number">0.375f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.625f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">0.6875f</literal><operator>)</operator> <operator>*</operator> <literal type="number">16.f</literal> <operator>+</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>y</name> <operator>-</operator> <literal type="number">0.375f</literal><operator>)</operator> <operator>*</operator> <literal type="number">8.f</literal> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0.5f</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0.6875f</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><literal type="number">0.f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.375f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>&gt;=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.375f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.625f</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.625f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">1.f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>x</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>y</name> <operator>-</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>x</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">3.f</literal> <operator>-</operator> <literal type="number">4.f</literal> <operator>*</operator> <name>x</name><operator>)</operator> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>/</operator> <literal type="number">0.1875f</literal> <operator>+</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0.8125f</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">1.f</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><literal type="number">0.f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.375f</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>y</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.375f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.625f</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.625f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">1.f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">2.f</literal> <operator>*</operator> <name>x</name> <operator>-</operator> <literal type="number">1.f</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>y</name> <operator>+</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>x</name> <operator>-</operator> <literal type="number">2.f</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">4.f</literal> <operator>*</operator> <name>x</name> <operator>-</operator> <literal type="number">3.f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">0.8125f</literal><operator>)</operator> <operator>/</operator> <literal type="number">0.1875f</literal> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0.f</literal> <operator>&lt;=</operator> <name>y</name> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">0.375f</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><literal type="number">0.5f</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0.8125f</literal> <operator>&amp;&amp;</operator> <name>y</name> <operator>&lt;</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.6875f</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">0.8125f</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><literal type="number">0.8125f</literal> <operator>&lt;=</operator> <name>x</name> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <literal type="number">1.f</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>y</name> <operator>/</operator> <literal type="number">2.f</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>x</name> <operator>-</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>y</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>y</name><operator>)</operator> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><literal type="number">0.375f</literal> <operator>-</operator> <name>y</name><operator>)</operator> <operator>/</operator> <literal type="number">0.375f</literal> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><literal type="number">0.5f</literal> <operator>-</operator> <name>x</name> <operator>+</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>y</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>y</name> <operator>-</operator> <literal type="number">0.5f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">2.f</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <name>y</name><operator>)</operator> <operator>/</operator> <literal type="number">0.375f</literal> <operator>+</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>int</name></type> <name>xyz_to_tspyramid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name><name>us</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name><name>vs</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>du</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>uf</name></decl>, <decl><type ref="prev"/><name>vf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ui</name></decl>, <decl><type ref="prev"/><name>vi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>face</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>xyz_to_cube</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>face</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uf</name> <operator>=</operator> <operator>(</operator><name>uf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <operator>(</operator><name>vf</name> <operator>+</operator> <literal type="number">1.f</literal><operator>)</operator> <operator>*</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>face</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UP</name></expr>:</case>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.1875f</literal> <operator>*</operator> <name>vf</name> <operator>-</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>uf</name> <operator>*</operator> <name>vf</name> <operator>-</operator> <literal type="number">0.125f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.8125f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.375f</literal> <operator>-</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FRONT</name></expr>:</case>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>uf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DOWN</name></expr>:</case>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <literal type="number">0.1875f</literal> <operator>*</operator> <name>vf</name> <operator>-</operator> <literal type="number">0.5f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>uf</name> <operator>*</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">1.f</literal> <operator>-</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>vf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LEFT</name></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.25f</literal> <operator>*</operator> <name>vf</name> <operator>+</operator> <literal type="number">0.75f</literal> <operator>*</operator> <name>uf</name> <operator>*</operator> <name>vf</name> <operator>-</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.375f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.1875f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.8125f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>RIGHT</name></expr>:</case>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.375f</literal> <operator>*</operator> <name>uf</name> <operator>-</operator> <literal type="number">0.75f</literal> <operator>*</operator> <name>uf</name> <operator>*</operator> <name>vf</name> <operator>+</operator> <name>vf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.1875f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.5f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BACK</name></expr>:</case>
<expr_stmt><expr><name>uf</name> <operator>=</operator> <literal type="number">0.125f</literal> <operator>*</operator> <name>uf</name> <operator>+</operator> <literal type="number">0.6875f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>=</operator> <literal type="number">0.25f</literal> <operator>*</operator> <name>vf</name> <operator>+</operator> <literal type="number">0.375f</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name>uf</name> <operator>*=</operator> <name>width</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vf</name> <operator>*=</operator> <name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ui</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>uf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vi</name> <operator>=</operator> <call><name>floorf</name><argument_list>(<argument><expr><name>vf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>du</name> <operator>=</operator> <name>uf</name> <operator>-</operator> <name>ui</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dv</name> <operator>=</operator> <name>vf</name> <operator>-</operator> <name>vi</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>us</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>reflectx</name><argument_list>(<argument><expr><name>ui</name> <operator>+</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>reflecty</name><argument_list>(<argument><expr><name>vi</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>multiply_matrix</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>float</name></type> <name>sum</name> <init>= <expr><literal type="number">0.f</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <name><name>b</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>calculate_rotation_matrix</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>yaw</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>pitch</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>roll</name></decl></parameter>,
<parameter><decl><type><name>float</name></type> <name><name>rot_mat</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>rotation_order</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>yaw_rad</name> <init>= <expr><name>yaw</name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>pitch_rad</name> <init>= <expr><name>pitch</name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>roll_rad</name> <init>= <expr><name>roll</name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_yaw</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>yaw_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_yaw</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>yaw_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_pitch</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>pitch_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_pitch</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>pitch_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>sin_roll</name> <init>= <expr><call><name>sinf</name><argument_list>(<argument><expr><name>roll_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>cos_roll</name> <init>= <expr><call><name>cosf</name><argument_list>(<argument><expr><name>roll_rad</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name><name>m</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>temp</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_yaw</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sin_yaw</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>sin_yaw</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_yaw</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cos_pitch</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>sin_pitch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sin_pitch</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cos_pitch</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>cos_roll</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>sin_roll</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sin_roll</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>cos_roll</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>multiply_matrix</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name><name>m</name><index>[<expr><name><name>rotation_order</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>m</name><index>[<expr><name><name>rotation_order</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multiply_matrix</name><argument_list>(<argument><expr><name>rot_mat</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name><name>m</name><index>[<expr><name><name>rotation_order</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>rotate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name><name>rot_mat</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x_tmp</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>y_tmp</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>z_tmp</name> <init>= <expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name><name>rot_mat</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>x_tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>y_tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>z_tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_mirror_modifier</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>h_flip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v_flip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>d_flip</name></decl></parameter>,
<parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>modifier</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>h_flip</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>v_flip</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>modifier</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>d_flip</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>mirror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>float</name> <modifier>*</modifier></type><name>modifier</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*=</operator> <name><name>modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*=</operator> <name><name>modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*=</operator> <name><name>modifier</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>allocate_plane</name><parameter_list>(<parameter><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sizeof_uv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sizeof_ker</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sizeof_mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>uv_linesize</name><index>[<expr><name>p</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_height</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>sizeof_uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>uv_linesize</name><index>[<expr><name>p</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_height</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>sizeof_uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>p</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sizeof_ker</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ker</name><index>[<expr><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ker</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>uv_linesize</name><index>[<expr><name>p</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_height</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>sizeof_ker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>ker</name><index>[<expr><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sizeof_mask</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>mask</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>mask</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pr_width</name><index>[<expr><name>p</name></expr>]</index></name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_height</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>sizeof_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>mask</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fov_from_dfov</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>d_fov</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>h_fov</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>v_fov</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STEREOGRAPHIC</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><literal type="number">0.5f</literal> <operator>*</operator> <call><name>hypotf</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>l</name> <init>= <expr><name>d</name> <operator>/</operator> <operator>(</operator><call><name>tanf</name><argument_list>(<argument><expr><name>d_fov</name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">720.f</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>h_fov</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <call><name>atan2f</name><argument_list>(<argument><expr><name>w</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">360.f</literal> <operator>/</operator> <name>M_PI</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v_fov</name> <operator>=</operator> <literal type="number">2.f</literal> <operator>*</operator> <call><name>atan2f</name><argument_list>(<argument><expr><name>h</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">360.f</literal> <operator>/</operator> <name>M_PI</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>FISHEYE</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><literal type="number">0.5f</literal> <operator>*</operator> <call><name>hypotf</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>h_fov</name> <operator>=</operator> <name>d</name> <operator>/</operator> <name>w</name> <operator>*</operator> <name>d_fov</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v_fov</name> <operator>=</operator> <name>d</name> <operator>/</operator> <name>h</name> <operator>*</operator> <name>d_fov</name></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>FLAT</name></expr>:</case>
<default>default:</default>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>da</name> <init>= <expr><call><name>tanf</name><argument_list>(<argument><expr><literal type="number">0.5f</literal> <operator>*</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>d_fov</name></expr></argument>, <argument><expr><literal type="number">359.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">180.f</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><call><name>hypotf</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>h_fov</name> <operator>=</operator> <call><name>atan2f</name><argument_list>(<argument><expr><name>da</name> <operator>*</operator> <name>w</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">360.f</literal> <operator>/</operator> <name>M_PI</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v_fov</name> <operator>=</operator> <call><name>atan2f</name><argument_list>(<argument><expr><name>da</name> <operator>*</operator> <name>h</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">360.f</literal> <operator>/</operator> <name>M_PI</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>h_fov</name> <operator>&lt;</operator> <literal type="number">0.f</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>h_fov</name> <operator>+=</operator> <literal type="number">360.f</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>v_fov</name> <operator>&lt;</operator> <literal type="number">0.f</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>v_fov</name> <operator>+=</operator> <literal type="number">360.f</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_dimensions</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outw</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>outw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>outw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>FF_CEIL_RSHIFT</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>outw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outh</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>outh</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>FF_CEIL_RSHIFT</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outh</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>outh</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>av_always_inline</name> <name>int</name></type> <name>v360_slice</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jobnr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nb_jobs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_allocated</name></name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_value</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>max_value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pr_width</name><index>[<expr><name>p</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>uv_linesize</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>uv_linesize</name><index>[<expr><name>p</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>pr_height</name><index>[<expr><name>p</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>in_width</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>inplanewidth</name><index>[<expr><name>p</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>in_height</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>inplaneheight</name><index>[<expr><name>p</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>slice_start</name> <init>= <expr><operator>(</operator><name>height</name> <operator>*</operator> <name>jobnr</name> <operator>)</operator> <operator>/</operator> <name>nb_jobs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>slice_end</name> <init>= <expr><operator>(</operator><name>height</name> <operator>*</operator> <operator>(</operator><name>jobnr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>nb_jobs</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>du</name></decl>, <decl><type ref="prev"/><name>dv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>vec</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XYRemap</name></type> <name>rmap</name></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>slice_start</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>slice_end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>p</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name>uv_linesize</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>p</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name>uv_linesize</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>ker</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>ker</name><index>[<expr><name>p</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name>uv_linesize</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>mask8</name> <init>= <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>mask</name></name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_width</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>mask16</name> <init>= <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>mask</name></name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>pr_width</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_mask</name></decl>, <decl><type ref="prev"/><name>out_mask</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>out_transpose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>out_mask</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>out_mask</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rotate</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rot_mat</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name><name>vec</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>normalize_vector</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mirror</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_mirror_modifier</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>in_transpose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>in_mask</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>in_height</name></expr></argument>, <argument><expr><name>in_width</name></expr></argument>, <argument><expr><name><name>rmap</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>rmap</name><operator>.</operator><name>u</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>du</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>in_mask</name> <operator>=</operator> <call><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>in_width</name></expr></argument>, <argument><expr><name>in_height</name></expr></argument>, <argument><expr><name><name>rmap</name><operator>.</operator><name>u</name></name></expr></argument>, <argument><expr><name><name>rmap</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>du</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>av_assert1</name><argument_list>(<argument><expr><operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name>du</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name>dv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name><argument_list>(<argument><expr><name>du</name></expr></argument>, <argument><expr><name>dv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rmap</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>ker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>mask</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>mask_size</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mask8</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal> <operator>*</operator> <operator>(</operator><name>out_mask</name> <operator>&amp;</operator> <name>in_mask</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>mask16</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>max_value</name> <operator>*</operator> <operator>(</operator><name>out_mask</name> <operator>&amp;</operator> <name>in_mask</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_output</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>outlink</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>depth</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sizeof_mask</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>mask_size</name></name> <operator>=</operator> <operator>(</operator><name>depth</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizeof_uv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sizeof_ker</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_offset_h</name></decl>, <decl><type ref="prev"/><name>in_offset_w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>out_offset_h</name></decl>, <decl><type ref="prev"/><name>out_offset_w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>hf</name></decl>, <decl><type ref="prev"/><name>wf</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>prepare_out</name>)<parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>have_alpha</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>depth</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ih_flip</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>input_mirror_modifier</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>iv_flip</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.f</literal></expr> </then><else>: <expr><literal type="number">1.f</literal></expr></else></ternary></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>interp</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NEAREST</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>nearest_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap1_8bit_slice</name></expr> </then><else>: <expr><name>remap1_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BILINEAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>bilinear_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap2_8bit_slice</name></expr> </then><else>: <expr><name>remap2_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LAGRANGE9</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>lagrange_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap3_8bit_slice</name></expr> </then><else>: <expr><name>remap3_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BICUBIC</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>bicubic_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap4_8bit_slice</name></expr> </then><else>: <expr><name>remap4_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>LANCZOS</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>lanczos_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap4_8bit_slice</name></expr> </then><else>: <expr><name>remap4_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SPLINE16</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>spline16_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap4_8bit_slice</name></expr> </then><else>: <expr><name>remap4_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>GAUSSIAN</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>calculate_kernel</name></name> <operator>=</operator> <name>gaussian_kernel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name> <operator>=</operator> <ternary><condition><expr><name>depth</name> <operator>&lt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><name>remap4_8bit_slice</name></expr> </then><else>: <expr><name>remap4_16bit_slice</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_uv</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sizeof_ker</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>ff_v360_init</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>order</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>order</name> <operator>&lt;</operator> <name>NB_RORDERS</name></expr>;</condition> <incr><expr><name>order</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>rorder</name><index>[<expr><name>order</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rorder</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete rorder option. Direction for all 3 rotation orders should be specified. Switching to default rorder.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>YAW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PITCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>ROLL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rorder</name> <operator>=</operator> <call><name>get_rorder</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rorder</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Incorrect rotation order symbol '%c' in rorder option. Switching to default rorder.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>YAW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PITCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>ROLL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name><index>[<expr><name>order</name></expr>]</index></name> <operator>=</operator> <name>rorder</name></expr>;</expr_stmt>
</block_content>}</block></for>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>in_stereo</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STEREO_2D</name></expr>:</case>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_offset_w</name> <operator>=</operator> <name>in_offset_h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREO_SBS</name></expr>:</case>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_offset_w</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>in_offset_h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREO_TB</name></expr>:</case>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in_offset_w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in_offset_h</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>set_dimensions</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>inplanewidth</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>inplaneheight</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_dimensions</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_offset_w</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_offset_h</name></name></expr></argument>, <argument><expr><name>in_offset_w</name></expr></argument>, <argument><expr><name>in_offset_h</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_width</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>inplanewidth</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_height</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>inplaneheight</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>id_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fov_from_dfov</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>id_fov</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ih_fov</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>iv_fov</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>in_transpose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>in_height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>in</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EQUIRECTANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_equirect</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_3_2</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_cube3x2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_cube_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>/</operator> <literal type="number">3.f</literal> <operator>*</operator> <literal type="number">4.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_1_6</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_cube1x6</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_cube_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>*</operator> <literal type="number">4.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>/</operator> <literal type="number">3.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_6_1</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_cube6x1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_cube_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>/</operator> <literal type="number">3.f</literal> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EQUIANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_eac</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_eac_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>/</operator> <literal type="number">9.f</literal> <operator>*</operator> <literal type="number">8.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FLAT</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_flat</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_flat_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PERSPECTIVE</name></expr>:</case>
<case>case <expr><name>PANNINI</name></expr>:</case>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Supplied format is not accepted as input.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DUAL_FISHEYE</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_dfisheye</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BARREL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_barrel</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>/</operator> <literal type="number">5.f</literal> <operator>*</operator> <literal type="number">4.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREOGRAPHIC</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_stereographic</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_stereographic_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MERCATOR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_mercator</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BALL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_ball</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>/</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HAMMER</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_hammer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SINUSOIDAL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_sinusoidal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FISHEYE</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_fisheye</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_fisheye_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CYLINDRICAL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_cylindrical</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_cylindrical_in</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TETRAHEDRON</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_tetrahedron</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BARREL_SPLIT</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_barrelsplit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>*</operator> <literal type="number">4.f</literal> <operator>/</operator> <literal type="number">3.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TSPYRAMID</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_tspyramid</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HEQUIRECTANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>in_transform</name></name> <operator>=</operator> <name>xyz_to_hequirect</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wf</name> <operator>=</operator> <name>w</name> <operator>*</operator> <literal type="number">2.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hf</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Specified input format is not handled.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_BUG</name></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EQUIRECTANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>equirect_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_3_2</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>cube3x2_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_cube_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">4.f</literal> <operator>*</operator> <literal type="number">3.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_1_6</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>cube1x6_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_cube_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">4.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>*</operator> <literal type="number">3.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CUBEMAP_6_1</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>cube6x1_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_cube_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">2.f</literal> <operator>*</operator> <literal type="number">3.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>/</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EQUIANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>eac_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_eac_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>/</operator> <literal type="number">8.f</literal> <operator>*</operator> <literal type="number">9.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FLAT</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>flat_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_flat_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DUAL_FISHEYE</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>dfisheye_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BARREL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>barrel_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">4.f</literal> <operator>*</operator> <literal type="number">5.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREOGRAPHIC</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>stereographic_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_stereographic_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>*</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MERCATOR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>mercator_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>*</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BALL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>ball_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>*</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HAMMER</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>hammer_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SINUSOIDAL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>sinusoidal_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>FISHEYE</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>fisheye_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_fisheye_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PANNINI</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>pannini_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CYLINDRICAL</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>cylindrical_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>prepare_cylindrical_out</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name> <operator>*</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PERSPECTIVE</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>perspective_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TETRAHEDRON</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>tetrahedron_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BARREL_SPLIT</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>barrelsplit_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">4.f</literal> <operator>*</operator> <literal type="number">3.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TSPYRAMID</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>tspyramid_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>HEQUIRECTANGULAR</name></expr>:</case>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>out_transform</name></name> <operator>=</operator> <name>hequirect_to_xyz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prepare_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>wf</name> <operator>/</operator> <literal type="number">2.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>lrintf</name><argument_list>(<argument><expr><name>hf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Specified output format is not handled.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_BUG</name></expr>;</return>
</block_content>}</block></switch>


<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>out</name></name> <operator>==</operator> <name>FLAT</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>d_fov</name></name> <operator>==</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name>w</name> <operator>/</operator> <call><name>tanf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">360.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>tanf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">360.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>out</name></name> <operator>==</operator> <name>FLAT</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>d_fov</name></name> <operator>==</operator> <literal type="number">0.f</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name>h</name> <operator>/</operator> <call><name>tanf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">360.f</literal></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>tanf</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name> <operator>*</operator> <name>M_PI</name> <operator>/</operator> <literal type="number">360.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Both width and height values should be specified.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>out_transpose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>in_transpose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FFSWAP</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>d_fov</name></name> <operator>&gt;</operator> <literal type="number">0.f</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fov_from_dfov</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>d_fov</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>h_fov</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>v_fov</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prepare_out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>prepare_out</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>err</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_dimensions</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pr_width</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pr_height</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>out_stereo</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STEREO_2D</name></expr>:</case>
<expr_stmt><expr><name>out_offset_w</name> <operator>=</operator> <name>out_offset_h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREO_SBS</name></expr>:</case>
<expr_stmt><expr><name>out_offset_w</name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>out_offset_h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>STEREO_TB</name></expr>:</case>
<expr_stmt><expr><name>out_offset_w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>out_offset_h</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>set_dimensions</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>out_offset_w</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>out_offset_h</name></name></expr></argument>, <argument><expr><name>out_offset_w</name></expr></argument>, <argument><expr><name>out_offset_h</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_dimensions</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>planewidth</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>planeheight</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>uv_linesize</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>pr_width</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nb_planes</name></name> <operator>=</operator> <call><name>av_pix_fmt_count_planes</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>have_alpha</name> <operator>=</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_ALPHA</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name> <operator>==</operator> <name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_w</name></name> <operator>&amp;&amp;</operator> <name><name>desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nb_allocated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nb_allocated</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_allocated</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>allocate_plane</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sizeof_uv</name></expr></argument>, <argument><expr><name>sizeof_ker</name></expr></argument>, <argument><expr><name>sizeof_mask</name> <operator>*</operator> <name>have_alpha</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>alpha</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>calculate_rotation_matrix</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>yaw</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>pitch</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>roll</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>rot_mat</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>rotation_order</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_mirror_modifier</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>h_flip</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>v_flip</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>d_flip</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>output_mirror_modifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>v360_slice</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>ff_filter_get_nb_threads</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ThreadData</name></type> <name>td</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>ff_get_video_buffer</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_frame_copy_props</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>td</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>td</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>remap_slice</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>ff_filter_get_nb_threads</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>process_command</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>res_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_filter_process_command</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>res_len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>config_output</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>void</name></type> <name>uninit</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>V360Context</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nb_allocated</name></name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>u</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>ker</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>inputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>filter_frame</name> <operator>=</operator> <name>filter_frame</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>outputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_output</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_vf_v360</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"v360"</literal></expr>,
<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Convert 360 projection of video."</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>V360Context</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>uninit</name> <operator>=</operator> <name>uninit</name></expr>,
<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,
<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>inputs</name></expr>,
<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>outputs</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>v360_class</name></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_SLICE_THREADS</name></expr>,
<expr><operator>.</operator><name>process_command</name> <operator>=</operator> <name>process_command</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
