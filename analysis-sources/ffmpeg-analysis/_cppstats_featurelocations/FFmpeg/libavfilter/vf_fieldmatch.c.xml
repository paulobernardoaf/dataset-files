<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavfilter\vf_fieldmatch.c">































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/imgutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avfilter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filters.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_MAIN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_CLEANSRC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<enum>enum <name>fieldmatch_parity</name> <block>{
<decl><name>FM_PARITY_AUTO</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>FM_PARITY_BOTTOM</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>FM_PARITY_TOP</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
}</block>;</enum>

<enum>enum <name>matching_mode</name> <block>{
<decl><name>MODE_PC</name></decl>,
<decl><name>MODE_PC_N</name></decl>,
<decl><name>MODE_PC_U</name></decl>,
<decl><name>MODE_PC_N_UB</name></decl>,
<decl><name>MODE_PCN</name></decl>,
<decl><name>MODE_PCN_UB</name></decl>,
<decl><name>NB_MODE</name></decl>
}</block>;</enum>

<enum>enum <name>comb_matching_mode</name> <block>{
<decl><name>COMBMATCH_NONE</name></decl>,
<decl><name>COMBMATCH_SC</name></decl>,
<decl><name>COMBMATCH_FULL</name></decl>,
<decl><name>NB_COMBMATCH</name></decl>
}</block>;</enum>

<enum>enum <name>comb_dbg</name> <block>{
<decl><name>COMBDBG_NONE</name></decl>,
<decl><name>COMBDBG_PCN</name></decl>,
<decl><name>COMBDBG_PCNUB</name></decl>,
<decl><name>NB_COMBDBG</name></decl>
}</block>;</enum>

<typedef>typedef <type><struct>struct <name>FieldMatchContext</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>prv</name></decl>, <modifier>*</modifier><name>src</name>, <modifier>*</modifier><name>nxt</name>;</decl_stmt> 
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>prv2</name></decl>, <modifier>*</modifier><name>src2</name>, <modifier>*</modifier><name>nxt2</name>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>got_frame</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>hsub</name></decl>, <name>vsub</name>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bpc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>eof</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int64_t</name></type> <name>lastscdiff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lastn</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ppsrc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>field</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mchroma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y0</name></decl>, <name>y1</name>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>scthresh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>scthresh_flt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>combmatch</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>combdbg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cthresh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chroma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>blockx</name></decl>, <name>blocky</name>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>combpel</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>map_data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>map_linesize</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>cmask_data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>cmask_linesize</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>c_array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tpitchy</name></decl>, <name>tpitchuv</name>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tbuffer</name></decl>;</decl_stmt>
}</block></struct></type> <name>FieldMatchContext</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(FieldMatchContext, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS</name></cpp:macro> <cpp:value>AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>fieldmatch_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"order"</literal></expr>, <expr><literal type="string">"specify the assumed field order"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_AUTO</name></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"order"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"auto"</literal></expr>, <expr><literal type="string">"auto detect parity"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_AUTO</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"order"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bff"</literal></expr>, <expr><literal type="string">"assume bottom field first"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_BOTTOM</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"order"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"tff"</literal></expr>, <expr><literal type="string">"assume top field first"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_TOP</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"order"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"mode"</literal></expr>, <expr><literal type="string">"set the matching mode or strategy to use"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PC_N</name></expr>}</block></expr>, <expr><name>MODE_PC</name></expr>, <expr><name>NB_MODE</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pc"</literal></expr>, <expr><literal type="string">"2-way match (p/c)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PC</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pc_n"</literal></expr>, <expr><literal type="string">"2-way match + 3rd match on combed (p/c + u)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PC_N</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pc_u"</literal></expr>, <expr><literal type="string">"2-way match + 3rd match (same order) on combed (p/c + u)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PC_U</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pc_n_ub"</literal></expr>, <expr><literal type="string">"2-way match + 3rd match on combed + 4th/5th matches if still combed (p/c + u + u/b)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PC_N_UB</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pcn"</literal></expr>, <expr><literal type="string">"3-way match (p/c/n)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PCN</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pcn_ub"</literal></expr>, <expr><literal type="string">"3-way match + 4th/5th matches on combed (p/c/n + u/b)"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>MODE_PCN_UB</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"ppsrc"</literal></expr>, <expr><literal type="string">"mark main input as a pre-processed input and activate clean source input stream"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>ppsrc</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"field"</literal></expr>, <expr><literal type="string">"set the field to match from"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_AUTO</name></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"field"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"auto"</literal></expr>, <expr><literal type="string">"automatic (same value as 'order')"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_AUTO</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"field"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bottom"</literal></expr>, <expr><literal type="string">"bottom field"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_BOTTOM</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"field"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"top"</literal></expr>, <expr><literal type="string">"top field"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>FM_PARITY_TOP</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"field"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"mchroma"</literal></expr>, <expr><literal type="string">"set whether or not chroma is included during the match comparisons"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>mchroma</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">1</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"y0"</literal></expr>, <expr><literal type="string">"define an exclusion band which excludes the lines between y0 and y1 from the field matching decision"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>y0</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"y1"</literal></expr>, <expr><literal type="string">"define an exclusion band which excludes the lines between y0 and y1 from the field matching decision"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"scthresh"</literal></expr>, <expr><literal type="string">"set scene change detection threshold"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>scthresh_flt</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_DOUBLE</name></expr>, <expr><block>{<expr><operator>.</operator><name>dbl</name><operator>=</operator><literal type="number">12</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"combmatch"</literal></expr>, <expr><literal type="string">"set combmatching mode"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>combmatch</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBMATCH_SC</name></expr>}</block></expr>, <expr><name>COMBMATCH_NONE</name></expr>, <expr><name>NB_COMBMATCH</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"combmatching"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"none"</literal></expr>, <expr><literal type="string">"disable combmatching"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBMATCH_NONE</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"combmatching"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sc"</literal></expr>, <expr><literal type="string">"enable combmatching only on scene change"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBMATCH_SC</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"combmatching"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"full"</literal></expr>, <expr><literal type="string">"enable combmatching all the time"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBMATCH_FULL</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"combmatching"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"combdbg"</literal></expr>, <expr><literal type="string">"enable comb debug"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>combdbg</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBDBG_NONE</name></expr>}</block></expr>, <expr><name>COMBDBG_NONE</name></expr>, <expr><name>NB_COMBDBG</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"dbglvl"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"none"</literal></expr>, <expr><literal type="string">"no forced calculation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBDBG_NONE</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"dbglvl"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pcn"</literal></expr>, <expr><literal type="string">"calculate p/c/n"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBDBG_PCN</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"dbglvl"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"pcnub"</literal></expr>, <expr><literal type="string">"calculate p/c/n/u/b"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>COMBDBG_PCNUB</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"dbglvl"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"cthresh"</literal></expr>, <expr><literal type="string">"set the area combing threshold used for combed frame detection"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>cthresh</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator> <literal type="number">9</literal></expr>}</block></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"chroma"</literal></expr>, <expr><literal type="string">"set whether or not chroma is considered in the combed frame decision"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>chroma</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_BOOL</name></expr>,<expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"blockx"</literal></expr>, <expr><literal type="string">"set the x-axis size of the window used during combed frame detection"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>blockx</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">16</literal></expr>}</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">9</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"blocky"</literal></expr>, <expr><literal type="string">"set the y-axis size of the window used during combed frame detection"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>blocky</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">16</literal></expr>}</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">9</literal></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"combpel"</literal></expr>, <expr><literal type="string">"set the number of combed pixels inside any of the blocky by blockx size blocks on the frame for the frame to be detected as combed"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>combpel</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><literal type="number">80</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AVFILTER_DEFINE_CLASS</name><argument_list>(<argument><expr><name>fieldmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_width</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>plane</name></expr> ?</condition><then> <expr><call><name>AV_CEIL_RSHIFT</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>hsub</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>f</name><operator>-&gt;</operator><name>width</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_height</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>plane</name></expr> ?</condition><then> <expr><call><name>AV_CEIL_RSHIFT</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>vsub</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>f</name><operator>-&gt;</operator><name>height</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>luma_abs_diff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>f2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>srcp1</name> <init>= <expr><name><name>f1</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>srcp2</name> <init>= <expr><name><name>f2</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>src1_linesize</name> <init>= <expr><name><name>f1</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>src2_linesize</name> <init>= <expr><name><name>f2</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><name><name>f1</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><name><name>f1</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>acc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>acc</name> <operator>+=</operator> <call><name>abs</name><argument_list>(<argument><expr><name><name>srcp1</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp2</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>srcp1</name> <operator>+=</operator> <name>src1_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcp2</name> <operator>+=</operator> <name>src2_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>acc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_buf</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linesize</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>h</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>calc_combed_score</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>plane</name></decl>, <decl><type ref="prev"/><name>max_v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cthresh</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cthresh</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cthresh6</name> <init>= <expr><name>cthresh</name> <operator>*</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>plane</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>plane</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>fm</name><operator>-&gt;</operator><name>chroma</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>plane</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>srcp</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>src_linesize</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><call><name>get_width</name> <argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><call><name>get_height</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkp</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmk_linesize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cthresh</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fill_buf</name><argument_list>(<argument><expr><name>cmkp</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>cmk_linesize</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fill_buf</name><argument_list>(<argument><expr><name>cmkp</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>cmk_linesize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILTER</name><parameter_list>(<parameter><type><name>xm2</name></type></parameter>, <parameter><type><name>xm1</name></type></parameter>, <parameter><type><name>xp1</name></type></parameter>, <parameter><type><name>xp2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>abs( 4 * srcp[x] -3 * (srcp[x + (xm1)*src_linesize] + srcp[x + (xp1)*src_linesize]) + (srcp[x + (xm2)*src_linesize] + srcp[x + (xp2)*src_linesize])) &gt; cthresh6</cpp:value></cpp:define>





<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>+</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <call><name>FILTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cmkp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>srcp</name> <operator>+=</operator> <name>src_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>-</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s2</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>+</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <name>s2</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <call><name>FILTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cmkp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>srcp</name> <operator>+=</operator> <name>src_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name><operator>-</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>-</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s2</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>+</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <name>s2</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <call><name>FILTER</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cmkp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>srcp</name> <operator>+=</operator> <name>src_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>-</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s2</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>+</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <name>s2</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <call><name>FILTER</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cmkp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>srcp</name> <operator>+=</operator> <name>src_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>s1</name> <init>= <expr><call><name>abs</name><argument_list>(<argument><expr><name><name>srcp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>srcp</name><index>[<expr><name>x</name> <operator>-</operator> <name>src_linesize</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;</operator> <name>cthresh</name> <operator>&amp;&amp;</operator> <call><name>FILTER</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cmkp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>chroma</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkp</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkpU</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkpV</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><call><name>AV_CEIL_RSHIFT</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>hsub</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><call><name>AV_CEIL_RSHIFT</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>height</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>vsub</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmk_linesize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmk_linesizeUV</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkpp</name> <init>= <expr><name>cmkp</name> <operator>-</operator> <operator>(</operator><name>cmk_linesize</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkpn</name> <init>= <expr><name>cmkp</name> <operator>+</operator> <operator>(</operator><name>cmk_linesize</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cmkpnn</name> <init>= <expr><name>cmkp</name> <operator>+</operator> <name>cmk_linesize</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>cmkpp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkpn</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkpnn</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkpV</name> <operator>+=</operator> <name>cmk_linesizeUV</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmkpU</name> <operator>+=</operator> <name>cmk_linesizeUV</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_FF_AROUND</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>lz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(p[(x)-1 - (lz)] == 0xff || p[(x) - (lz)] == 0xff || p[(x)+1 - (lz)] == 0xff || p[(x)-1 ] == 0xff || p[(x)+1 ] == 0xff || p[(x)-1 + (lz)] == 0xff || p[(x) + (lz)] == 0xff || p[(x)+1 + (lz)] == 0xff)</cpp:value></cpp:define>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cmkpV</name><index>[<expr><name>x</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator> <call><name>HAS_FF_AROUND</name><argument_list>(<argument><expr><name>cmkpV</name></expr></argument>, <argument><expr><name>cmk_linesizeUV</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>cmkpU</name><index>[<expr><name>x</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator> <call><name>HAS_FF_AROUND</name><argument_list>(<argument><expr><name>cmkpU</name></expr></argument>, <argument><expr><name>cmk_linesizeUV</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><name>cmkp</name><operator>)</operator><index>[<expr><name>x</name></expr>]</index> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><name>cmkpn</name><operator>)</operator><index>[<expr><name>x</name></expr>]</index> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>y</name><operator>&amp;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><name>cmkpp</name><operator>)</operator><index>[<expr><name>x</name></expr>]</index> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator><name>cmkpnn</name><operator>)</operator><index>[<expr><name>x</name></expr>]</index> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>blockx</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>blocky</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xhalf</name> <init>= <expr><name>blockx</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yhalf</name> <init>= <expr><name>blocky</name><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmk_linesize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>cmkp</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>cmk_linesize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>height</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xblocks</name> <init>= <expr><operator>(</operator><operator>(</operator><name>width</name><operator>+</operator><name>xhalf</name><operator>)</operator><operator>/</operator><name>blockx</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>xblocks4</name> <init>= <expr><name>xblocks</name><operator>&lt;&lt;</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>yblocks</name> <init>= <expr><operator>(</operator><operator>(</operator><name>height</name><operator>+</operator><name>yhalf</name><operator>)</operator><operator>/</operator><name>blocky</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>c_array</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>c_array</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>arraysize</name> <init>= <expr><operator>(</operator><name>xblocks</name><operator>*</operator><name>yblocks</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>heighta</name> <init>= <expr><operator>(</operator><name>height</name><operator>/</operator><operator>(</operator><name>blocky</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>*</operator><operator>(</operator><name>blocky</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>widtha</name> <init>= <expr><operator>(</operator><name>width</name> <operator>/</operator><operator>(</operator><name>blockx</name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>*</operator><operator>(</operator><name>blockx</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>heighta</name> <operator>==</operator> <name>height</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>heighta</name> <operator>=</operator> <name>height</name> <operator>-</operator> <name>yhalf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>c_array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arraysize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c_array</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C_ARRAY_ADD</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const int box1 = (x / blockx) * 4; const int box2 = ((x + xhalf) / blockx) * 4; c_array[temp1 + box1 ] += v; c_array[temp1 + box2 + 1] += v; c_array[temp2 + box1 + 2] += v; c_array[temp2 + box2 + 3] += v; } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERTICAL_HALF</name><parameter_list>(<parameter><type><name>y_start</name></type></parameter>, <parameter><type><name>y_end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { for (y = y_start; y &lt; y_end; y++) { const int temp1 = (y / blocky) * xblocks4; const int temp2 = ((y + yhalf) / blocky) * xblocks4; for (x = 0; x &lt; width; x++) if (cmkp[x - cmk_linesize] == 0xff &amp;&amp; cmkp[x ] == 0xff &amp;&amp; cmkp[x + cmk_linesize] == 0xff) C_ARRAY_ADD(1); cmkp += cmk_linesize; } } while (0)</cpp:value></cpp:define>












<expr_stmt><expr><call><name>VERTICAL_HALF</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>yhalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <name>yhalf</name></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>heighta</name></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <name>yhalf</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>temp1</name> <init>= <expr><operator>(</operator><name>y</name> <operator>/</operator> <name>blocky</name><operator>)</operator> <operator>*</operator> <name>xblocks4</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>temp2</name> <init>= <expr><operator>(</operator><operator>(</operator><name>y</name> <operator>+</operator> <name>yhalf</name><operator>)</operator> <operator>/</operator> <name>blocky</name><operator>)</operator> <operator>*</operator> <name>xblocks4</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>widtha</name></expr>;</condition> <incr><expr><name>x</name> <operator>+=</operator> <name>xhalf</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>cmkp_tmp</name> <init>= <expr><name>cmkp</name> <operator>+</operator> <name>x</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>, <decl><type ref="prev"/><name>v</name></decl>, <decl><type ref="prev"/><name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>yhalf</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <name>xhalf</name></expr>;</condition> <incr><expr><name>v</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>cmkp_tmp</name><index>[<expr><name>v</name> <operator>-</operator> <name>cmk_linesize</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator>
<name><name>cmkp_tmp</name><index>[<expr><name>v</name></expr> ]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator>
<name><name>cmkp_tmp</name><index>[<expr><name>v</name> <operator>+</operator> <name>cmk_linesize</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>cmkp_tmp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>sum</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>C_ARRAY_ADD</name><argument_list>(<argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>widtha</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>cmkp_tmp</name> <init>= <expr><name>cmkp</name> <operator>+</operator> <name>x</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>u</name></decl>, <decl><type ref="prev"/><name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>yhalf</name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cmkp_tmp</name><index>[<expr><operator>-</operator><name>cmk_linesize</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator>
<name><name>cmkp_tmp</name><index>[ <expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator>
<name><name>cmkp_tmp</name><index>[ <expr><name>cmk_linesize</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cmkp_tmp</name> <operator>+=</operator> <name>cmk_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>sum</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>C_ARRAY_ADD</name><argument_list>(<argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>cmkp</name> <operator>+=</operator> <name>cmk_linesize</name> <operator>*</operator> <name>yhalf</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>VERTICAL_HALF</name><argument_list>(<argument><expr><name>heighta</name></expr></argument>, <argument><expr><name>height</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>arraysize</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>c_array</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&gt;</operator> <name>max_v</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_v</name> <operator>=</operator> <name><name>c_array</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block>
<return>return <expr><name>max_v</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>build_abs_diff_mask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>prvp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prv_linesize</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>nxtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nxt_linesize</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>tbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tbuf_linesize</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prvp</name> <operator>-=</operator> <name>prv_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtp</name> <operator>-=</operator> <name>nxt_linesize</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name></expr>;</condition> <incr><expr><name>y</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tbuffer</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <call><name>FFABS</name><argument_list>(<argument><expr><name><name>prvp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>-</operator> <name><name>nxtp</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>prvp</name> <operator>+=</operator> <name>prv_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtp</name> <operator>+=</operator> <name>nxt_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tbuffer</name> <operator>+=</operator> <name>tbuf_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>build_diff_map</name><parameter_list>(<parameter><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>prvp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prv_linesize</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>nxtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nxt_linesize</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dstp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dst_linesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>plane</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>u</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tpitch</name> <init>= <expr><ternary><condition><expr><name>plane</name></expr> ?</condition><then> <expr><name><name>fm</name><operator>-&gt;</operator><name>tpitchuv</name></name></expr> </then><else>: <expr><name><name>fm</name><operator>-&gt;</operator><name>tpitchy</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name> <operator>+</operator> <name>tpitch</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>build_abs_diff_mask</name><argument_list>(<argument><expr><name>prvp</name></expr></argument>, <argument><expr><name>prv_linesize</name></expr></argument>, <argument><expr><name>nxtp</name></expr></argument>, <argument><expr><name>nxt_linesize</name></expr></argument>,
<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name></expr></argument>, <argument><expr><name>tpitch</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name><operator>&gt;&gt;</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name> <operator>-</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>width</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <name><name>dp</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>u</name> <operator>=</operator> <name>x</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>x</name><operator>+</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>dp</name><index>[<expr><name>u</name><operator>-</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>dp</name><index>[<expr><name>u</name></expr> ]</index></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>dp</name><index>[<expr><name>u</name><operator>+</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dstp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>lower</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>u</name> <operator>=</operator> <name>x</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>x</name><operator>+</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><index>[<expr><name>u</name><operator>-</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><index>[<expr><name>u</name></expr> ]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><index>[<expr><name>u</name><operator>+</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>lower</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>upper</name> <operator>&amp;&amp;</operator> <name>lower</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dstp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>upper2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>lower2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>x</name><operator>-</operator><literal type="number">4</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><name>u</name><operator>-</operator><literal type="number">2</literal><operator>*</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>upper2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name><name>dp</name><index>[<expr><name>u</name><operator>-</operator> <name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name><name>dp</name><index>[<expr><name>u</name><operator>+</operator> <name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lower</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>height</name><operator>-</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>dp</name><index>[<expr><name>u</name><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>tpitch</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lower2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>upper</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lower</name> <operator>||</operator> <name>upper2</name><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>lower</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>upper</name> <operator>||</operator> <name>lower2</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dstp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dstp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>dp</name> <operator>+=</operator> <name>tpitch</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dstp</name> <operator>+=</operator> <name>dst_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<enum>enum <block>{ <decl><name>mP</name></decl>, <decl><name>mC</name></decl>, <decl><name>mN</name></decl>, <decl><name>mB</name></decl>, <decl><name>mU</name></decl> }</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_field_base</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>match</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>-</operator> <name>field</name></expr> </then><else>: <expr><literal type="number">1</literal> <operator>+</operator> <name>field</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>select_frame</name><parameter_list>(<parameter><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>match</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>match</name> <operator>==</operator> <name>mP</name> <operator>||</operator> <name>match</name> <operator>==</operator> <name>mB</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>match</name> <operator>==</operator> <name>mN</name> <operator>||</operator> <name>match</name> <operator>==</operator> <name>mU</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_fields</name><parameter_list>(<parameter><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>match1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>match2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>plane</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>accumPc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>accumPm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>accumPml</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>accumNc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>accumNm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>accumNml</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>norm1</name></decl>, <decl><type ref="prev"/><name>norm2</name></decl>, <decl><type ref="prev"/><name>mtn1</name></decl>, <decl><type ref="prev"/><name>mtn2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>mr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>plane</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>plane</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name><name>fm</name><operator>-&gt;</operator><name>mchroma</name></name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</condition> <incr><expr><name>plane</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>fbase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>mapp</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>map_data</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>map_linesize</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>map_linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>srcp</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>src_linesize</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>srcf_linesize</name> <init>= <expr><name>src_linesize</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prv_linesize</name></decl>, <decl><type ref="prev"/><name>nxt_linesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prvf_linesize</name></decl>, <decl><type ref="prev"/><name>nxtf_linesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>width</name> <init>= <expr><call><name>get_width</name> <argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>height</name> <init>= <expr><call><name>get_height</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y0a</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>y0</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>plane</name></expr> ?</condition><then> <expr><name><name>fm</name><operator>-&gt;</operator><name>vsub</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>y1a</name> <init>= <expr><name><name>fm</name><operator>-&gt;</operator><name>y1</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><ternary><condition><expr><name>plane</name></expr> ?</condition><then> <expr><name><name>fm</name><operator>-&gt;</operator><name>vsub</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>startx</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>plane</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">8</literal> <operator>&gt;&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>hsub</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stopx</name> <init>= <expr><name>width</name> <operator>-</operator> <name>startx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>srcpf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>srcf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>srcnf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>prvpf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prvnf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nxtpf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nxtnf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fill_buf</name><argument_list>(<argument><expr><name>mapp</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>map_linesize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>fbase</name> <operator>=</operator> <call><name>get_field_base</name><argument_list>(<argument><expr><name>match1</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>srcf</name> <operator>=</operator> <name>srcp</name> <operator>+</operator> <operator>(</operator><name>fbase</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>src_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcpf</name> <operator>=</operator> <name>srcf</name> <operator>-</operator> <name>srcf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcnf</name> <operator>=</operator> <name>srcf</name> <operator>+</operator> <name>srcf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mapp</name> <operator>=</operator> <name>mapp</name> <operator>+</operator> <name>fbase</name> <operator>*</operator> <name>map_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>select_frame</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>match1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prv_linesize</name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prvf_linesize</name> <operator>=</operator> <name>prv_linesize</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prvpf</name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name>fbase</name> <operator>*</operator> <name>prv_linesize</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>prvnf</name> <operator>=</operator> <name>prvpf</name> <operator>+</operator> <name>prvf_linesize</name></expr>;</expr_stmt> 


<expr_stmt><expr><name>fbase</name> <operator>=</operator> <call><name>get_field_base</name><argument_list>(<argument><expr><name>match2</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>select_frame</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>match2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nxt_linesize</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtf_linesize</name> <operator>=</operator> <name>nxt_linesize</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtpf</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name>fbase</name> <operator>*</operator> <name>nxt_linesize</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>nxtnf</name> <operator>=</operator> <name>nxtpf</name> <operator>+</operator> <name>nxtf_linesize</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>map_linesize</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>match1</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>field</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>match1</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>field</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>build_diff_map</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>prvpf</name></expr></argument>, <argument><expr><name>prvf_linesize</name></expr></argument>, <argument><expr><name>nxtpf</name></expr></argument>, <argument><expr><name>nxtf_linesize</name></expr></argument>,
<argument><expr><name>mapp</name></expr></argument>, <argument><expr><name>map_linesize</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>build_diff_map</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>prvnf</name></expr></argument>, <argument><expr><name>prvf_linesize</name></expr></argument>, <argument><expr><name>nxtnf</name></expr></argument>, <argument><expr><name>nxtf_linesize</name></expr></argument>,
<argument><expr><name>mapp</name> <operator>+</operator> <name>map_linesize</name></expr></argument>, <argument><expr><name>map_linesize</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>y</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>y</name> <operator>&lt;</operator> <name>height</name> <operator>-</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>y0a</name> <operator>==</operator> <name>y1a</name> <operator>||</operator> <name><name>y</name> <argument_list type="generic">&lt; <argument><expr><name>y0a</name> <operator>||</operator> <name>y</name></expr></argument> &gt;</argument_list></name> <name>y1a</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>x</name> <operator>=</operator> <name>startx</name></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>stopx</name></expr>;</condition> <incr><expr><name>x</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp1</name> <operator>=</operator> <name><name>srcpf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>srcf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name><name>srcnf</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>temp2</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><name><name>prvpf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>+</operator> <name><name>prvnf</name><index>[<expr><name>x</name></expr>]</index></name><operator>)</operator> <operator>-</operator> <name>temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp2</name> <operator>&gt;</operator> <literal type="number">23</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumPc</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>temp2</name> <operator>&gt;</operator> <literal type="number">42</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumPm</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">4</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumPml</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>temp2</name> <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><name><name>nxtpf</name><index>[<expr><name>x</name></expr>]</index></name> <operator>+</operator> <name><name>nxtnf</name><index>[<expr><name>x</name></expr>]</index></name><operator>)</operator> <operator>-</operator> <name>temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp2</name> <operator>&gt;</operator> <literal type="number">23</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumNc</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>temp2</name> <operator>&gt;</operator> <literal type="number">42</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumNm</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name></expr>]</index></name><operator>&amp;</operator><literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>mapp</name><index>[<expr><name>x</name> <operator>+</operator> <name>map_linesize</name></expr>]</index></name><operator>&amp;</operator><literal type="number">4</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>accumNml</name> <operator>+=</operator> <name>temp2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prvpf</name> <operator>+=</operator> <name>prvf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prvnf</name> <operator>+=</operator> <name>prvf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcpf</name> <operator>+=</operator> <name>srcf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcf</name> <operator>+=</operator> <name>srcf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcnf</name> <operator>+=</operator> <name>srcf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtpf</name> <operator>+=</operator> <name>nxtf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nxtnf</name> <operator>+=</operator> <name>nxtf_linesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mapp</name> <operator>+=</operator> <name>map_linesize</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>accumPm</name> <operator>&lt;</operator> <literal type="number">500</literal> <operator>&amp;&amp;</operator> <name><name>accumNm</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">500</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>accumPml</name> <operator>&gt;=</operator> <literal type="number">500</literal> <operator>||</operator> <name>accumNml</name> <operator>&gt;=</operator> <literal type="number">500</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<name>FFMAX</name><operator>(</operator><name>accumPml</name>,<name>accumNml</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal><operator>*</operator><call><name>FFMIN</name><argument_list>(<argument><expr><name>accumPml</name></expr></argument>,<argument><expr><name>accumNml</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>accumPm</name> <operator>=</operator> <name>accumPml</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumNm</name> <operator>=</operator> <name>accumNml</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>norm1</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>accumPc</name> <operator>/</operator> <literal type="number">6.0f</literal><operator>)</operator> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>norm2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>accumNc</name> <operator>/</operator> <literal type="number">6.0f</literal><operator>)</operator> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mtn1</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>accumPm</name> <operator>/</operator> <literal type="number">6.0f</literal><operator>)</operator> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mtn2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>accumNm</name> <operator>/</operator> <literal type="number">6.0f</literal><operator>)</operator> <operator>+</operator> <literal type="number">0.5f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>norm1</name></expr></argument>,<argument><expr><name>norm2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>norm1</name></expr></argument>,<argument><expr><name>norm2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>mtn1</name></expr></argument>, <argument><expr><name>mtn2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>mtn1</name></expr></argument>, <argument><expr><name>mtn2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><name>mtn1</name></expr></argument>, <argument><expr><name>mtn2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>float</name><operator>)</operator><call><name>FFMAX</name><argument_list>(<argument><expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>norm1</name></expr></argument>,<argument><expr><name>norm2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>mtn1</name> <operator>&gt;=</operator> <literal type="number">500</literal> <operator>||</operator> <name>mtn2</name> <operator>&gt;=</operator> <literal type="number">500</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mtn1</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>mtn2</name><operator>*</operator><literal type="number">1</literal> <operator>||</operator> <name>mtn2</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>mtn1</name><operator>*</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>mtn1</name> <operator>&gt;=</operator> <literal type="number">1000</literal> <operator>||</operator> <name>mtn2</name> <operator>&gt;=</operator> <literal type="number">1000</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mtn1</name><operator>*</operator><literal type="number">3</literal> <operator>&lt;</operator> <name>mtn2</name><operator>*</operator><literal type="number">2</literal> <operator>||</operator> <name>mtn2</name><operator>*</operator><literal type="number">3</literal> <operator>&lt;</operator> <name>mtn1</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>mtn1</name> <operator>&gt;=</operator> <literal type="number">2000</literal> <operator>||</operator> <name>mtn2</name> <operator>&gt;=</operator> <literal type="number">2000</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mtn1</name><operator>*</operator><literal type="number">5</literal> <operator>&lt;</operator> <name>mtn2</name><operator>*</operator><literal type="number">4</literal> <operator>||</operator> <name>mtn2</name><operator>*</operator><literal type="number">5</literal> <operator>&lt;</operator> <name>mtn1</name><operator>*</operator><literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name>mtn1</name> <operator>&gt;=</operator> <literal type="number">4000</literal> <operator>||</operator> <name>mtn2</name> <operator>&gt;=</operator> <literal type="number">4000</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>c2</name> <operator>&gt;</operator> <name>c1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><name>mtn1</name> <operator>&gt;</operator> <name>mtn2</name></expr> ?</condition><then> <expr><name>match2</name></expr> </then><else>: <expr><name>match1</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>mr</name> <operator>&gt;</operator> <literal type="number">0.005</literal> <operator>&amp;&amp;</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>mtn1</name></expr></argument>, <argument><expr><name>mtn2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">150</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mtn1</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>mtn2</name><operator>*</operator><literal type="number">1</literal> <operator>||</operator> <name>mtn2</name><operator>*</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>mtn1</name><operator>*</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><name>mtn1</name> <operator>&gt;</operator> <name>mtn2</name></expr> ?</condition><then> <expr><name>match2</name></expr> </then><else>: <expr><name>match1</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><name>norm1</name> <operator>&gt;</operator> <name>norm2</name></expr> ?</condition><then> <expr><name>match2</name></expr> </then><else>: <expr><name>match1</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_fields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>plane</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>plane</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>plane</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr>;</condition> <incr><expr><name>plane</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>plane_h</name> <init>= <expr><call><name>get_height</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nb_copy_fields</name> <init>= <expr><operator>(</operator><name>plane_h</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>field</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>plane_h</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_image_copy_plane</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name>field</name><operator>*</operator><name><name>dst</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>src</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>+</operator> <name>field</name><operator>*</operator><name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><name>plane</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>get_width</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>plane</name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>fm</name><operator>-&gt;</operator><name>bpc</name></name></expr></argument>, <argument><expr><name>nb_copy_fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>create_weave_frame</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>prv</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>nxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name> <operator>==</operator> <name>mC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>av_frame_clone</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>ff_get_video_buffer</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_frame_copy_props</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>mP</name></expr>:</case> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>-</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>prv</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>mN</name></expr>:</case> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>-</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>nxt</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>mB</name></expr>:</case> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>prv</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>-</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>mU</name></expr>:</case> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>copy_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>nxt</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>-</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>checkmm</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>combs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m2</name></decl></parameter>,
<parameter><decl><type><name>AVFrame</name> <modifier>*</modifier><modifier>*</modifier></type><name>gen_frames</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_COMB</name><parameter_list>(<parameter><type><name>mid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (combs[mid] &lt; 0) { if (!gen_frames[mid]) gen_frames[mid] = create_weave_frame(ctx, mid, field, fm-&gt;prv, fm-&gt;src, fm-&gt;nxt); combs[mid] = calc_combed_score(fm, gen_frames[mid]); } } while (0)</cpp:value></cpp:define>








<expr_stmt><expr><call><name>LOAD_COMB</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LOAD_COMB</name><argument_list>(<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combs</name><index>[<expr><name>m2</name></expr>]</index></name> <operator>*</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name><name>combs</name><index>[<expr><name>m1</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name><name>combs</name><index>[<expr><name>m2</name></expr>]</index></name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name><name>combs</name><index>[<expr><name>m1</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>combs</name><index>[<expr><name>m1</name></expr>]</index></name> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>combpel</name></name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>abs</name><argument_list>(<argument><expr><name><name>combs</name><index>[<expr><name>m2</name></expr>]</index></name> <operator>-</operator> <name><name>combs</name><index>[<expr><name>m1</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">30</literal> <operator>&amp;&amp;</operator> <name><name>combs</name><index>[<expr><name>m2</name></expr>]</index></name> <operator>&lt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>combpel</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>m2</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>m1</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>fxo0m</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>mP</name></expr>, <expr><name>mC</name></expr>, <expr><name>mN</name></expr>, <expr><name>mB</name></expr>, <expr><name>mU</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>fxo1m</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>mN</name></expr>, <expr><name>mC</name></expr>, <expr><name>mP</name></expr>, <expr><name>mU</name></expr>, <expr><name>mB</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>combs</name><index>[]</index></name> <init>= <expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>, <decl><type ref="prev"/><name>field</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>match</name></decl>, <decl><type ref="prev"/><name>sc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>fxo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name><name>gen_frames</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLIDING_FRAME_WINDOW</name><parameter_list>(<parameter><type><name>prv</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>nxt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (prv != src) av_frame_free(&amp;prv); prv = src; src = nxt; if (in) nxt = in; if (!prv) prv = src; if (!prv) return 0; av_assert0(prv &amp;&amp; src &amp;&amp; nxt); } while (0)</cpp:value></cpp:define>












<if_stmt><if>if <condition>(<expr><call><name>FF_INLINK_IDX</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INPUT_MAIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIDING_FRAME_WINDOW</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIDING_FRAME_WINDOW</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv2</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src2</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>=</operator> <name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> <operator>=</operator> <name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>order</name> <operator>=</operator> <ternary><condition><expr><name><name>fm</name><operator>-&gt;</operator><name>order</name></name> <operator>!=</operator> <name>FM_PARITY_AUTO</name></expr> ?</condition><then> <expr><name><name>fm</name><operator>-&gt;</operator><name>order</name></name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>in</name><operator>-&gt;</operator><name>interlaced_frame</name></name></expr> ?</condition><then> <expr><name><name>in</name><operator>-&gt;</operator><name>top_field_first</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>field</name> <operator>=</operator> <ternary><condition><expr><name><name>fm</name><operator>-&gt;</operator><name>field</name></name> <operator>!=</operator> <name>FM_PARITY_AUTO</name></expr> ?</condition><then> <expr><name><name>fm</name><operator>-&gt;</operator><name>field</name></name></expr> </then><else>: <expr><name>order</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>order</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>order</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>field</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>field</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fxo</name> <operator>=</operator> <ternary><condition><expr><name>field</name> <operator>^</operator> <name>order</name></expr> ?</condition><then> <expr><name>fxo1m</name></expr> </then><else>: <expr><name>fxo0m</name></expr></else></ternary></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>combdbg</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>combs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>mN</name> <operator>&amp;&amp;</operator> <name><name>fm</name><operator>-&gt;</operator><name>combdbg</name></name> <operator>==</operator> <name>COMBDBG_PCN</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>gen_frames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>create_weave_frame</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gen_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>combs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>calc_combed_score</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name><name>gen_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"COMBS: %3d %3d %3d %3d %3d\n"</literal></expr></argument>,
<argument><expr><name><name>combs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>gen_frames</name><index>[<expr><name>mC</name></expr>]</index></name> <operator>=</operator> <call><name>av_frame_clone</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gen_frames</name><index>[<expr><name>mC</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>compare_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mC</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mP</name></expr>]</index></name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>MODE_PCN</name> <operator>||</operator> <name><name>fm</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>MODE_PCN_UB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>compare_fields</name><argument_list>(<argument><expr><name>fm</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mN</name></expr>]</index></name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>combmatch</name></name> <operator>==</operator> <name>COMBMATCH_SC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>lastn</name></name> <operator>==</operator> <name><name>outlink</name><operator>-&gt;</operator><name>frame_count_in</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>lastscdiff</name></name> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>scthresh</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>luma_abs_diff</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>scthresh</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>lastn</name></name> <operator>=</operator> <name><name>outlink</name><operator>-&gt;</operator><name>frame_count_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>lastscdiff</name></name> <operator>=</operator> <call><name>luma_abs_diff</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sc</name> <operator>=</operator> <name><name>fm</name><operator>-&gt;</operator><name>lastscdiff</name></name> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>scthresh</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>combmatch</name></name> <operator>==</operator> <name>COMBMATCH_FULL</name> <operator>||</operator> <operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>combmatch</name></name> <operator>==</operator> <name>COMBMATCH_SC</name> <operator>&amp;&amp;</operator> <name>sc</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MODE_PC</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><ternary><condition><expr><name>match</name> <operator>==</operator> <name><name>fxo</name><index>[<expr><name>mP</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>fxo</name><index>[<expr><name>mC</name></expr>]</index></name></expr> </then><else>: <expr><name><name>fxo</name><index>[<expr><name>mP</name></expr>]</index></name></expr></else></ternary></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MODE_PC_N</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mN</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MODE_PC_U</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mU</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MODE_PC_N_UB</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mN</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mU</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mB</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MODE_PCN</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><ternary><condition><expr><name>match</name> <operator>==</operator> <name><name>fxo</name><index>[<expr><name>mP</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>fxo</name><index>[<expr><name>mC</name></expr>]</index></name></expr> </then><else>: <expr><name><name>fxo</name><index>[<expr><name>mP</name></expr>]</index></name></expr></else></ternary></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MODE_PCN_UB</name></expr>:</case>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mU</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>checkmm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>combs</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>fxo</name><index>[<expr><name>mB</name></expr>]</index></name></expr></argument>, <argument><expr><name>gen_frames</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>create_weave_frame</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv2</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src2</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gen_frames</name><index>[<expr><name>match</name></expr>]</index></name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>create_weave_frame</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name><name>gen_frames</name><index>[<expr><name>match</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gen_frames</name><index>[<expr><name>match</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>interlaced_frame</name></name> <operator>=</operator> <name><name>combs</name><index>[<expr><name>match</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>fm</name><operator>-&gt;</operator><name>combpel</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>-&gt;</operator><name>interlaced_frame</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Frame #%"</literal><name>PRId64</name><literal type="string">" at %s is still interlaced\n"</literal></expr></argument>,
<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>frame_count_in</name></name></expr></argument>, <argument><expr><call><name>av_ts2timestr</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>pts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>inlink</name><operator>-&gt;</operator><name>time_base</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>top_field_first</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"SC:%d | COMBS: %3d %3d %3d %3d %3d (combpel=%d)"</literal>
<literal type="string">" match=%d combed=%s\n"</literal></expr></argument>, <argument><expr><name>sc</name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>combpel</name></name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>dst</name><operator>-&gt;</operator><name>interlaced_frame</name></name></expr> ?</condition><then> <expr><literal type="string">"YES"</literal></expr> </then><else>: <expr><literal type="string">"NO"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fail</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>FF_ARRAY_ELEMS</name><argument_list>(<argument><expr><name>gen_frames</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gen_frames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>activate</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>pts</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FF_FILTER_FORWARD_STATUS_BACK_ALL</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_inlink_consume_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frame</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_inlink_consume_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frame</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>ff_inlink_acknowledge_status</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>AVERROR_EOF</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>eof</name></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>INPUT_MAIN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ff_outlink_set_status</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>pts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name> <operator>&amp;&amp;</operator> <call><name>ff_inlink_acknowledge_status</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>AVERROR_EOF</name></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>eof</name></name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>INPUT_CLEANSRC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ff_outlink_set_status</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>pts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ff_outlink_frame_wanted</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_inlink_request_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>got_frame</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ff_inlink_request_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>query_formats</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>pix_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>AV_PIX_FMT_YUV444P</name></expr>, <expr><name>AV_PIX_FMT_YUV422P</name></expr>, <expr><name>AV_PIX_FMT_YUV420P</name></expr>,
<expr><name>AV_PIX_FMT_YUV411P</name></expr>, <expr><name>AV_PIX_FMT_YUV410P</name></expr>,
<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>unproc_pix_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>AV_PIX_FMT_YUV410P</name></expr>, <expr><name>AV_PIX_FMT_YUV411P</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P</name></expr>, <expr><name>AV_PIX_FMT_YUV422P</name></expr>,
<expr><name>AV_PIX_FMT_YUV440P</name></expr>, <expr><name>AV_PIX_FMT_YUV444P</name></expr>,
<expr><name>AV_PIX_FMT_YUVJ420P</name></expr>, <expr><name>AV_PIX_FMT_YUVJ422P</name></expr>,
<expr><name>AV_PIX_FMT_YUVJ440P</name></expr>, <expr><name>AV_PIX_FMT_YUVJ444P</name></expr>,
<expr><name>AV_PIX_FMT_YUVJ411P</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P9</name></expr>, <expr><name>AV_PIX_FMT_YUV422P9</name></expr>, <expr><name>AV_PIX_FMT_YUV444P9</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P10</name></expr>, <expr><name>AV_PIX_FMT_YUV422P10</name></expr>, <expr><name>AV_PIX_FMT_YUV444P10</name></expr>,
<expr><name>AV_PIX_FMT_YUV440P10</name></expr>,
<expr><name>AV_PIX_FMT_YUV444P12</name></expr>, <expr><name>AV_PIX_FMT_YUV422P12</name></expr>, <expr><name>AV_PIX_FMT_YUV420P12</name></expr>,
<expr><name>AV_PIX_FMT_YUV440P12</name></expr>,
<expr><name>AV_PIX_FMT_YUV444P14</name></expr>, <expr><name>AV_PIX_FMT_YUV422P14</name></expr>, <expr><name>AV_PIX_FMT_YUV420P14</name></expr>,
<expr><name>AV_PIX_FMT_YUV420P16</name></expr>, <expr><name>AV_PIX_FMT_YUV422P16</name></expr>, <expr><name>AV_PIX_FMT_YUV444P16</name></expr>,
<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilterFormats</name> <modifier>*</modifier></type><name>fmts_list</name> <init>= <expr><call><name>ff_make_format_list</name><argument_list>(<argument><expr><name>pix_fmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmts_list</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ff_set_common_formats</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fmts_list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_formats_ref</name><argument_list>(<argument><expr><name>fmts_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_MAIN</name></expr>]</index></name><operator>-&gt;</operator><name>out_formats</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fmts_list</name> <operator>=</operator> <call><name>ff_make_format_list</name><argument_list>(<argument><expr><name>unproc_pix_fmts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmts_list</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_formats_ref</name><argument_list>(<argument><expr><name>fmts_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>in_formats</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_formats_ref</name><argument_list>(<argument><expr><name>fmts_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><name>INPUT_CLEANSRC</name></expr>]</index></name><operator>-&gt;</operator><name>out_formats</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_input</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>pix_desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>h</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>scthresh</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>w</name> <operator>*</operator> <name>h</name> <operator>*</operator> <literal type="number">255.0</literal> <operator>*</operator> <name><name>fm</name><operator>-&gt;</operator><name>scthresh_flt</name></name><operator>)</operator> <operator>/</operator> <literal type="number">100.0</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>av_image_alloc</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>map_data</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>map_linesize</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name>ret</name> <operator>=</operator> <call><name>av_image_alloc</name><argument_list>(<argument><expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name></name></expr></argument>, <argument><expr><name><name>fm</name><operator>-&gt;</operator><name>cmask_linesize</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>hsub</name></name> <operator>=</operator> <name><name>pix_desc</name><operator>-&gt;</operator><name>log2_chroma_w</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>vsub</name></name> <operator>=</operator> <name><name>pix_desc</name><operator>-&gt;</operator><name>log2_chroma_h</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>tpitchy</name></name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>tpitchuv</name></name> <operator>=</operator> <call><name>FFALIGN</name><argument_list>(<argument><expr><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name> <operator>=</operator> <call><name>av_calloc</name><argument_list>(<argument><expr><operator>(</operator><name>h</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <operator>*</operator> <name><name>fm</name><operator>-&gt;</operator><name>tpitchy</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>c_array</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>w</name> <operator>+</operator> <name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<operator>(</operator><operator>(</operator><operator>(</operator><name>h</name> <operator>+</operator> <name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name><operator>/</operator><literal type="number">2</literal><operator>)</operator><operator>/</operator><name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>fm</name><operator>-&gt;</operator><name>c_array</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name> <operator>||</operator> <operator>!</operator><name><name>fm</name><operator>-&gt;</operator><name>c_array</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>fieldmatch_init</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterPad</name></type> <name>pad</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <call><name>av_strdup</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_input</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pad</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_insert_inpad</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>INPUT_MAIN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pad</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pad</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pad</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>av_strdup</name><argument_list>(<argument><expr><literal type="string">"clean_src"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pad</name><operator>.</operator><name>config_props</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pad</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_insert_inpad</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>INPUT_CLEANSRC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pad</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pad</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"blockx and blocky settings must be power of two\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>combpel</name></name> <operator>&gt;</operator> <name><name>fm</name><operator>-&gt;</operator><name>blockx</name></name> <operator>*</operator> <name><name>fm</name><operator>-&gt;</operator><name>blocky</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Combed pixel should not be larger than blockx x blocky\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>void</name></type> <name>fieldmatch_uninit</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>prv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>nxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>prv2</name></name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>src2</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>prv2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fm</name><operator>-&gt;</operator><name>nxt2</name></name> <operator>!=</operator> <name><name>fm</name><operator>-&gt;</operator><name>src2</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>nxt2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>src</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>src2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>map_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>cmask_data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>tbuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fm</name><operator>-&gt;</operator><name>c_array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nb_inputs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>input_pads</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_output</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>outlink</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldMatchContext</name> <modifier>*</modifier></type><name>fm</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name> <init>=
<expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><ternary><condition><expr><name><name>fm</name><operator>-&gt;</operator><name>ppsrc</name></name></expr> ?</condition><then> <expr><name>INPUT_CLEANSRC</name></expr> </then><else>: <expr><name>INPUT_MAIN</name></expr></else></ternary></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fm</name><operator>-&gt;</operator><name>bpc</name></name> <operator>=</operator> <operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>time_base</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>time_base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>sample_aspect_ratio</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>sample_aspect_ratio</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>frame_rate</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>frame_rate</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>fieldmatch_outputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_output</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_vf_fieldmatch</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"fieldmatch"</literal></expr>,
<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Field matching for inverse telecine."</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,
<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FieldMatchContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>fieldmatch_init</name></expr>,
<expr><operator>.</operator><name>activate</name> <operator>=</operator> <name>activate</name></expr>,
<expr><operator>.</operator><name>uninit</name> <operator>=</operator> <name>fieldmatch_uninit</name></expr>,
<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>NULL</name></expr>,
<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>fieldmatch_outputs</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>fieldmatch_class</name></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_DYNAMIC_INPUTS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
