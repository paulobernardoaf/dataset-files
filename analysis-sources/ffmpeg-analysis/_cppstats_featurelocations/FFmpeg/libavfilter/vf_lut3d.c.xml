<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavfilter\vf_lut3d.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/intreadwrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/pixdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avfilter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"drawutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"formats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"framesync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"video.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>A</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<enum>enum <name>interp_mode</name> <block>{
<decl><name>INTERPOLATE_NEAREST</name></decl>,
<decl><name>INTERPOLATE_TRILINEAR</name></decl>,
<decl><name>INTERPOLATE_TETRAHEDRAL</name></decl>,
<decl><name>NB_INTERP_MODE</name></decl>
}</block>;</enum>

<struct>struct <name>rgbvec</name> <block>{
<decl_stmt><decl><type><name>float</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
}</block>;</struct>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LEVEL</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>LUT3DContext</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>interpolation</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>rgba_map</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>avfilter_action_func</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name></type> <name>scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>lut</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lutsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lutsize2</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HALDCLUT_FILTER</name></expr></cpp:if>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>clut_rgba_map</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clut_step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clut_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clut_planar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>clut_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FFFrameSync</name></type> <name>fs</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>LUT3DContext</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ThreadData</name> <block>{
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl>, <modifier>*</modifier><name>out</name>;</decl_stmt>
}</block></struct></type> <name>ThreadData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(LUT3DContext, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS</name></cpp:macro> <cpp:value>AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMON_OPTIONS</name></cpp:macro> <cpp:value>{ "interp", "select interpolation mode", OFFSET(interpolation), AV_OPT_TYPE_INT, {.i64=INTERPOLATE_TETRAHEDRAL}, 0, NB_INTERP_MODE-1, FLAGS, "interp_mode" }, { "nearest", "use values from the nearest defined points", 0, AV_OPT_TYPE_CONST, {.i64=INTERPOLATE_NEAREST}, INT_MIN, INT_MAX, FLAGS, "interp_mode" }, { "trilinear", "interpolate values using the 8 points defining a cube", 0, AV_OPT_TYPE_CONST, {.i64=INTERPOLATE_TRILINEAR}, INT_MIN, INT_MAX, FLAGS, "interp_mode" }, { "tetrahedral", "interpolate values using a tetrahedron", 0, AV_OPT_TYPE_CONST, {.i64=INTERPOLATE_TETRAHEDRAL}, INT_MIN, INT_MAX, FLAGS, "interp_mode" }, { NULL }</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>lerpf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>v0</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>v0</name> <operator>+</operator> <operator>(</operator><name>v1</name> <operator>-</operator> <name>v0</name><operator>)</operator> <operator>*</operator> <name>f</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>lerp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>v0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name></type> <name>v</name> <init>= <expr><block>{
<expr><call><name>lerpf</name><argument_list>(<argument><expr><name><name>v0</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>lerpf</name><argument_list>(<argument><expr><name><name>v0</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name><name>v1</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>, <macro><name>lerpf</name><argument_list>(<argument>v0-&gt;b</argument>, <argument>v1-&gt;b</argument>, <argument>f</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEAR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)((x) + .5))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FFMIN((int)(x) + 1, lut3d-&gt;lutsize - 1))</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>interp_nearest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><call><name>NEAR</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name> <operator>+</operator> <call><name>NEAR</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>+</operator> <call><name>NEAR</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>interp_trilinear</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lutsize2</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lutsize</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>prev</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name>PREV</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>PREV</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>PREV</name><argument_list>(<argument>s-&gt;b</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>next</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name>NEXT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NEXT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>NEXT</name><argument_list>(<argument>s-&gt;b</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>d</name> <init>= <expr><block>{<expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>, <expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <expr><name><name>s</name><operator>-&gt;</operator><name>b</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c000</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c001</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c010</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c011</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c100</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c101</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c110</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c111</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c00</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c000</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c100</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c10</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c010</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c110</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c01</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c001</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c101</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c11</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c011</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c111</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c0</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c00</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c10</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>g</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c1</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c01</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c11</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>g</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c</name> <init>= <expr><call><name>lerp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name><name>d</name><operator>.</operator><name>b</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>interp_tetrahedral</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lutsize2</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lutsize</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>prev</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name>PREV</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>PREV</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>PREV</name><argument_list>(<argument>s-&gt;b</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>next</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name>NEXT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NEXT</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>NEXT</name><argument_list>(<argument>s-&gt;b</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>d</name> <init>= <expr><block>{<expr><name><name>s</name><operator>-&gt;</operator><name>r</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>, <expr><name><name>s</name><operator>-&gt;</operator><name>g</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>, <expr><name><name>s</name><operator>-&gt;</operator><name>b</name></name> <operator>-</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c000</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c111</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name></type> <name>c</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>r</name></name> <operator>&gt;</operator> <name><name>d</name><operator>.</operator><name>g</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>g</name></name> <operator>&gt;</operator> <name><name>d</name><operator>.</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c100</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c110</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>d</name><operator>.</operator><name>r</name></name> <operator>&gt;</operator> <name><name>d</name><operator>.</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c100</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c101</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c100</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c001</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c101</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c101</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>b</name></name> <operator>&gt;</operator> <name><name>d</name><operator>.</operator><name>g</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c001</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c011</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c001</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>d</name><operator>.</operator><name>b</name></name> <operator>&gt;</operator> <name><name>d</name><operator>.</operator><name>r</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c010</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c011</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c011</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c010</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>prev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rgbvec</name></name></type> <name>c110</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>lutsize2</name> <operator>+</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>lutsize</name> <operator>+</operator> <name><name>prev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>r</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>r</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>g</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>g</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>g</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>)</operator> <operator>*</operator> <name><name>c000</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>g</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>)</operator> <operator>*</operator> <name><name>c010</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>r</name></name><operator>-</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c110</name><operator>.</operator><name>b</name></name> <operator>+</operator> <operator>(</operator><name><name>d</name><operator>.</operator><name>b</name></name><operator>)</operator> <operator>*</operator> <name><name>c111</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_INTERP_FUNC_PLANAR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>nbits</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int interp_##nbits##_##name##_p##depth(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { int x, y; const LUT3DContext *lut3d = ctx-&gt;priv; const ThreadData *td = arg; const AVFrame *in = td-&gt;in; const AVFrame *out = td-&gt;out; const int direct = out == in; const int slice_start = (in-&gt;height * jobnr ) / nb_jobs; const int slice_end = (in-&gt;height * (jobnr+1)) / nb_jobs; uint8_t *grow = out-&gt;data[0] + slice_start * out-&gt;linesize[0]; uint8_t *brow = out-&gt;data[1] + slice_start * out-&gt;linesize[1]; uint8_t *rrow = out-&gt;data[2] + slice_start * out-&gt;linesize[2]; uint8_t *arow = out-&gt;data[3] + slice_start * out-&gt;linesize[3]; const uint8_t *srcgrow = in-&gt;data[0] + slice_start * in-&gt;linesize[0]; const uint8_t *srcbrow = in-&gt;data[1] + slice_start * in-&gt;linesize[1]; const uint8_t *srcrrow = in-&gt;data[2] + slice_start * in-&gt;linesize[2]; const uint8_t *srcarow = in-&gt;data[3] + slice_start * in-&gt;linesize[3]; const float scale_r = (lut3d-&gt;scale.r / ((1&lt;&lt;depth) - 1)) * (lut3d-&gt;lutsize - 1); const float scale_g = (lut3d-&gt;scale.g / ((1&lt;&lt;depth) - 1)) * (lut3d-&gt;lutsize - 1); const float scale_b = (lut3d-&gt;scale.b / ((1&lt;&lt;depth) - 1)) * (lut3d-&gt;lutsize - 1); for (y = slice_start; y &lt; slice_end; y++) { uint##nbits##_t *dstg = (uint##nbits##_t *)grow; uint##nbits##_t *dstb = (uint##nbits##_t *)brow; uint##nbits##_t *dstr = (uint##nbits##_t *)rrow; uint##nbits##_t *dsta = (uint##nbits##_t *)arow; const uint##nbits##_t *srcg = (const uint##nbits##_t *)srcgrow; const uint##nbits##_t *srcb = (const uint##nbits##_t *)srcbrow; const uint##nbits##_t *srcr = (const uint##nbits##_t *)srcrrow; const uint##nbits##_t *srca = (const uint##nbits##_t *)srcarow; for (x = 0; x &lt; in-&gt;width; x++) { const struct rgbvec scaled_rgb = {srcr[x] * scale_r, srcg[x] * scale_g, srcb[x] * scale_b}; struct rgbvec vec = interp_##name(lut3d, &amp;scaled_rgb); dstr[x] = av_clip_uintp2(vec.r * (float)((1&lt;&lt;depth) - 1), depth); dstg[x] = av_clip_uintp2(vec.g * (float)((1&lt;&lt;depth) - 1), depth); dstb[x] = av_clip_uintp2(vec.b * (float)((1&lt;&lt;depth) - 1), depth); if (!direct &amp;&amp; in-&gt;linesize[3]) dsta[x] = srca[x]; } grow += out-&gt;linesize[0]; brow += out-&gt;linesize[1]; rrow += out-&gt;linesize[2]; arow += out-&gt;linesize[3]; srcgrow += in-&gt;linesize[0]; srcbrow += in-&gt;linesize[1]; srcrrow += in-&gt;linesize[2]; srcarow += in-&gt;linesize[3]; } return 0; }</cpp:value></cpp:define>






















































<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_INTERP_FUNC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>nbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int interp_##nbits##_##name(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { int x, y; const LUT3DContext *lut3d = ctx-&gt;priv; const ThreadData *td = arg; const AVFrame *in = td-&gt;in; const AVFrame *out = td-&gt;out; const int direct = out == in; const int step = lut3d-&gt;step; const uint8_t r = lut3d-&gt;rgba_map[R]; const uint8_t g = lut3d-&gt;rgba_map[G]; const uint8_t b = lut3d-&gt;rgba_map[B]; const uint8_t a = lut3d-&gt;rgba_map[A]; const int slice_start = (in-&gt;height * jobnr ) / nb_jobs; const int slice_end = (in-&gt;height * (jobnr+1)) / nb_jobs; uint8_t *dstrow = out-&gt;data[0] + slice_start * out-&gt;linesize[0]; const uint8_t *srcrow = in -&gt;data[0] + slice_start * in -&gt;linesize[0]; const float scale_r = (lut3d-&gt;scale.r / ((1&lt;&lt;nbits) - 1)) * (lut3d-&gt;lutsize - 1); const float scale_g = (lut3d-&gt;scale.g / ((1&lt;&lt;nbits) - 1)) * (lut3d-&gt;lutsize - 1); const float scale_b = (lut3d-&gt;scale.b / ((1&lt;&lt;nbits) - 1)) * (lut3d-&gt;lutsize - 1); for (y = slice_start; y &lt; slice_end; y++) { uint##nbits##_t *dst = (uint##nbits##_t *)dstrow; const uint##nbits##_t *src = (const uint##nbits##_t *)srcrow; for (x = 0; x &lt; in-&gt;width * step; x += step) { const struct rgbvec scaled_rgb = {src[x + r] * scale_r, src[x + g] * scale_g, src[x + b] * scale_b}; struct rgbvec vec = interp_##name(lut3d, &amp;scaled_rgb); dst[x + r] = av_clip_uint##nbits(vec.r * (float)((1&lt;&lt;nbits) - 1)); dst[x + g] = av_clip_uint##nbits(vec.g * (float)((1&lt;&lt;nbits) - 1)); dst[x + b] = av_clip_uint##nbits(vec.b * (float)((1&lt;&lt;nbits) - 1)); if (!direct &amp;&amp; step == 4) dst[x + a] = src[x + a]; } dstrow += out-&gt;linesize[0]; srcrow += in -&gt;linesize[0]; } return 0; }</cpp:value></cpp:define>









































<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>trilinear</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC</name><argument_list>(<argument>tetrahedral</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LINE_SIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <call><name>av_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'#'</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_LINE</name><parameter_list>(<parameter><type><name>loop_cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!fgets(line, sizeof(line), f)) { av_log(ctx, AV_LOG_ERROR, "Unexpected EOF\n"); return AVERROR_INVALIDDATA; } } while (loop_cond)</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type> <name>allocate_3dlut</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lutsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lutsize</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>lutsize</name></expr></argument> &gt;</argument_list></name> <name>MAX_LEVEL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too large or invalid 3D LUT size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>lutsize</name> <operator>*</operator> <name>lutsize</name> <operator>*</operator> <name>lutsize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>lutsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name> <operator>=</operator> <name>lutsize</name> <operator>*</operator> <name>lutsize</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_dat</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size2</name> <operator>=</operator> <name>size</name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"3DLUTSIZE "</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>k</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_cube</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"LUT_3D_SIZE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size2</name> <init>= <expr><name>size</name> <operator>*</operator> <name>size</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>i</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<label><name>try_again</name>:</label>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"MIN "</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vals</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"MAX "</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vals</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vals</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>vals</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vals</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"min: %f %f %f | max: %f %f %f\n"</literal></expr></argument>,
<argument><expr><name><name>min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>try_again</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"TITLE"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>try_again</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_3dl</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size2</name> <init>= <expr><literal type="number">17</literal> <operator>*</operator> <literal type="number">17</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>scale</name> <init>= <expr><literal type="number">16</literal><operator>*</operator><literal type="number">16</literal><operator>*</operator><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>k</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%d %d %d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>r</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>g</name></name> <operator>=</operator> <name>g</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_m3d</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>, <decl><type ref="prev"/><name>in</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>out</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>rgb_map</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"in"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"out"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>line</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_COLOR</name><parameter_list>(<parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { while (av_isspace(*p)) p++; switch (*p) { case 'r': rgb_map[id] = 0; break; case 'g': rgb_map[id] = 1; break; case 'b': rgb_map[id] = 2; break; } while (*p &amp;&amp; !av_isspace(*p)) p++; } while (0)</cpp:value></cpp:define>










<expr_stmt><expr><call><name>SET_COLOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_COLOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_COLOR</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>in</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>out</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"in and out must be defined\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>in</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name><name>out</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator>
<name>in</name></expr></argument> &gt;</argument_list></name> <name>MAX_LEVEL</name><operator>*</operator><name>MAX_LEVEL</name><operator>*</operator><name>MAX_LEVEL</name> <operator>||</operator>
<name>out</name></expr></argument> &gt;</argument_list></name> <name>MAX_LEVEL</name><operator>*</operator><name>MAX_LEVEL</name><operator>*</operator><name>MAX_LEVEL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid in (%d) or out (%d)\n"</literal></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>size</name><operator>*</operator><name>size</name><operator>*</operator><name>size</name> <operator>&lt;</operator> <name>in</name></expr>;</condition> <incr><expr><name>size</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size2</name> <operator>=</operator> <name>size</name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scale</name> <operator>=</operator> <literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name>out</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>k</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>val</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>val</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name><name>val</name><index>[<expr><name><name>rgb_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>g</name></name> <operator>=</operator> <name><name>val</name><index>[<expr><name><name>rgb_map</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name><name>val</name><index>[<expr><name><name>rgb_map</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_cinespace</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>in_min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>in_max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>out_min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>out_max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>inside_metadata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"CSPLUTV100"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not cineSpace LUT format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"3D"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not 3D LUT format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"BEGIN METADATA"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inside_metadata</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"END METADATA"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inside_metadata</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>inside_metadata</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size_r</name></decl>, <decl><type ref="prev"/><name>size_g</name></decl>, <decl><type ref="prev"/><name>size_b</name></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>npoints</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>npoints</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported number of pre-lut points.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_min</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_max</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>out_min</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>out_max</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%d %d %d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size_r</name> <operator>!=</operator> <name>size_g</name> <operator>||</operator> <name>size_r</name> <operator>!=</operator> <name>size_b</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported size combination: %dx%dx%d.\n"</literal></expr></argument>, <argument><expr><name>size_r</name></expr></argument>, <argument><expr><name>size_g</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>size_r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size2</name> <operator>=</operator> <name>size</name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>i</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>g</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vec</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>r</name></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>g</name></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>b</name></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_identity_matrix</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size2</name> <init>= <expr><name>size</name> <operator>*</operator> <name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>c</name> <init>= <expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name> <modifier>*</modifier></type><name>vec</name> <init>= <expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>k</name> <operator>*</operator> <name>size2</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>size</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>r</name></name> <operator>=</operator> <name>k</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>g</name></name> <operator>=</operator> <name>j</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>query_formats</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>enum</name> <name>AVPixelFormat</name></name></type> <name><name>pix_fmts</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>AV_PIX_FMT_RGB24</name></expr>, <expr><name>AV_PIX_FMT_BGR24</name></expr>,
<expr><name>AV_PIX_FMT_RGBA</name></expr>, <expr><name>AV_PIX_FMT_BGRA</name></expr>,
<expr><name>AV_PIX_FMT_ARGB</name></expr>, <expr><name>AV_PIX_FMT_ABGR</name></expr>,
<expr><name>AV_PIX_FMT_0RGB</name></expr>, <expr><name>AV_PIX_FMT_0BGR</name></expr>,
<expr><name>AV_PIX_FMT_RGB0</name></expr>, <expr><name>AV_PIX_FMT_BGR0</name></expr>,
<expr><name>AV_PIX_FMT_RGB48</name></expr>, <expr><name>AV_PIX_FMT_BGR48</name></expr>,
<expr><name>AV_PIX_FMT_RGBA64</name></expr>, <expr><name>AV_PIX_FMT_BGRA64</name></expr>,
<expr><name>AV_PIX_FMT_GBRP</name></expr>, <expr><name>AV_PIX_FMT_GBRAP</name></expr>,
<expr><name>AV_PIX_FMT_GBRP9</name></expr>,
<expr><name>AV_PIX_FMT_GBRP10</name></expr>, <expr><name>AV_PIX_FMT_GBRAP10</name></expr>,
<expr><name>AV_PIX_FMT_GBRP12</name></expr>, <expr><name>AV_PIX_FMT_GBRAP12</name></expr>,
<expr><name>AV_PIX_FMT_GBRP14</name></expr>,
<expr><name>AV_PIX_FMT_GBRP16</name></expr>, <expr><name>AV_PIX_FMT_GBRAP16</name></expr>,
<expr><name>AV_PIX_FMT_NONE</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterFormats</name> <modifier>*</modifier></type><name>fmts_list</name> <init>= <expr><call><name>ff_make_format_list</name><argument_list>(<argument><expr><name>pix_fmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmts_list</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ff_set_common_formats</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fmts_list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_input</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>is16bit</name></decl>, <decl><type ref="prev"/><name>planar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is16bit</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>planar</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_PLANAR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_fill_rgba_map</name><argument_list>(<argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>rgba_map</name></name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <call><name>av_get_padded_bits_per_pixel</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">3</literal> <operator>+</operator> <name>is16bit</name><operator>)</operator></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_FUNC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (planar) { switch (depth) { case 8: lut3d-&gt;interp = interp_8_##name##_p8; break; case 9: lut3d-&gt;interp = interp_16_##name##_p9; break; case 10: lut3d-&gt;interp = interp_16_##name##_p10; break; case 12: lut3d-&gt;interp = interp_16_##name##_p12; break; case 14: lut3d-&gt;interp = interp_16_##name##_p14; break; case 16: lut3d-&gt;interp = interp_16_##name##_p16; break; } } else if (is16bit) { lut3d-&gt;interp = interp_16_##name; } else { lut3d-&gt;interp = interp_8_##name; } } while (0)</cpp:value></cpp:define>













<switch>switch <condition>(<expr><name><name>lut3d</name><operator>-&gt;</operator><name>interpolation</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>INTERPOLATE_NEAREST</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC</name><argument_list>(<argument><expr><name>nearest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_TRILINEAR</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC</name><argument_list>(<argument><expr><name>trilinear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_TETRAHEDRAL</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC</name><argument_list>(<argument><expr><name>tetrahedral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>apply_lut</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ThreadData</name></type> <name>td</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>av_frame_is_writable</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>ff_get_video_buffer</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_frame_copy_props</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>td</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>td</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>ff_filter_get_nb_threads</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <name>in</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>apply_lut</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_LUT3D_FILTER</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>lut3d_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"file"</literal></expr>, <expr><literal type="string">"set 3D LUT file name"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><name>NULL</name></expr>}</block></expr>, <expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>FLAGS</name></expr> }</block></expr>,
<expr><name>COMMON_OPTIONS</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AVFILTER_DEFINE_CLASS</name><argument_list>(<argument><expr><name>lut3d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>lut3d_init</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lut3d</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>set_identity_matrix</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>av_fopen_utf8</name><argument_list>(<argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>av_err2str</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ext</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unable to guess the format from the extension\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ext</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"dat"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_dat</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"3dl"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_3dl</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"cube"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_cube</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"m3d"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_m3d</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"csp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_cinespace</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized '.%s' file type\n"</literal></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"3D LUT is empty\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>void</name></type> <name>lut3d_uninit</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>lut3d_inputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>filter_frame</name> <operator>=</operator> <name>filter_frame</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_input</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>lut3d_outputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_vf_lut3d</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"lut3d"</literal></expr>,
<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Adjust colors using a 3D LUT."</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LUT3DContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>lut3d_init</name></expr>,
<expr><operator>.</operator><name>uninit</name> <operator>=</operator> <name>lut3d_uninit</name></expr>,
<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,
<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>lut3d_inputs</name></expr>,
<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>lut3d_outputs</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>lut3d_class</name></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC</name> <operator>|</operator> <name>AVFILTER_FLAG_SLICE_THREADS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_HALDCLUT_FILTER</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_clut_packed</name><parameter_list>(<parameter><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>linesize</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>step</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_step</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>rgba_map</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_rgba_map</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>level</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>level2</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_CLUT</name><parameter_list>(<parameter><type><name>nbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int i, j, k, x = 0, y = 0; for (k = 0; k &lt; level; k++) { for (j = 0; j &lt; level; j++) { for (i = 0; i &lt; level; i++) { const uint##nbits##_t *src = (const uint##nbits##_t *) (data + y*linesize + x*step); struct rgbvec *vec = &amp;lut3d-&gt;lut[i * level2 + j * level + k]; vec-&gt;r = src[rgba_map[0]] / (float)((1&lt;&lt;(nbits)) - 1); vec-&gt;g = src[rgba_map[1]] / (float)((1&lt;&lt;(nbits)) - 1); vec-&gt;b = src[rgba_map[2]] / (float)((1&lt;&lt;(nbits)) - 1); if (++x == w) { x = 0; y++; } } } } } while (0)</cpp:value></cpp:define>




















<switch>switch <condition>(<expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_bits</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_clut_planar</name><parameter_list>(<parameter><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>datag</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>datab</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>datar</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>glinesize</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>blinesize</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rlinesize</name> <init>= <expr><name><name>frame</name><operator>-&gt;</operator><name>linesize</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_width</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>level</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>level2</name> <init>= <expr><name><name>lut3d</name><operator>-&gt;</operator><name>lutsize2</name></name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_CLUT_PLANAR</name><parameter_list>(<parameter><type><name>nbits</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int i, j, k, x = 0, y = 0; for (k = 0; k &lt; level; k++) { for (j = 0; j &lt; level; j++) { for (i = 0; i &lt; level; i++) { const uint##nbits##_t *gsrc = (const uint##nbits##_t *) (datag + y*glinesize); const uint##nbits##_t *bsrc = (const uint##nbits##_t *) (datab + y*blinesize); const uint##nbits##_t *rsrc = (const uint##nbits##_t *) (datar + y*rlinesize); struct rgbvec *vec = &amp;lut3d-&gt;lut[i * level2 + j * level + k]; vec-&gt;r = gsrc[x] / (float)((1&lt;&lt;(depth)) - 1); vec-&gt;g = bsrc[x] / (float)((1&lt;&lt;(depth)) - 1); vec-&gt;b = rsrc[x] / (float)((1&lt;&lt;(depth)) - 1); if (++x == w) { x = 0; y++; } } } } } while (0)</cpp:value></cpp:define>
























<switch>switch <condition>(<expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_bits</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">9</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">10</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">12</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">14</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><call><name>LOAD_CLUT_PLANAR</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_output</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>outlink</name><operator>-&gt;</operator><name>src</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_framesync_init_dualinput</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outlink</name><operator>-&gt;</operator><name>time_base</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>time_base</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_framesync_configure</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>activate</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ff_framesync_activate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_clut</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>level</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_bits</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_planar</name></name> <operator>=</operator> <call><name>av_pix_fmt_count_planes</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_step</name></name> <operator>=</operator> <call><name>av_get_padded_bits_per_pixel</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_fill_rgba_map</name><argument_list>(<argument><expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_rgba_map</name></name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>inlink</name><operator>-&gt;</operator><name>w</name></name> <operator>&gt;</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Padding on the right (%dpx) of the "</literal>
<literal type="string">"Hald CLUT will be ignored\n"</literal></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>w</name></name> <operator>-</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>inlink</name><operator>-&gt;</operator><name>w</name></name> <operator>&lt;</operator> <name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_INFO</name></expr></argument>, <argument><expr><literal type="string">"Padding at the bottom (%dpx) of the "</literal>
<literal type="string">"Hald CLUT will be ignored\n"</literal></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>h</name></name> <operator>-</operator> <name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_width</name></name> <operator>=</operator> <name>w</name> <operator>=</operator> <name>h</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>level</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>level</name><operator>*</operator><name>level</name><operator>*</operator><name>level</name> <operator>&lt;</operator> <name>w</name></expr>;</condition> <incr><expr><name>level</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>level</name><operator>*</operator><name>level</name><operator>*</operator><name>level</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>w</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"The Hald CLUT width does not match the level\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><name>w</name> <operator>==</operator> <name>h</name> <operator>&amp;&amp;</operator> <name>w</name> <operator>==</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>level</name> <operator>*=</operator> <name>level</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <name>MAX_LEVEL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_clut_level</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><name>MAX_LEVEL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_clut_size</name> <init>= <expr><name>max_clut_level</name><operator>*</operator><name>max_clut_level</name><operator>*</operator><name>max_clut_level</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too large Hald CLUT "</literal>
<literal type="string">"(maximum level is %d, or %dx%d CLUT)\n"</literal></expr></argument>,
<argument><expr><name>max_clut_level</name></expr></argument>, <argument><expr><name>max_clut_size</name></expr></argument>, <argument><expr><name>max_clut_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>allocate_3dlut</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>update_apply_clut</name><parameter_list>(<parameter><decl><type><name>FFFrameSync</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>master</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>second</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ff_framesync_dualinput_get</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>master</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>second</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>master</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lut3d</name><operator>-&gt;</operator><name>clut_planar</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>update_clut_planar</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>update_clut_packed</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>apply_lut</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>master</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>haldclut_init</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>lut3d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut3d</name><operator>-&gt;</operator><name>fs</name><operator>.</operator><name>on_event</name></name> <operator>=</operator> <name>update_apply_clut</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>void</name></type> <name>haldclut_uninit</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT3DContext</name> <modifier>*</modifier></type><name>lut3d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ff_framesync_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lut3d</name><operator>-&gt;</operator><name>lut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>haldclut_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>COMMON_OPTIONS</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FRAMESYNC_DEFINE_CLASS</name><argument_list>(<argument><expr><name>haldclut</name></expr></argument>, <argument><expr><name>LUT3DContext</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>haldclut_inputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"main"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_input</name></expr>,
}</block></expr>,<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"clut"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_clut</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>haldclut_outputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_output</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_vf_haldclut</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"haldclut"</literal></expr>,
<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Adjust colors using a Hald CLUT."</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LUT3DContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>preinit</name> <operator>=</operator> <name>haldclut_framesync_preinit</name></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>haldclut_init</name></expr>,
<expr><operator>.</operator><name>uninit</name> <operator>=</operator> <name>haldclut_uninit</name></expr>,
<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,
<expr><operator>.</operator><name>activate</name> <operator>=</operator> <name>activate</name></expr>,
<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>haldclut_inputs</name></expr>,
<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>haldclut_outputs</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>haldclut_class</name></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL</name> <operator>|</operator> <name>AVFILTER_FLAG_SLICE_THREADS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_LUT1D_FILTER</name></expr></cpp:if>

<enum>enum <name>interp_1d_mode</name> <block>{
<decl><name>INTERPOLATE_1D_NEAREST</name></decl>,
<decl><name>INTERPOLATE_1D_LINEAR</name></decl>,
<decl><name>INTERPOLATE_1D_CUBIC</name></decl>,
<decl><name>INTERPOLATE_1D_COSINE</name></decl>,
<decl><name>INTERPOLATE_1D_SPLINE</name></decl>,
<decl><name>NB_INTERP_1D_MODE</name></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_1D_LEVEL</name></cpp:macro> <cpp:value>65536</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>LUT1DContext</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AVClass</name> <modifier>*</modifier></type><name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>interpolation</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>rgbvec</name></name></type> <name>scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>rgba_map</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>lut</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>MAX_1D_LEVEL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lutsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>avfilter_action_func</name> <modifier>*</modifier></type><name>interp</name></decl>;</decl_stmt>
}</block></struct></type> <name>LUT1DContext</name>;</typedef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OFFSET</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(LUT1DContext, x)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_identity_matrix_1d</name><parameter_list>(<parameter><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>c</name> <init>= <expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>*</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_cinespace_1d</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>in_min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>in_max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>out_min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>out_max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>inside_metadata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"CSPLUTV100"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not cineSpace LUT format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"1D"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not 1D LUT format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"BEGIN METADATA"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inside_metadata</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"END METADATA"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inside_metadata</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>inside_metadata</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>npoints</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>npoints</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported number of pre-lut points.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AVERROR_PATCHWELCOME</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_min</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>in_max</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>out_min</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>out_max</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>size</name></expr></argument> &gt;</argument_list></name> <name>MAX_1D_LEVEL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too large or invalid 1D LUT size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>*=</operator> <name><name>out_max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>out_min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>in_max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>in_min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_cube_1d</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>MAX_LINE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>min</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>max</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"LUT_1D_SIZE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><call><name>strtol</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>size</name></expr></argument> &gt;</argument_list></name> <name>MAX_1D_LEVEL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Too large or invalid 1D LUT size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<do>do <block>{<block_content>
<label><name>try_again</name>:</label>
<expr_stmt><expr><call><name>NEXT_LINE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN_"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"MIN "</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vals</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"MAX "</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vals</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vals</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>vals</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vals</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"min: %f %f %f | max: %f %f %f\n"</literal></expr></argument>,
<argument><expr><name><name>min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>try_again</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"LUT_1D_INPUT_RANGE "</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">19</literal></expr></argument>, <argument><expr><literal type="string">"%f %f"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<goto>goto <name>try_again</name>;</goto>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"TITLE"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>try_again</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>skip_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><call><name>av_sscanf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%f %f %f"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AVERROR_INVALIDDATA</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <call><name>av_clipf</name><argument_list>(<argument><expr><literal type="number">1.</literal> <operator>/</operator> <operator>(</operator><name><name>max</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>min</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0.f</literal></expr></argument>, <argument><expr><literal type="number">1.f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVOption</name></type> <name><name>lut1d_options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"file"</literal></expr>, <expr><literal type="string">"set 1D LUT file name"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_STRING</name></expr>, <expr><block>{<expr><operator>.</operator><name>str</name><operator>=</operator><name>NULL</name></expr>}</block></expr>, <expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>FLAGS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"interp"</literal></expr>, <expr><literal type="string">"select interpolation mode"</literal></expr>, <expr><call><name>OFFSET</name><argument_list>(<argument><expr><name>interpolation</name></expr></argument>)</argument_list></call></expr>, <expr><name>AV_OPT_TYPE_INT</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_LINEAR</name></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NB_INTERP_1D_MODE</name><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"nearest"</literal></expr>, <expr><literal type="string">"use values from the nearest defined points"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_NEAREST</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"linear"</literal></expr>, <expr><literal type="string">"use values from the linear interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_LINEAR</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"cosine"</literal></expr>, <expr><literal type="string">"use values from the cosine interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_COSINE</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"cubic"</literal></expr>, <expr><literal type="string">"use values from the cubic interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_CUBIC</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"spline"</literal></expr>, <expr><literal type="string">"use values from the spline interpolation"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>AV_OPT_TYPE_CONST</name></expr>, <expr><block>{<expr><operator>.</operator><name>i64</name><operator>=</operator><name>INTERPOLATE_1D_SPLINE</name></expr>}</block></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>, <expr><name>FLAGS</name></expr>, <expr><literal type="string">"interp_mode"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AVFILTER_DEFINE_CLASS</name><argument_list>(<argument><expr><name>lut1d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>interp_1d_nearest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><call><name>NEAR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT1D</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(FFMIN((int)(x) + 1, lut1d-&gt;lutsize - 1))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>interp_1d_linear</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prev</name> <init>= <expr><call><name>PREV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>next</name> <init>= <expr><call><name>NEXT1D</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><name>s</name> <operator>-</operator> <name>prev</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>p</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>prev</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>n</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>next</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lerpf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>interp_1d_cosine</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prev</name> <init>= <expr><call><name>PREV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>next</name> <init>= <expr><call><name>NEXT1D</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>d</name> <init>= <expr><name>s</name> <operator>-</operator> <name>prev</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>p</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>prev</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>n</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>next</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>m</name> <init>= <expr><operator>(</operator><literal type="number">1.f</literal> <operator>-</operator> <call><name>cosf</name><argument_list>(<argument><expr><name>d</name> <operator>*</operator> <name>M_PI</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>*</operator> <literal type="number">.5f</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lerpf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>interp_1d_cubic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prev</name> <init>= <expr><call><name>PREV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>next</name> <init>= <expr><call><name>NEXT1D</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>mu</name> <init>= <expr><name>s</name> <operator>-</operator> <name>prev</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>a0</name></decl>, <decl><type ref="prev"/><name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>, <decl><type ref="prev"/><name>a3</name></decl>, <decl><type ref="prev"/><name>mu2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>y0</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>prev</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y1</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>prev</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y2</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>next</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y3</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>mu2</name> <operator>=</operator> <name>mu</name> <operator>*</operator> <name>mu</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a0</name> <operator>=</operator> <name>y3</name> <operator>-</operator> <name>y2</name> <operator>-</operator> <name>y0</name> <operator>+</operator> <name>y1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a1</name> <operator>=</operator> <name>y0</name> <operator>-</operator> <name>y1</name> <operator>-</operator> <name>a0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a2</name> <operator>=</operator> <name>y2</name> <operator>-</operator> <name>y0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a3</name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>

<return>return <expr><name>a0</name> <operator>*</operator> <name>mu</name> <operator>*</operator> <name>mu2</name> <operator>+</operator> <name>a1</name> <operator>*</operator> <name>mu2</name> <operator>+</operator> <name>a2</name> <operator>*</operator> <name>mu</name> <operator>+</operator> <name>a3</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type> <name>interp_1d_spline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>float</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prev</name> <init>= <expr><call><name>PREV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>next</name> <init>= <expr><call><name>NEXT1D</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>x</name> <init>= <expr><name>s</name> <operator>-</operator> <name>prev</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>c0</name></decl>, <decl><type ref="prev"/><name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>c3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float</name></type> <name>y0</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><call><name>FFMAX</name><argument_list>(<argument><expr><name>prev</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y1</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>prev</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y2</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><name>next</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>y3</name> <init>= <expr><name><name>lut1d</name><operator>-&gt;</operator><name>lut</name><index>[<expr><name>idx</name></expr>]</index><index>[<expr><call><name>FFMIN</name><argument_list>(<argument><expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name>y1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name>y2</name> <operator>-</operator> <name>y0</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>y0</name> <operator>-</operator> <literal type="number">2.5f</literal> <operator>*</operator> <name>y1</name> <operator>+</operator> <literal type="number">2.f</literal> <operator>*</operator> <name>y2</name> <operator>-</operator> <literal type="number">.5f</literal> <operator>*</operator> <name>y3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <literal type="number">.5f</literal> <operator>*</operator> <operator>(</operator><name>y3</name> <operator>-</operator> <name>y0</name><operator>)</operator> <operator>+</operator> <literal type="number">1.5f</literal> <operator>*</operator> <operator>(</operator><name>y1</name> <operator>-</operator> <name>y2</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name>c3</name> <operator>*</operator> <name>x</name> <operator>+</operator> <name>c2</name><operator>)</operator> <operator>*</operator> <name>x</name> <operator>+</operator> <name>c1</name><operator>)</operator> <operator>*</operator> <name>x</name> <operator>+</operator> <name>c0</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>nbits</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int interp_1d_##nbits##_##name##_p##depth(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { int x, y; const LUT1DContext *lut1d = ctx-&gt;priv; const ThreadData *td = arg; const AVFrame *in = td-&gt;in; const AVFrame *out = td-&gt;out; const int direct = out == in; const int slice_start = (in-&gt;height * jobnr ) / nb_jobs; const int slice_end = (in-&gt;height * (jobnr+1)) / nb_jobs; uint8_t *grow = out-&gt;data[0] + slice_start * out-&gt;linesize[0]; uint8_t *brow = out-&gt;data[1] + slice_start * out-&gt;linesize[1]; uint8_t *rrow = out-&gt;data[2] + slice_start * out-&gt;linesize[2]; uint8_t *arow = out-&gt;data[3] + slice_start * out-&gt;linesize[3]; const uint8_t *srcgrow = in-&gt;data[0] + slice_start * in-&gt;linesize[0]; const uint8_t *srcbrow = in-&gt;data[1] + slice_start * in-&gt;linesize[1]; const uint8_t *srcrrow = in-&gt;data[2] + slice_start * in-&gt;linesize[2]; const uint8_t *srcarow = in-&gt;data[3] + slice_start * in-&gt;linesize[3]; const float factor = (1 &lt;&lt; depth) - 1; const float scale_r = (lut1d-&gt;scale.r / factor) * (lut1d-&gt;lutsize - 1); const float scale_g = (lut1d-&gt;scale.g / factor) * (lut1d-&gt;lutsize - 1); const float scale_b = (lut1d-&gt;scale.b / factor) * (lut1d-&gt;lutsize - 1); for (y = slice_start; y &lt; slice_end; y++) { uint##nbits##_t *dstg = (uint##nbits##_t *)grow; uint##nbits##_t *dstb = (uint##nbits##_t *)brow; uint##nbits##_t *dstr = (uint##nbits##_t *)rrow; uint##nbits##_t *dsta = (uint##nbits##_t *)arow; const uint##nbits##_t *srcg = (const uint##nbits##_t *)srcgrow; const uint##nbits##_t *srcb = (const uint##nbits##_t *)srcbrow; const uint##nbits##_t *srcr = (const uint##nbits##_t *)srcrrow; const uint##nbits##_t *srca = (const uint##nbits##_t *)srcarow; for (x = 0; x &lt; in-&gt;width; x++) { float r = srcr[x] * scale_r; float g = srcg[x] * scale_g; float b = srcb[x] * scale_b; r = interp_1d_##name(lut1d, 0, r); g = interp_1d_##name(lut1d, 1, g); b = interp_1d_##name(lut1d, 2, b); dstr[x] = av_clip_uintp2(r * factor, depth); dstg[x] = av_clip_uintp2(g * factor, depth); dstb[x] = av_clip_uintp2(b * factor, depth); if (!direct &amp;&amp; in-&gt;linesize[3]) dsta[x] = srca[x]; } grow += out-&gt;linesize[0]; brow += out-&gt;linesize[1]; rrow += out-&gt;linesize[2]; arow += out-&gt;linesize[3]; srcgrow += in-&gt;linesize[0]; srcbrow += in-&gt;linesize[1]; srcrrow += in-&gt;linesize[2]; srcarow += in-&gt;linesize[3]; } return 0; }</cpp:value></cpp:define>



























































<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">8</literal></argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">9</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">12</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">14</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_PLANAR_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_INTERP_FUNC_1D</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>nbits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int interp_1d_##nbits##_##name(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { int x, y; const LUT1DContext *lut1d = ctx-&gt;priv; const ThreadData *td = arg; const AVFrame *in = td-&gt;in; const AVFrame *out = td-&gt;out; const int direct = out == in; const int step = lut1d-&gt;step; const uint8_t r = lut1d-&gt;rgba_map[R]; const uint8_t g = lut1d-&gt;rgba_map[G]; const uint8_t b = lut1d-&gt;rgba_map[B]; const uint8_t a = lut1d-&gt;rgba_map[A]; const int slice_start = (in-&gt;height * jobnr ) / nb_jobs; const int slice_end = (in-&gt;height * (jobnr+1)) / nb_jobs; uint8_t *dstrow = out-&gt;data[0] + slice_start * out-&gt;linesize[0]; const uint8_t *srcrow = in -&gt;data[0] + slice_start * in -&gt;linesize[0]; const float factor = (1 &lt;&lt; nbits) - 1; const float scale_r = (lut1d-&gt;scale.r / factor) * (lut1d-&gt;lutsize - 1); const float scale_g = (lut1d-&gt;scale.g / factor) * (lut1d-&gt;lutsize - 1); const float scale_b = (lut1d-&gt;scale.b / factor) * (lut1d-&gt;lutsize - 1); for (y = slice_start; y &lt; slice_end; y++) { uint##nbits##_t *dst = (uint##nbits##_t *)dstrow; const uint##nbits##_t *src = (const uint##nbits##_t *)srcrow; for (x = 0; x &lt; in-&gt;width * step; x += step) { float rr = src[x + r] * scale_r; float gg = src[x + g] * scale_g; float bb = src[x + b] * scale_b; rr = interp_1d_##name(lut1d, 0, rr); gg = interp_1d_##name(lut1d, 1, gg); bb = interp_1d_##name(lut1d, 2, bb); dst[x + r] = av_clip_uint##nbits(rr * factor); dst[x + g] = av_clip_uint##nbits(gg * factor); dst[x + b] = av_clip_uint##nbits(bb * factor); if (!direct &amp;&amp; step == 4) dst[x + a] = src[x + a]; } dstrow += out-&gt;linesize[0]; srcrow += in -&gt;linesize[0]; } return 0; }</cpp:value></cpp:define>













































<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">8</literal></argument>)</argument_list></macro>

<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>nearest</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>linear</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>cosine</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>cubic</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>DEFINE_INTERP_FUNC_1D</name><argument_list>(<argument>spline</argument>, <argument><literal type="number">16</literal></argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type> <name>config_input_1d</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>is16bit</name></decl>, <decl><type ref="prev"/><name>planar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AVPixFmtDescriptor</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><call><name>av_pix_fmt_desc_get</name><argument_list>(<argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is16bit</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>comp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>depth</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>planar</name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AV_PIX_FMT_FLAG_PLANAR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_fill_rgba_map</name><argument_list>(<argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>rgba_map</name></name></expr></argument>, <argument><expr><name><name>inlink</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <call><name>av_get_padded_bits_per_pixel</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">3</literal> <operator>+</operator> <name>is16bit</name><operator>)</operator></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_FUNC_1D</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (planar) { switch (depth) { case 8: lut1d-&gt;interp = interp_1d_8_##name##_p8; break; case 9: lut1d-&gt;interp = interp_1d_16_##name##_p9; break; case 10: lut1d-&gt;interp = interp_1d_16_##name##_p10; break; case 12: lut1d-&gt;interp = interp_1d_16_##name##_p12; break; case 14: lut1d-&gt;interp = interp_1d_16_##name##_p14; break; case 16: lut1d-&gt;interp = interp_1d_16_##name##_p16; break; } } else if (is16bit) { lut1d-&gt;interp = interp_1d_16_##name; } else { lut1d-&gt;interp = interp_1d_8_##name; } } while (0)</cpp:value></cpp:define>













<switch>switch <condition>(<expr><name><name>lut1d</name><operator>-&gt;</operator><name>interpolation</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>INTERPOLATE_1D_NEAREST</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC_1D</name><argument_list>(<argument><expr><name>nearest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_1D_LINEAR</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC_1D</name><argument_list>(<argument><expr><name>linear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_1D_COSINE</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC_1D</name><argument_list>(<argument><expr><name>cosine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_1D_CUBIC</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC_1D</name><argument_list>(<argument><expr><name>cubic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>INTERPOLATE_1D_SPLINE</name></expr>:</case> <expr_stmt><expr><call><name>SET_FUNC_1D</name><argument_list>(<argument><expr><name>spline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_assert0</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>lut1d_init</name><parameter_list>(<parameter><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>g</name></name> <operator>=</operator> <name><name>lut1d</name><operator>-&gt;</operator><name>scale</name><operator>.</operator><name>b</name></name> <operator>=</operator> <literal type="number">1.f</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lut1d</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_identity_matrix_1d</name><argument_list>(<argument><expr><name>lut1d</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>av_fopen_utf8</name><argument_list>(<argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>av_err2str</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ext</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unable to guess the format from the extension\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ext</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"cube"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"1dlut"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_cube_1d</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>av_strcasecmp</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">"csp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>parse_cinespace_1d</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized '.%s' file type\n"</literal></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>AVERROR</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lut1d</name><operator>-&gt;</operator><name>lutsize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"1D LUT is empty\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>AVERROR_INVALIDDATA</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>apply_1d_lut</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LUT1DContext</name> <modifier>*</modifier></type><name>lut1d</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ThreadData</name></type> <name>td</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>av_frame_is_writable</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>ff_get_video_buffer</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>av_frame_copy_props</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>td</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>in</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>td</name><operator>.</operator><name>out</name></name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ctx</name><operator>-&gt;</operator><name>internal</name><operator>-&gt;</operator><name>execute</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>lut1d</name><operator>-&gt;</operator><name>interp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>td</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FFMIN</name><argument_list>(<argument><expr><name><name>outlink</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>ff_filter_get_nb_threads</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name> <operator>!=</operator> <name>in</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>av_frame_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>filter_frame_1d</name><parameter_list>(<parameter><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>inlink</name></decl></parameter>, <parameter><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>AVFilterLink</name> <modifier>*</modifier></type><name>outlink</name> <init>= <expr><name><name>inlink</name><operator>-&gt;</operator><name>dst</name><operator>-&gt;</operator><name>outputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AVFrame</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>apply_1d_lut</name><argument_list>(<argument><expr><name>inlink</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ff_filter_frame</name><argument_list>(<argument><expr><name>outlink</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>lut1d_inputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
<expr><operator>.</operator><name>filter_frame</name> <operator>=</operator> <name>filter_frame_1d</name></expr>,
<expr><operator>.</operator><name>config_props</name> <operator>=</operator> <name>config_input_1d</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>AVFilterPad</name></type> <name><name>lut1d_outputs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"default"</literal></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_VIDEO</name></expr>,
}</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AVFilter</name></type> <name>ff_vf_lut1d</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"lut1d"</literal></expr>,
<expr><operator>.</operator><name>description</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"Adjust colors using a 1D LUT."</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>priv_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LUT1DContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>lut1d_init</name></expr>,
<expr><operator>.</operator><name>query_formats</name> <operator>=</operator> <name>query_formats</name></expr>,
<expr><operator>.</operator><name>inputs</name> <operator>=</operator> <name>lut1d_inputs</name></expr>,
<expr><operator>.</operator><name>outputs</name> <operator>=</operator> <name>lut1d_outputs</name></expr>,
<expr><operator>.</operator><name>priv_class</name> <operator>=</operator> <operator>&amp;</operator><name>lut1d_class</name></expr>,
<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC</name> <operator>|</operator> <name>AVFILTER_FLAG_SLICE_THREADS</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
