<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ffmpeg-analysis\_cppstats_featurelocations\FFmpeg\libavcodec\mlpenc.c">





















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"avcodec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"put_bits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audio_frame_queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/crc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/avstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libavutil/samplefmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mlp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lpc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAJOR_HEADER_INTERVAL</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLP_MIN_LPC_ORDER</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLP_MAX_LPC_ORDER</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLP_MIN_LPC_SHIFT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MLP_MAX_LPC_SHIFT</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name>min_channel</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_channel</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_matrix_channel</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>noise_shift</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>noisegen_seed</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>data_check_present</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int32_t</name></type> <name>lossless_check_data</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_huff_lsbs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_output_bits</name></decl>;</decl_stmt> 
}</block></struct></type> <name>RestartHeader</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>outch</name><index>[<expr><name>MAX_MATRICES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>forco</name><index>[<expr><name>MAX_MATRICES</name></expr>]</index><index>[<expr><name>MAX_CHANNELS</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>coeff</name><index>[<expr><name>MAX_MATRICES</name></expr>]</index><index>[<expr><name>MAX_CHANNELS</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>fbits</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int8_t</name></type> <name><name>shift</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>MatrixParams</name>;</typedef>

<enum>enum <name>ParamFlags</name> <block>{
<decl><name>PARAMS_DEFAULT</name> <init>= <expr><literal type="number">0xff</literal></expr></init></decl>,
<decl><name>PARAM_PRESENCE_FLAGS</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></init></decl>,
<decl><name>PARAM_BLOCKSIZE</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr></init></decl>,
<decl><name>PARAM_MATRIX</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">6</literal></expr></init></decl>,
<decl><name>PARAM_OUTSHIFT</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr></init></decl>,
<decl><name>PARAM_QUANTSTEP</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></init></decl>,
<decl><name>PARAM_FIR</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>,
<decl><name>PARAM_IIR</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>,
<decl><name>PARAM_HUFFOFFSET</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>PARAM_PRESENT</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,
}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>uint16_t</name></type> <name>blocksize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>quant_step_size</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MatrixParams</name></type> <name>matrix_params</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>param_presence_flags</name></decl>;</decl_stmt> 
}</block></struct></type> <name>DecodingParams</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BestOffset</name> <block>{
<decl_stmt><decl><type><name>int32_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bitcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lsb_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>max</name></decl>;</decl_stmt>
}</block></struct></type> <name>BestOffset</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUFF_OFFSET_MIN</name></cpp:macro> <cpp:value>(-16384)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HUFF_OFFSET_MAX</name></cpp:macro> <cpp:value>( 16383)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CODEBOOKS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_substreams</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>num_channels</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name><name>coded_sample_fmt</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>coded_sample_rate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>coded_peak_bitrate</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>substream_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordlength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>channel_occupancy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>summary_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>inout_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>major_inout_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>write_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>major_scratch_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>last_frame</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>lpc_sample_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_number_of_frames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>next_major_number_of_frames</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_frame_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>next_major_frame_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>lossless_check_data</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>max_output_bits</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>frame_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>frame_index</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>one_sample_buffer_size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>max_restart_interval</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>min_restart_interval</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>restart_intervals</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint16_t</name></type> <name>timestamp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint16_t</name></type> <name>dts</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>channel_arrangement</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint8_t</name></type> <name>ch_modifier_thd0</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ch_modifier_thd1</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ch_modifier_thd2</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>seq_size</name> <index>[<expr><name>MAJOR_HEADER_INTERVAL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>seq_offset</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sequence_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>channel_params</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BestOffset</name></type> <name><name>best_offset</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>MAX_CHANNELS</name></expr>]</index><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>decoding_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name></type> <name><name>restart_header</name> <index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ChannelParams</name></type> <name><name>major_channel_params</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>DecodingParams</name></type> <name><name>major_decoding_params</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>major_params_changed</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name><operator>+</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_cur_subblock_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_filter_state_subblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>major_number_of_subblocks</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BestOffset</name> <argument_list>(<argument><expr><operator>*</operator><name>cur_best_offset</name></expr></argument>)</argument_list></call><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cur_channel_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>cur_decoding_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>cur_restart_header</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AudioFrameQueue</name></type> <name>afq</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>starting_frame_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>number_of_frames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>number_of_samples</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>number_of_subblocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>seq_index</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>prev_channel_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>prev_decoding_params</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>seq_channel_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>seq_decoding_params</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>max_codebook_search</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LPCContext</name></type> <name>lpc_ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>MLPEncodeContext</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ChannelParams</name></type> <name><name>restart_channel_params</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DecodingParams</name></type> <name><name>restart_decoding_params</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BestOffset</name></type> <name><name>restart_best_offset</name><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_MAJOR</name></cpp:macro> <cpp:value>0xf8726f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAJOR_SYNC_INFO_SIGNATURE</name></cpp:macro> <cpp:value>0xB752</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_MLP</name></cpp:macro> <cpp:value>0xbb</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNC_TRUEHD</name></cpp:macro> <cpp:value>0xba</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DVDA</name></cpp:macro> <cpp:value>0x4000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_CONST</name></cpp:macro> <cpp:value>0x8000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBSTREAM_INFO_MAX_2_CHAN</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBSTREAM_INFO_HIGH_RATE</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBSTREAM_INFO_ALWAYS_SET</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBSTREAM_INFO_2_SUBSTREAMS</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_filter_params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ChannelParams</name> <modifier>*</modifier></type><name>prev_cp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FilterParams</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><operator>&amp;</operator><name><name>prev_cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>FilterParams</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>order</name></name> <operator>!=</operator> <name><name>fp</name><operator>-&gt;</operator><name>order</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev</name><operator>-&gt;</operator><name>order</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>shift</name></name> <operator>!=</operator> <name><name>fp</name><operator>-&gt;</operator><name>shift</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fp</name><operator>-&gt;</operator><name>order</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev_cp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_matrix_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MatrixParams</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>, <decl><type ref="prev"/><name>mat</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>!=</operator> <name><name>mp</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>channel</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>mat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mat</name> <operator>&lt;</operator> <name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>mat</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>mat</name></expr>]</index></name> <operator>!=</operator> <name><name>mp</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>mat</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>mat</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name> <operator>!=</operator> <name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>mat</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_decoding_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>prev_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>prev_mp</name> <init>= <expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>!=</operator> <name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_PRESENCE_FLAGS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>!=</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_BLOCKSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compare_matrix_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>prev_mp</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_MATRIX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_matrix_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev_mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>!=</operator> <name><name>mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_OUTSHIFT</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>!=</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>ch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_QUANTSTEP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>prev_cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>prev_channel_params</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>retval</name> <operator>&amp;</operator> <name>PARAM_FIR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>compare_filter_params</name><argument_list>(<argument><expr><name>prev_cp</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>FIR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_FIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>retval</name> <operator>&amp;</operator> <name>PARAM_IIR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>compare_filter_params</name><argument_list>(<argument><expr><name>prev_cp</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>IIR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_IIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev_cp</name><operator>-&gt;</operator><name>huff_offset</name></name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>huff_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <name>PARAM_HUFFOFFSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prev_cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>||</operator>
<name><name>prev_cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name> <operator>!=</operator> <name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>|=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_filter_params</name><parameter_list>(<parameter><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>dst_cp</name></decl></parameter>, <parameter><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>src_cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><operator>&amp;</operator><name><name>dst_cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>&amp;</operator><name><name>src_cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>order</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>order</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>-&gt;</operator><name>order</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>shift</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>shift</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>coeff_shift</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>coeff_shift</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>coeff_bits</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>coeff_bits</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>order</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>order</name> <operator>&lt;</operator> <name><name>dst</name><operator>-&gt;</operator><name>order</name></name></expr>;</condition> <incr><expr><name>order</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst_cp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>order</name></expr>]</index></name> <operator>=</operator> <name><name>src_cp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>order</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_matrix_params</name><parameter_list>(<parameter><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name>MAX_CHANNELS</name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>MAX_MATRICES</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>count</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>count</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>MAX_MATRICES</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_restart_frame_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_decoding_params</name></name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>copy_matrix_params</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_channel_params</name></name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>filter</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name><operator>.</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name><operator>-&gt;</operator><name>matrix_params</name><operator>.</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>filter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>filter</name> <operator>&lt;</operator> <name>NUM_FILTERS</name></expr>;</condition> <incr><expr><name>filter</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_filter_params</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_decoding_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>DecodingParams</name></type> <name><name>decoding_params</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><operator>&amp;</operator><name><name>decoding_params</name><index>[<expr><name>substr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></argument> , <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MatrixParams</name></expr></argument> )</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_channel_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ChannelParams</name></type> <name><name>channel_params</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>channel_params</name><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>filter_params</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>filter_params</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>default_decoding_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>DecodingParams</name></type> <name><name>decoding_params</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_decoding_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>decoding_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><operator>&amp;</operator><name><name>decoding_params</name><index>[<expr><name>substr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>param_presence_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_BLOCKSIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_MATRIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_OUTSHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_QUANTSTEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_FIR</name></expr>;</expr_stmt>

<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_HUFFOFFSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name>param_presence_flags</name> <operator>|=</operator> <name>PARAM_PRESENT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>=</operator> <name>param_presence_flags</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name> <specifier>inline</specifier></type> <name>number_sbits</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>number</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>number</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>av_log2</name><argument_list>(<argument><expr><call><name>FFABS</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>!</operator><operator>!</operator><name>number</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>InputBitDepth</name> <block>{
<decl><name>BITS_16</name></decl>,
<decl><name>BITS_20</name></decl>,
<decl><name>BITS_24</name></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mlp_peak_bitrate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>peak_bitrate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sample_rate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>peak_bitrate</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>-</operator> <literal type="number">8</literal><operator>)</operator> <operator>/</operator> <name>sample_rate</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>mlp_encode_init</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name></name> <operator>=</operator> <name>avctx</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_rate</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">44100</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x08</literal> <operator>+</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x08</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">44100</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x08</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x0C</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">44100</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>|=</operator> <name>SUBSTREAM_INFO_HIGH_RATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x08</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x10</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">48000</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal> <operator>+</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x08</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">48000</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x0C</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">48000</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>|=</operator> <name>SUBSTREAM_INFO_HIGH_RATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <literal type="number">40</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <literal type="number">0x10</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported sample rate %d. Supported "</literal>
<literal type="string">"sample rates are 44100, 88200, 176400, 48000, "</literal>
<literal type="string">"96000, and 192000.\n"</literal></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>


<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_peak_bitrate</name></name> <operator>=</operator> <call><name>mlp_peak_bitrate</name><argument_list>(<argument><expr><literal type="number">9600000</literal></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_rate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Only mono and stereo are supported at the moment.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>|=</operator> <name>SUBSTREAM_INFO_ALWAYS_SET</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>|=</operator> <name>SUBSTREAM_INFO_MAX_2_CHAN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>sample_fmt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AV_SAMPLE_FMT_S16</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_fmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>BITS_16</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>wordlength</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bits_per_raw_sample</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>AV_SAMPLE_FMT_S32</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_fmt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>BITS_24</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>wordlength</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avctx</name><operator>-&gt;</operator><name>bits_per_raw_sample</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Sample format not supported. "</literal>
<literal type="string">"Only 16- and 24-bit samples are supported.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_fmt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dts</name></name> <operator>=</operator> <operator>-</operator><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>one_sample_buffer_size</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name>
<operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name> <operator>=</operator> <name>MAJOR_HEADER_INTERVAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_codebook_search</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name> <operator>=</operator> <name>MAJOR_HEADER_INTERVAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>lpc_sample_buffer</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>lpc_sample_buffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for buffering samples.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>one_sample_buffer_size</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for buffering samples.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name> <operator>=</operator> <call><name>av_malloc_array</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for buffering samples.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_mlp_init_crc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_MLP</name></expr>)</condition> <block>{<block_content>

<switch>switch<condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>channel_layout</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AV_CH_LAYOUT_MONO</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_STEREO</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_2_1</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_QUAD</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_2POINT1</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_SURROUND</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_4POINT0</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_5POINT0_BACK</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_3POINT1</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_4POINT1</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_5POINT1_BACK</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported channel arrangement\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>FLAGS_DVDA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_occupancy</name></name> <operator>=</operator> <name><name>ff_mlp_ch_info</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name></expr>]</index></name><operator>.</operator><name>channel_occupancy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>summary_info</name></name> <operator>=</operator> <name><name>ff_mlp_ch_info</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name></expr>]</index></name><operator>.</operator><name>summary_info</name></expr> ;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch<condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>channel_layout</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AV_CH_LAYOUT_STEREO</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd0</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_5POINT0_BACK</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd0</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd2</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AV_CH_LAYOUT_5POINT1_BACK</name></expr>:</case>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd0</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd2</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unsupported channel arrangement\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_occupancy</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>summary_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof>
<operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>lossless_check_data</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>lossless_check_data</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_offset</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_size</name> <index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>seq_size</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name> <operator>=</operator> <name>sum</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChannelParams</name></expr></argument>)</argument_list></sizeof>
<operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_params</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>channel_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for analysis context.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DecodingParams</name></expr></argument>)</argument_list></sizeof>
<operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>decoding_params</name></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>decoding_params</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for analysis context.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>AVERROR</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name> <index>[<expr><name>substr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>noisegen_seed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>max_matrix_channel</name></name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>clear_channel_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>restart_channel_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clear_decoding_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>restart_decoding_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_lpc_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>lpc_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr></argument>,
<argument><expr><name>MLP_MAX_LPC_ORDER</name></expr></argument>, <argument><expr><name>FF_LPC_TYPE_LEVINSON</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for LPC context.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ff_af_queue_init</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>afq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>write_major_sync</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PutBitContext</name></type> <name>pb</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>SYNC_MAJOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_MLP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>SYNC_MLP</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_fmt</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_fmt</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>codec_id</name></name> <operator>==</operator> <name>AV_CODEC_ID_TRUEHD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>SYNC_TRUEHD</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_sample_rate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd0</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd1</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ch_modifier_thd2</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_arrangement</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>MAJOR_SYNC_INFO_SIGNATURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>flags</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>coded_peak_bitrate</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0x1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>fs</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>wordlength</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>channel_occupancy</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0x8080</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>summary_info</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_WL16</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">26</literal></expr></argument>, <argument><expr><call><name>ff_mlp_checksum16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>write_restart_header</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>lossless_check</name> <init>= <expr><call><name>xor_32_to_8</name><argument_list>(<argument><expr><name><name>rh</name><operator>-&gt;</operator><name>lossless_check_data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>start_count</name> <init>= <expr><call><name>put_bits_count</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PutBitContext</name></type> <name>tmpb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ch</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">0x31ea</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>max_matrix_channel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>noise_shift</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>noisegen_seed</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>max_huff_lsbs</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>max_output_bits</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>max_output_bits</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rh</name><operator>-&gt;</operator><name>data_check_present</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>lossless_check</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_matrix_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><name>tmpb</name> <operator>=</operator> <operator>*</operator><name>pb</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>ff_mlp_restart_checksum</name><argument_list>(<argument><expr><name><name>pb</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><call><name>put_bits_count</name><argument_list>(<argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>write_matrix_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mat</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>mat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mat</name> <operator>&lt;</operator> <name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>mat</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>mp</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>mat</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>mp</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>mat</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>coeff</name> <init>= <expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>mat</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>coeff</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>coeff</name> <operator>&gt;&gt;=</operator> <literal type="number">14</literal> <operator>-</operator> <name><name>mp</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>mat</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_sbits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>mp</name><operator>-&gt;</operator><name>fbits</name><index>[<expr><name>mat</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>coeff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>write_filter_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>order</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fp</name><operator>-&gt;</operator><name>order</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>fcoeff</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>coeff</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>shift</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>coeff_bits</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>coeff_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fp</name><operator>-&gt;</operator><name>order</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>put_sbits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>fp</name><operator>-&gt;</operator><name>coeff_bits</name></name></expr></argument>, <argument><expr><name><name>fcoeff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <name><name>fp</name><operator>-&gt;</operator><name>coeff_shift</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>write_decoding_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>params_changed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>!=</operator> <name>PARAMS_DEFAULT</name> <operator>&amp;&amp;</operator>
<name>params_changed</name> <operator>&amp;</operator> <name>PARAM_PRESENCE_FLAGS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_BLOCKSIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_BLOCKSIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_MATRIX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_MATRIX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_matrix_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_OUTSHIFT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_OUTSHIFT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_matrix_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_sbits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_QUANTSTEP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_QUANTSTEP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_FIR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_FIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_filter_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>FIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_IIR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_IIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_filter_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>IIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>param_presence_flags</name></name> <operator>&amp;</operator> <name>PARAM_HUFFOFFSET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>params_changed</name> <operator>&amp;</operator> <name>PARAM_HUFFOFFSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name> <argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_sbits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name> <operator>&gt;</operator> <literal type="number">24</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid Huff LSBs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>write_block_data</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>PutBitContext</name> <modifier>*</modifier></type><name>pb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>write_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>sign_huff_offset</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>codebook_index</name> <index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>lsb_bits</name> <index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign_shift</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lsb_bits</name> <index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name> <operator>-</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codebook_index</name> <index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sign_huff_offset</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>huff_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign_shift</name> <operator>=</operator> <name><name>lsb_bits</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>-</operator> <name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sign_huff_offset</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-=</operator> <literal type="number">7</literal> <operator>&lt;&lt;</operator> <name><name>lsb_bits</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>sign_shift</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sign_huff_offset</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>-=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>sign_shift</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>ch</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>ch</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name> <init>= <expr><operator>*</operator><name>sample_buffer</name><operator>++</operator> <operator>&gt;&gt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sample</name> <operator>-=</operator> <name><name>sign_huff_offset</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>codebook_index</name><index>[<expr><name>ch</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>vlc</name> <init>= <expr><name>sample</name> <operator>&gt;&gt;</operator> <name><name>lsb_bits</name><index>[<expr><name>ch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>ff_mlp_huffman_tables</name><index>[<expr><name><name>codebook_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>]</index><index>[<expr><name>vlc</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ff_mlp_huffman_tables</name><index>[<expr><name><name>codebook_index</name><index>[<expr><name>ch</name></expr>]</index></name></expr>]</index><index>[<expr><name>vlc</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>put_sbits</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name><name>lsb_bits</name><index>[<expr><name>ch</name></expr>]</index></name></expr></argument>, <argument><expr><name>sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></for>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_buffer</name></name> <operator>=</operator> <name>sample_buffer</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>write_substrs</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>restart_frame</name></decl></parameter>,
<parameter><decl><type><name>uint16_t</name></type> <name><name>substream_data_len</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>lossless_check_data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>lossless_check_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lossless_check_data</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cur_subblock_index</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>major_cur_subblock_index</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num_subblocks</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>major_filter_state_subblock</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>subblock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name> <index>[<expr><name>substr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>substr_restart_frame</name> <init>= <expr><name>restart_frame</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>parity</name></decl>, <decl><type ref="prev"/><name>checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PutBitContext</name></type> <name>pb</name></decl>, <decl><type ref="prev"/><name>tmpb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>params_changed</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name> <operator>=</operator> <name>rh</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>subblock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>subblock</name> <operator>&lt;=</operator> <name>num_subblocks</name></expr>;</condition> <incr><expr><name>subblock</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>subblock_index</name></decl>;</decl_stmt>

<expr_stmt><expr><name>subblock_index</name> <operator>=</operator> <name>cur_subblock_index</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_decoding_params</name><index>[<expr><name>subblock_index</name></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_channel_params</name><index>[<expr><name>subblock_index</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>params_changed</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_params_changed</name><index>[<expr><name>subblock_index</name></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>substr_restart_frame</name> <operator>||</operator> <name>params_changed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>substr_restart_frame</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_restart_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>lossless_check_data</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_decoding_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><name>params_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_block_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name>substr_restart_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>substr_restart_frame</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>lossless_check_data</name></name> <operator>^=</operator> <operator>*</operator><name>lossless_check_data</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>last_frame</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>END_OF_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>tmpb</name> <operator>=</operator> <name>pb</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>parity</name> <operator>=</operator> <call><name>ff_mlp_calculate_parity</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">0xa9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>ff_mlp_checksum8</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>parity</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_put_bits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>+=</operator> <call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>substream_data_len</name><index>[<expr><name>substr</name></expr>]</index></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>+=</operator> <call><name>put_bits_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pb</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_cur_subblock_index</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_filter_state_subblock</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_filter_state_subblock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>write_frame_headers</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>frame_header</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>substream_headers</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>length</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>restart_frame</name></decl></parameter>,
<parameter><decl><type><name>uint16_t</name></type> <name><name>substream_data_len</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>access_unit_header</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>parity_nibble</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>parity_nibble</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>parity_nibble</name> <operator>^=</operator> <name>length</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>substr_hdr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>substr_hdr</name> <operator>|=</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>substr_hdr</name> <operator>|=</operator> <operator>(</operator><operator>!</operator><name>restart_frame</name> <operator>&lt;&lt;</operator> <literal type="number">14</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>substr_hdr</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">13</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>substr_hdr</name> <operator>|=</operator> <operator>(</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name>substr_hdr</name> <operator>|=</operator> <operator>(</operator><name><name>substream_data_len</name><index>[<expr><name>substr</name></expr>]</index></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0FFF</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_WB16</name><argument_list>(<argument><expr><name>substream_headers</name></expr></argument>, <argument><expr><name>substr_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>parity_nibble</name> <operator>^=</operator> <operator>*</operator><name>substream_headers</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>parity_nibble</name> <operator>^=</operator> <operator>*</operator><name>substream_headers</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>parity_nibble</name> <operator>^=</operator> <name>parity_nibble</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>parity_nibble</name> <operator>^=</operator> <name>parity_nibble</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>parity_nibble</name> <operator>&amp;=</operator> <literal type="number">0xF</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>access_unit_header</name> <operator>|=</operator> <operator>(</operator><name>parity_nibble</name> <operator>^</operator> <literal type="number">0xF</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>access_unit_header</name> <operator>|=</operator> <name>length</name> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AV_WB16</name><argument_list>(<argument><expr><name>frame_header</name></expr></argument> , <argument><expr><name>access_unit_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AV_WB16</name><argument_list>(<argument><expr><name>frame_header</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dts</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>write_access_unit</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>buf_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>restart_frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>substream_data_len</name><index>[<expr><name>MAX_SUBSTREAMS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf0</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>total_length</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf_size</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_size</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>restart_frame</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf_size</name> <operator>&lt;</operator> <literal type="number">28</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>write_major_sync</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">28</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_size</name> <operator>-=</operator> <literal type="number">28</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf1</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_size</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>write_substrs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><name>restart_frame</name></expr></argument>, <argument><expr><name>substream_data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>total_length</name> <operator>=</operator> <name>buf</name> <operator>-</operator> <name>buf0</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_frame_headers</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf0</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>total_length</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>restart_frame</name></expr></argument>, <argument><expr><name>substream_data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>total_length</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>input_data_internal</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>samples</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is24</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>lossless_check_data</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>lossless_check_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name> <modifier>*</modifier></type><name>samples_32</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>int32_t</name> <operator>*</operator><operator>)</operator> <name>samples</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int16_t</name> <modifier>*</modifier></type><name>samples_16</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>int16_t</name> <operator>*</operator><operator>)</operator> <name>samples</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lossless_check_data</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name> <index>[<expr><name>substr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>temp_lossless_check_data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>greatest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>abs_sample</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sample</name> <operator>=</operator> <ternary><condition><expr><name>is24</name></expr> ?</condition><then> <expr><operator>*</operator><name>samples_32</name><operator>++</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr> </then><else>: <expr><operator>*</operator><name>samples_16</name><operator>++</operator> <operator>*</operator> <literal type="number">256</literal></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>abs_sample</name> <operator>=</operator> <call><name>FFABS</name><argument_list>(<argument><expr><name>sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>greatest</name> <operator>&lt;</operator> <name>abs_sample</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>greatest</name> <operator>=</operator> <name>abs_sample</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>temp_lossless_check_data</name> <operator>^=</operator> <operator>(</operator><name>sample</name> <operator>&amp;</operator> <literal type="number">0x00ffffff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>channel</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sample_buffer</name><operator>++</operator> <operator>=</operator> <name>sample</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></for>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name> <operator>=</operator> <call><name>number_sbits</name><argument_list>(<argument><expr><name>greatest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>lossless_check_data</name><operator>++</operator> <operator>=</operator> <name>temp_lossless_check_data</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>input_data</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>samples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>sample_fmt</name></name> <operator>==</operator> <name>AV_SAMPLE_FMT_S32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>input_data_internal</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>samples</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>input_data_internal</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>samples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>input_to_sample_buffer</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cur_index</name> <init>= <expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>starting_frame_index</name></name> <operator>+</operator> <name>index</name><operator>)</operator> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>input_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name> <operator>+</operator> <name>cur_index</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>one_sample_buffer_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>channel</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name>cur_index</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sample_buffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>input_buffer</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>input_buffer</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type> <name>number_trailing_zeroes</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>sample</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;</operator> <literal type="number">24</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>sample</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>bits</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>



<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">24</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>bits</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>determine_quant_step_size</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>sample_mask</name><index>[<expr><name>MAX_CHANNELS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sample_mask</name></expr></argument>, <argument><expr><literal type="number">0x00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sample_mask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sample_mask</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>|=</operator> <operator>*</operator><name>sample_buffer</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
</block_content>}</block></for>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <call><name>number_trailing_zeroes</name><argument_list>(<argument><expr><name><name>sample_mask</name><index>[<expr><name>channel</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>code_filter_coeffs</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>fcoeff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name>INT_MIN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>, <decl><type ref="prev"/><name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>coeff_mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>order</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>order</name> <operator>&lt;</operator> <name><name>fp</name><operator>-&gt;</operator><name>order</name></name></expr>;</condition> <incr><expr><name>order</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>coeff</name> <init>= <expr><name><name>fcoeff</name><index>[<expr><name>order</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>coeff</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>coeff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>coeff</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>coeff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>coeff_mask</name> <operator>|=</operator> <name>coeff</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><call><name>number_sbits</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>number_sbits</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>shift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>shift</name> <operator>&lt;</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <name>bits</name> <operator>+</operator> <name>shift</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>coeff_mask</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>shift</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>shift</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>coeff_bits</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>coeff_shift</name></name> <operator>=</operator> <name>shift</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>set_filter_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>filter</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>clear_filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter</name> <operator>==</operator> <name>IIR</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>&amp;</operator> <name>SUBSTREAM_INFO_HIGH_RATE</name><operator>)</operator> <operator>||</operator>
<name>clear_filter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>filter</name> <operator>==</operator> <name>IIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>filter</name> <operator>==</operator> <name>FIR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_order</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>substream_info</name></name> <operator>&amp;</operator> <name>SUBSTREAM_INFO_HIGH_RATE</name><operator>)</operator></expr>
?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><name>MLP_MAX_LPC_ORDER</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name><name>coefs</name><index>[<expr><name>MAX_LPC_ORDER</name></expr>]</index><index>[<expr><name>MAX_LPC_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>lpc_samples</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>lpc_sample_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>fcoeff</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>coeff</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>shift</name><index>[<expr><name>MLP_MAX_LPC_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>order</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>lpc_samples</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sample_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>ff_lpc_calc_coefs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>lpc_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>lpc_sample_buffer</name></name></expr></argument>,
<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr></argument>, <argument><expr><name>MLP_MIN_LPC_ORDER</name></expr></argument>,
<argument><expr><name>max_order</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>coefs</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr><name>FF_LPC_TYPE_LEVINSON</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>ORDER_METHOD_EST</name></expr></argument>, <argument><expr><name>MLP_MIN_LPC_SHIFT</name></expr></argument>,
<argument><expr><name>MLP_MAX_LPC_SHIFT</name></expr></argument>, <argument><expr><name>MLP_MIN_LPC_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fp</name><operator>-&gt;</operator><name>shift</name></name> <operator>=</operator> <name><name>shift</name><index>[<expr><name>order</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>order</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>fcoeff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>coefs</name><index>[<expr><name>order</name><operator>-</operator><literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>code_filter_coeffs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>fcoeff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>determine_filters</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>channel</name></decl>, <decl><type ref="prev"/><name>filter</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>filter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>filter</name> <operator>&lt;</operator> <name>NUM_FILTERS</name></expr>;</condition> <incr><expr><name>filter</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_filter_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<enum>enum <name>MLPChMode</name> <block>{
<decl><name>MLP_CHMODE_LEFT_RIGHT</name></decl>,
<decl><name>MLP_CHMODE_LEFT_SIDE</name></decl>,
<decl><name>MLP_CHMODE_RIGHT_SIDE</name></decl>,
<decl><name>MLP_CHMODE_MID_SIDE</name></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>MLPChMode</name></name></type> <name>estimate_stereo_mode</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>score</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>sum</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>right_ch</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>left_ch</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MLPChMode</name></name></type> <name>best</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><name><name>left_ch</name> <index>[<expr><name>i</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>left_ch</name> <index>[<expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name> <operator>+</operator> <name><name>left_ch</name> <index>[<expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><name><name>right_ch</name><index>[<expr><name>i</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>right_ch</name><index>[<expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name> <operator>+</operator> <name><name>right_ch</name><index>[<expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <call><name>FFABS</name><argument_list>( <argument><expr><name>left</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <call><name>FFABS</name><argument_list>( <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <call><name>FFABS</name><argument_list>(<argument><expr><operator>(</operator><name>left</name> <operator>+</operator> <name>right</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <call><name>FFABS</name><argument_list>( <argument><expr><name>left</name> <operator>-</operator> <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>score</name><index>[<expr><name>MLP_CHMODE_LEFT_RIGHT</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>score</name><index>[<expr><name>MLP_CHMODE_LEFT_SIDE</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>score</name><index>[<expr><name>MLP_CHMODE_RIGHT_SIDE</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>score</name><index>[<expr><name>MLP_CHMODE_MID_SIDE</name></expr>]</index></name> <operator>=</operator> <name><name>sum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>sum</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if<condition>(<expr><name><name>score</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>score</name><index>[<expr><name>best</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>best</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>best</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>code_matrix_coeffs</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>coeff_mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bits</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>coeff</name> <init>= <expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><name>mat</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>coeff_mask</name> <operator>|=</operator> <name>coeff</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bits</name> <operator>&lt;</operator> <literal type="number">14</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>coeff_mask</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>bits</name><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><name>bits</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>fbits</name> <index>[<expr><name>mat</name></expr>]</index></name> <operator>=</operator> <literal type="number">14</literal> <operator>-</operator> <name>bits</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>lossless_matrix_coeffs</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>shift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>MLPChMode</name></name></type> <name>mode</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name> <operator>-</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>estimate_stereo_mode</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MLP_CHMODE_MID_SIDE</name></expr>:</case>
<case>case <expr><name>MLP_CHMODE_LEFT_RIGHT</name></expr>:</case>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MLP_CHMODE_LEFT_SIDE</name></expr>:</case>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>outch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>MLP_CHMODE_RIGHT_SIDE</name></expr>:</case>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>outch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>coeff</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<for>for <control>(<init><expr><name>mat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mat</name> <operator>&lt;</operator> <name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>mat</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>code_matrix_coeffs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>mat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>channel</name></expr>]</index></name> <operator>=</operator> <name>shift</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>codebook_extremes</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
<expr><block>{<expr><operator>-</operator><literal type="number">9</literal></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">15</literal></expr>, <expr><literal type="number">14</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>




<function><type><specifier>static</specifier> <name>void</name></type> <name>no_codebook_bits_offset</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>max</name></decl></parameter>,
<parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>bo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>unsign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lsb_bits</name></decl>;</decl_stmt>

<expr_stmt><expr><name>min</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lsb_bits</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><call><name>number_sbits</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>number_sbits</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>lsb_bits</name> <operator>+=</operator> <operator>!</operator><operator>!</operator><name>lsb_bits</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lsb_bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unsign</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>lsb_bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>lsb_bits</name></name> <operator>=</operator> <name>lsb_bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>bitcount</name></name> <operator>=</operator> <name>lsb_bits</name> <operator>*</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>offset</name> <operator>-</operator> <name>unsign</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>unsign</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>no_codebook_bits</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>max</name></decl></parameter>,
<parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>bo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>unsign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lsb_bits</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <name>HUFF_OFFSET_MIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>HUFF_OFFSET_MIN</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <name>HUFF_OFFSET_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>HUFF_OFFSET_MAX</name> <operator>-</operator> <name>max</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>max</name> <operator>-</operator> <name>min</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lsb_bits</name> <operator>=</operator> <call><name>number_sbits</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lsb_bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>unsign</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>lsb_bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>min</name> <operator>+</operator> <name>diff</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <operator>!</operator><operator>!</operator><name>lsb_bits</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>lsb_bits</name></name> <operator>=</operator> <name>lsb_bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>bitcount</name></name> <operator>=</operator> <name>lsb_bits</name> <operator>*</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>max</name> <operator>-</operator> <name>unsign</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>min</name> <operator>+</operator> <name>unsign</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>codebook_bits_offset</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>codebook</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name></type> <name>sample_min</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>sample_max</name></decl></parameter>,
<parameter><decl><type><name>int16_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>bo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>codebook_min</name> <init>= <expr><name><name>codebook_extremes</name><index>[<expr><name>codebook</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>codebook_max</name> <init>= <expr><name><name>codebook_extremes</name><index>[<expr><name>codebook</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>codebook_offset</name> <init>= <expr><literal type="number">7</literal> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>-</operator> <name>codebook</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>unsign_offset</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lsb_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bitcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset_min</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>offset_max</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unsign</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sample_min</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_max</name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>sample_min</name> <argument_list type="generic">&lt; <argument><expr><name>codebook_min</name> <operator>||</operator> <name>sample_max</name></expr></argument> &gt;</argument_list></name> <name>codebook_max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lsb_bits</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_min</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_max</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>unsign</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lsb_bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>unsign</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>codebook</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unsign_offset</name> <operator>-=</operator> <name>unsign</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lsb_bits</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name> <init>= <expr><operator>*</operator><name>sample_buffer</name> <operator>&gt;&gt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp_min</name></decl>, <decl><type ref="prev"/><name>temp_max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sample</name> <operator>-=</operator> <name>unsign_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>temp_min</name> <operator>=</operator> <name>sample</name> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp_min</name> <operator>&lt;</operator> <name>offset_min</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset_min</name> <operator>=</operator> <name>temp_min</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>temp_max</name> <operator>=</operator> <name>unsign</name> <operator>-</operator> <name>temp_min</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp_max</name> <operator>&lt;</operator> <name>offset_max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset_max</name> <operator>=</operator> <name>temp_max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sample</name> <operator>&gt;&gt;=</operator> <name>lsb_bits</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bitcount</name> <operator>+=</operator> <name><name>ff_mlp_huffman_tables</name><index>[<expr><name>codebook</name></expr>]</index><index>[<expr><name>sample</name> <operator>+</operator> <name>codebook_offset</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>lsb_bits</name></name> <operator>=</operator> <name>lsb_bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>bitcount</name></name> <operator>=</operator> <name>lsb_bits</name> <operator>*</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>+</operator> <name>bitcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>offset</name> <operator>-</operator> <name>offset_min</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bo</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>offset_max</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>codebook_bits</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>codebook</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>max</name></decl></parameter>,
<parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>bo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>previous_count</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset_min</name></decl>, <decl><type ref="prev"/><name>offset_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_greater</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>offset_min</name> <operator>=</operator> <call><name>FFMAX</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_max</name> <operator>=</operator> <call><name>FFMIN</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <name>offset_max</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;=</operator> <name>offset_min</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BestOffset</name></type> <name>temp_bo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>codebook_bits_offset</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>codebook</name></expr></argument>,
<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>temp_bo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>temp_bo</name><operator>.</operator><name>bitcount</name></name> <operator>&lt;</operator> <name>previous_count</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>temp_bo</name><operator>.</operator><name>bitcount</name></name> <operator>&lt;</operator> <name><name>bo</name><operator>-&gt;</operator><name>bitcount</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>bo</name> <operator>=</operator> <name>temp_bo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>is_greater</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>++</operator><name>is_greater</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_codebook_search</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>previous_count</name> <operator>=</operator> <name><name>temp_bo</name><operator>.</operator><name>bitcount</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>direction</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>temp_bo</name><operator>.</operator><name>max</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>temp_bo</name><operator>.</operator><name>min</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>determine_bits</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>min</name> <init>= <expr><name>INT32_MAX</name></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name>INT32_MIN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>no_filters_used</name> <init>= <expr><operator>!</operator><name><name>cp</name><operator>-&gt;</operator><name>filter_params</name><index>[<expr><name>FIR</name></expr>]</index></name><operator>.</operator><name>order</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>average</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name> <init>= <expr><operator>*</operator><name>sample_buffer</name> <operator>&gt;&gt;</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sample</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>sample</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sample</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>sample</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>average</name> <operator>+=</operator> <name>sample</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>average</name> <operator>/=</operator> <name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>no_filters_used</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>no_codebook_bits</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_best_offset</name><index>[<expr><name>channel</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>av_clip</name><argument_list>(<argument><expr><name>average</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MIN</name></expr></argument>, <argument><expr><name>HUFF_OFFSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>no_codebook_bits_offset</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_best_offset</name><index>[<expr><name>channel</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_CODEBOOKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BestOffset</name></type> <name>temp_bo</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int16_t</name></type> <name>offset_max</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>codebook_bits_offset</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>temp_bo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>no_filters_used</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset_max</name> <operator>=</operator> <name><name>temp_bo</name><operator>.</operator><name>max</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>codebook_bits</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>temp_bo</name><operator>.</operator><name>min</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp_bo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>codebook_bits</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>offset_max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp_bo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_best_offset</name><index>[<expr><name>channel</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>temp_bo</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAMPLE_MAX</name><parameter_list>(<parameter><type><name>bitdepth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((1 &lt;&lt; (bitdepth - 1)) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAMPLE_MIN</name><parameter_list>(<parameter><type><name>bitdepth</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(~SAMPLE_MAX(bitdepth))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSB_MASK</name><parameter_list>(<parameter><type><name>bits</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(-(int)(1u &lt;&lt; (bits)))</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_filter</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FilterParams</name> <modifier>*</modifier></type><name><name>fp</name><index>[<expr><name>NUM_FILTERS</name></expr>]</index></name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>filter_params</name><index>[<expr><name>FIR</name></expr>]</index></name></expr>,
<expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>filter_params</name><index>[<expr><name>IIR</name></expr>]</index></name></expr>, }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name><name>filter_state_buffer</name><index>[<expr><name>NUM_FILTERS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><call><name>MSB_MASK</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>number_of_samples</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>filter_shift</name> <init>= <expr><name><name>fp</name><index>[<expr><name>FIR</name></expr>]</index></name><operator>-&gt;</operator><name>shift</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>filter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_FILTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>filter_state_buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>av_malloc</name><argument_list>(<argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>filter_state_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name></name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>,
<argument><expr><literal type="string">"Not enough memory for applying filters.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>filter_state_buffer</name><index>[<expr><name>FIR</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>sample_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filter_state_buffer</name><index>[<expr><name>IIR</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>sample_buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">8</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>number_of_samples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name> <init>= <expr><operator>*</operator><name>sample_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>order</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>accum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>residual</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>filter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>filter</name> <operator>&lt;</operator> <name>NUM_FILTERS</name></expr>;</condition> <incr><expr><name>filter</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>fcoeff</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name><index>[<expr><name>channel</name></expr>]</index></name><operator>.</operator><name><name>coeff</name><index>[<expr><name>filter</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>order</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>order</name> <operator>&lt;</operator> <name><name>fp</name><index>[<expr><name>filter</name></expr>]</index></name><operator>-&gt;</operator><name>order</name></expr>;</condition> <incr><expr><name>order</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>accum</name> <operator>+=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>filter_state_buffer</name><index>[<expr><name>filter</name></expr>]</index><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>order</name></expr>]</index></name> <operator>*</operator>
<name><name>fcoeff</name><index>[<expr><name>order</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>accum</name> <operator>&gt;&gt;=</operator> <name>filter_shift</name></expr>;</expr_stmt>
<expr_stmt><expr><name>residual</name> <operator>=</operator> <name>sample</name> <operator>-</operator> <operator>(</operator><name>accum</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>residual</name> <argument_list type="generic">&lt; <argument><expr><name>SAMPLE_MIN</name><operator>(</operator><literal type="number">24</literal><operator>)</operator> <operator>||</operator> <name>residual</name></expr></argument> &gt;</argument_list></name> <call><name>SAMPLE_MAX</name><argument_list>(<argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>free_and_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>filter_state_buffer</name><index>[<expr><name>FIR</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sample</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filter_state_buffer</name><index>[<expr><name>IIR</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <name>residual</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>sample_buffer</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name>channel</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>number_of_samples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sample_buffer</name> <operator>=</operator> <name><name>filter_state_buffer</name><index>[<expr><name>IIR</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>free_and_return</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_FILTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>filter_state_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>apply_filters</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>apply_filter</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>set_filter_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>FIR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_filter_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>IIR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apply_filter</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>generate_2_noise_channels</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>seed</name> <init>= <expr><name><name>rh</name><operator>-&gt;</operator><name>noisegen_seed</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>seed_shr7</name> <init>= <expr><name>seed</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>sample_buffer</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int8_t</name><operator>)</operator><operator>(</operator><name>seed</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>rh</name><operator>-&gt;</operator><name>noise_shift</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sample_buffer</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int8_t</name><operator>)</operator> <name>seed_shr7</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>rh</name><operator>-&gt;</operator><name>noise_shift</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>seed</name> <operator>=</operator> <operator>(</operator><name>seed</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>^</operator> <name>seed_shr7</name> <operator>^</operator> <operator>(</operator><name>seed_shr7</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>noisegen_seed</name></name> <operator>=</operator> <name>seed</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>rematrix_channels</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MatrixParams</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>matrix_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>sample_buffer</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mat</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>maxchan</name></decl>;</decl_stmt>

<expr_stmt><expr><name>maxchan</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>mat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mat</name> <operator>&lt;</operator> <name><name>mp</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>mat</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>msb_mask_bits</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>sample_fmt</name></name> <operator>==</operator> <name>AV_SAMPLE_FMT_S16</name></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>-</operator> <name><name>mp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>mat</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>mask</name> <init>= <expr><call><name>MSB_MASK</name><argument_list>(<argument><expr><name>msb_mask_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>outch</name> <init>= <expr><name><name>mp</name><operator>-&gt;</operator><name>outch</name><index>[<expr><name>mat</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>src_ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>accum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>src_ch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>src_ch</name> <operator>&lt;</operator> <name>maxchan</name></expr>;</condition> <incr><expr><name>src_ch</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sample</name> <init>= <expr><operator>*</operator><operator>(</operator><name>sample_buffer</name> <operator>+</operator> <name>src_ch</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>accum</name> <operator>+=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <name>sample</name> <operator>*</operator> <name><name>mp</name><operator>-&gt;</operator><name>forco</name><index>[<expr><name>mat</name></expr>]</index><index>[<expr><name>src_ch</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>sample_buffer</name><index>[<expr><name>outch</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>accum</name> <operator>&gt;&gt;</operator> <literal type="number">14</literal><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sample_buffer</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>





<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAJOR_HEADER_INTERVAL</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bitcount</name></decl>;</decl_stmt>
}</block></struct></type> <name>PathCounter</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>path_counter_codebook</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"0"</literal></expr>, <expr><literal type="string">"1"</literal></expr>, <expr><literal type="string">"2"</literal></expr>, <expr><literal type="string">"3"</literal></expr>, }</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO_PATH</name></cpp:macro> <cpp:value>'0'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODEBOOK_CHANGE_BITS</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clear_path_counter</name><parameter_list>(<parameter><decl><type><name>PathCounter</name> <modifier>*</modifier></type><name>path_counter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_CODEBOOKS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>path_counter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZERO_PATH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path_counter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path_counter</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bitcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_best_offset</name><parameter_list>(<parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>lsb_bits</name></name> <operator>!=</operator> <name><name>cur</name><operator>-&gt;</operator><name>lsb_bits</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>best_codebook_path_cost</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl></parameter>,
<parameter><decl><type><name>PathCounter</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur_codebook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>cur_bo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_bo</name> <init>= <expr><name>restart_best_offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bitcount</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>bitcount</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>path</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_codebook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>prev_bo</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>best_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>prev_codebook</name> <operator>=</operator> <name><name>path</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>ZERO_PATH</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cur_bo</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>best_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>bitcount</name> <operator>+=</operator> <name><name>cur_bo</name><index>[<expr><name>cur_codebook</name></expr>]</index></name><operator>.</operator><name>bitcount</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_codebook</name> <operator>!=</operator> <name>cur_codebook</name> <operator>||</operator>
<call><name>compare_best_offset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prev_bo</name><index>[<expr><name>prev_codebook</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_bo</name><index>[<expr><name>cur_codebook</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bitcount</name> <operator>+=</operator> <name>CODEBOOK_CHANGE_BITS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>bitcount</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_best_codebook</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <name><name>rh</name><operator>-&gt;</operator><name>min_channel</name></name></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;=</operator> <name><name>rh</name><operator>-&gt;</operator><name>max_channel</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BestOffset</name> <modifier>*</modifier></type><name>cur_bo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_bo</name> <init>= <expr><name>restart_best_offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PathCounter</name></type> <name><name>path_counter</name><index>[<expr><name>NUM_CODEBOOKS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>best_codebook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_path_counter</name><argument_list>(<argument><expr><name>path_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>best_bitcount</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>codebook</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cur_bo</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>best_offset</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>codebook</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>codebook</name> <operator>&lt;</operator> <name>NUM_CODEBOOKS</name></expr>;</condition> <incr><expr><name>codebook</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>prev_best_bitcount</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last_best</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>last_best</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>last_best</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>last_best</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>PathCounter</name> <modifier>*</modifier></type><name>dst_path</name> <init>= <expr><operator>&amp;</operator><name><name>path_counter</name><index>[<expr><name>codebook</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PathCounter</name> <modifier>*</modifier></type><name>src_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp_bitcount</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>last_best</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>src_path</name> <operator>=</operator> <operator>&amp;</operator><name><name>path_counter</name><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>compare_best_offset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prev_bo</name><index>[<expr><name>codebook</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_bo</name><index>[<expr><name>codebook</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>src_path</name> <operator>=</operator> <operator>&amp;</operator><name><name>path_counter</name><index>[<expr><name>codebook</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>temp_bitcount</name> <operator>=</operator> <call><name>best_codebook_path_cost</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>channel</name></expr></argument>, <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>codebook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>temp_bitcount</name> <operator>&lt;</operator> <name>best_bitcount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>best_bitcount</name> <operator>=</operator> <name>temp_bitcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name>best_codebook</name> <operator>=</operator> <name>codebook</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>temp_bitcount</name> <operator>&lt;</operator> <name>prev_best_bitcount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev_best_bitcount</name> <operator>=</operator> <name>temp_bitcount</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src_path</name> <operator>!=</operator> <name>dst_path</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>src_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PathCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>av_strlcat</name><argument_list>(<argument><expr><name><name>dst_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>path_counter_codebook</name><index>[<expr><name>codebook</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dst_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst_path</name><operator>-&gt;</operator><name>bitcount</name></name> <operator>=</operator> <name>temp_bitcount</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>prev_bo</name> <operator>=</operator> <name>cur_bo</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path_counter</name><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path_counter</name><index>[<expr><name>best_codebook</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PathCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name><name>path_counter</name><index>[<expr><name>NUM_CODEBOOKS</name></expr>]</index></name><operator>.</operator><name>path</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_channel_params</name></name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator> <name>channel</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>best_codebook</name> <operator>=</operator> <operator>*</operator><name>best_path</name><operator>++</operator> <operator>-</operator> <name>ZERO_PATH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cur_bo</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>best_offset</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index><index>[<expr><name>best_codebook</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_offset</name></name> <operator>=</operator> <name><name>cur_bo</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>huff_lsbs</name></name> <operator>=</operator> <name><name>cur_bo</name><operator>-&gt;</operator><name>lsb_bits</name></name> <operator>+</operator> <name><name>dp</name><operator>-&gt;</operator><name>quant_step_size</name><index>[<expr><name>channel</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>codebook</name></name> <operator>=</operator> <name>best_codebook</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>set_major_params</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RestartHeader</name> <modifier>*</modifier></type><name>rh</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_huff_lsbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>max_output_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>seq_dp</name> <init>= <expr><operator>(</operator><name>DecodingParams</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>decoding_params</name></name><operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>seq_offset</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>seq_cp</name> <init>= <expr><operator>(</operator><name>ChannelParams</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>channel_params</name></name> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>seq_offset</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>channel</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>seq_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_decoding_params</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name></expr></argument>, <argument><expr><name>seq_dp</name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DecodingParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>channel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>channel</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr>;</condition> <incr><expr><name>channel</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>huff_lsbs</name> <init>= <expr><operator>(</operator><name>seq_cp</name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator> <name>channel</name><operator>)</operator><operator>-&gt;</operator><name>huff_lsbs</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>max_huff_lsbs</name> <operator>&lt;</operator> <name>huff_lsbs</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_huff_lsbs</name> <operator>=</operator> <name>huff_lsbs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_channel_params</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>channel</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>(</operator><name>seq_cp</name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator> <name>channel</name><operator>)</operator></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChannelParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>max_huff_lsbs</name></name> <operator>=</operator> <name>max_huff_lsbs</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>max_output_bits</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_output_bits</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name><name>rh</name><operator>-&gt;</operator><name>max_output_bits</name></name> <operator>=</operator> <name>max_output_bits</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>prev_decoding_params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>restart_decoding_params</name><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>prev_channel_params</name></name> <operator>=</operator> <name>restart_channel_params</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>MAJOR_HEADER_INTERVAL</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_decoding_params</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_channel_params</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_params_changed</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name> <operator>=</operator> <call><name>compare_decoding_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>prev_decoding_params</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>prev_channel_params</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_number_of_subblocks</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_filter_state_subblock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_cur_subblock_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>analyze_sample_buffer</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ChannelParams</name> <modifier>*</modifier></type><name>seq_cp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_channel_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>seq_dp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_decoding_params</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name> <operator>=</operator> <name>seq_dp</name> <operator>+</operator> <literal type="number">1</literal><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name> <operator>=</operator> <name>seq_cp</name> <operator>+</operator> <literal type="number">1</literal><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>determine_quant_step_size</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>generate_2_noise_channels</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lossless_matrix_coeffs</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rematrix_channels</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>determine_filters</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apply_filters</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_restart_frame_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>DecodingParams</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name>seq_dp</name> <operator>+</operator> <operator>(</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>




<expr_stmt><expr><operator>(</operator><name>seq_dp</name> <operator>+</operator> <name>substr</name><operator>)</operator><operator>-&gt;</operator><name>blocksize</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>seq_dp</name> <operator>+</operator> <literal type="number">1</literal><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name><operator>)</operator><operator>-&gt;</operator><name>blocksize</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name> <operator>=</operator> <name>seq_dp</name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator> <name>substr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name> <operator>=</operator> <name>seq_cp</name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_best_offset</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>best_offset</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>determine_bits</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_channels</name></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>set_best_codebook</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>process_major_frame</name><parameter_list>(<parameter><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>substr</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>starting_frame_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_number_of_frames</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_frame_size</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>substr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>substr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name></expr>;</condition> <incr><expr><name>substr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_restart_header</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>restart_header</name><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_decoding_params</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_decoding_params</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><name>substr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cur_channel_params</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_channel_params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_2_noise_channels</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rematrix_channels</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>apply_filters</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>mlp_encode_frame</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>, <parameter><decl><type><name>AVPacket</name> <modifier>*</modifier></type><name>avpkt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AVFrame</name> <modifier>*</modifier></type><name>frame</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>got_packet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bytes_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>restart_frame</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_alloc_packet2</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>avpkt</name></expr></argument>, <argument><expr><literal type="number">87500</literal> <operator>*</operator> <name><name>avctx</name><operator>-&gt;</operator><name>channels</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>frame</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>ff_af_queue_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>afq</name></name></expr></argument>, <argument><expr><name>frame</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>frame</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name>
<operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>one_sample_buffer_size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>last_frame</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name>
<operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>one_sample_buffer_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>input_and_return</name>;</goto>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name> <operator>&gt;</operator> <name>MAX_BLOCKSIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>av_log</name><argument_list>(<argument><expr><name>avctx</name></expr></argument>, <argument><expr><name>AV_LOG_ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid frame size (%d &gt; %d)\n"</literal></expr></argument>,
<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>MAX_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>restart_frame</name> <operator>=</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>restart_frame</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_major_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>process_major_frame</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>write_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name>write_access_unit</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>restart_frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dts</name></name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name></expr>;</expr_stmt>

<label><name>input_and_return</name>:</label>

<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name></expr>]</index></name> <operator>=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>next_major_frame_size</name></name> <operator>+=</operator> <name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>next_major_number_of_frames</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>input_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>last_frame</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>last_frame</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>restart_frame</name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>restart_frame</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>seq_index</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>seq_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
<condition><expr><name>seq_index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>restart_intervals</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>seq_index</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator> <operator>&lt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name></expr>;</condition>
<incr><expr><name>seq_index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>number_of_samples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>inout_buffer</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_index</name></name> <operator>=</operator> <name>seq_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>starting_frame_index</name></name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>-</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>frame_number</name></name> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator>
<operator>-</operator> <operator>(</operator><name>seq_index</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator><operator>)</operator> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>next_major_number_of_frames</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_subblocks</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>next_major_number_of_frames</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_channel_params</name></name> <operator>=</operator> <operator>(</operator><name>ChannelParams</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>channel_params</name></name> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>seq_offset</name><index>[<expr><name>seq_index</name></expr>]</index></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_decoding_params</name></name> <operator>=</operator> <operator>(</operator><name>DecodingParams</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>decoding_params</name></name> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>/</operator> <name><name>ctx</name><operator>-&gt;</operator><name>min_restart_interval</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>sequence_size</name></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator> <operator>+</operator>
<operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>seq_offset</name><index>[<expr><name>seq_index</name></expr>]</index></name><operator>)</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>number_of_frames</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>number_of_samples</name> <operator>+=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name><index>[<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>starting_frame_index</name></name> <operator>+</operator> <name>index</name><operator>)</operator> <operator>%</operator> <name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>number_of_samples</name></name> <operator>=</operator> <name>number_of_samples</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>seq_size</name><index>[<expr><name>seq_index</name></expr>]</index></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>clear_channel_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_channel_params</name></name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>avctx</name><operator>-&gt;</operator><name>channels</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>default_decoding_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>seq_decoding_params</name></name> <operator>+</operator> <name>index</name><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>num_substreams</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>input_to_sample_buffer</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>analyze_sample_buffer</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>frame_index</name></name> <operator>==</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>max_restart_interval</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_frame_size</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>next_major_frame_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>next_major_frame_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>major_number_of_frames</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>next_major_number_of_frames</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>next_major_number_of_frames</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_frame_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>no_data_left</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>no_data_left</name>:</label>

<expr_stmt><expr><call><name>ff_af_queue_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>afq</name></name></expr></argument>, <argument><expr><name><name>avctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>avpkt</name><operator>-&gt;</operator><name>pts</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>avpkt</name><operator>-&gt;</operator><name>duration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>avpkt</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>bytes_written</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>got_packet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>av_cold</name> <name>int</name></type> <name>mlp_encode_close</name><parameter_list>(<parameter><decl><type><name>AVCodecContext</name> <modifier>*</modifier></type><name>avctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>MLPEncodeContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>avctx</name><operator>-&gt;</operator><name>priv_data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ff_lpc_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>lpc_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>lossless_check_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_scratch_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>major_inout_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>lpc_sample_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>decoding_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>channel_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>frame_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>av_freep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>max_output_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ff_af_queue_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>afq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_MLP_ENCODER</name></expr></cpp:if>
<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_mlp_encoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator><literal type="string">"mlp"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"MLP (Meridian Lossless Packing)"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_MLP</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MLPEncodeContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>mlp_encode_init</name></expr>,
<expr><operator>.</operator><name>encode2</name> <operator>=</operator> <name>mlp_encode_frame</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>mlp_encode_close</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_SMALL_LAST_FRAME</name> <operator>|</operator> <name>AV_CODEC_CAP_DELAY</name> <operator>|</operator> <name>AV_CODEC_CAP_EXPERIMENTAL</name></expr>,
<expr><operator>.</operator><name>sample_fmts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> enum <name><name>AVSampleFormat</name><index>[]</index></name><operator>)</operator> <block>{<expr><name>AV_SAMPLE_FMT_S16</name></expr>, <expr><name>AV_SAMPLE_FMT_NONE</name></expr>}</block></expr>,
<expr><operator>.</operator><name>supported_samplerates</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name><name>int</name><index>[]</index></name><operator>)</operator> <block>{<expr><literal type="number">44100</literal></expr>, <expr><literal type="number">48000</literal></expr>, <expr><literal type="number">88200</literal></expr>, <expr><literal type="number">96000</literal></expr>, <expr><literal type="number">176400</literal></expr>, <expr><literal type="number">192000</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><operator>.</operator><name>channel_layouts</name> <operator>=</operator> <name>ff_mlp_channel_layouts</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONFIG_TRUEHD_ENCODER</name></expr></cpp:if>
<decl_stmt><decl><type><name>AVCodec</name></type> <name>ff_truehd_encoder</name> <init>= <expr><block>{
<expr><operator>.</operator><name>name</name> <operator>=</operator><literal type="string">"truehd"</literal></expr>,
<expr><operator>.</operator><name>long_name</name> <operator>=</operator> <call><name>NULL_IF_CONFIG_SMALL</name><argument_list>(<argument><expr><literal type="string">"TrueHD"</literal></expr></argument>)</argument_list></call></expr>,
<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>AVMEDIA_TYPE_AUDIO</name></expr>,
<expr><operator>.</operator><name>id</name> <operator>=</operator> <name>AV_CODEC_ID_TRUEHD</name></expr>,
<expr><operator>.</operator><name>priv_data_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MLPEncodeContext</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><operator>.</operator><name>init</name> <operator>=</operator> <name>mlp_encode_init</name></expr>,
<expr><operator>.</operator><name>encode2</name> <operator>=</operator> <name>mlp_encode_frame</name></expr>,
<expr><operator>.</operator><name>close</name> <operator>=</operator> <name>mlp_encode_close</name></expr>,
<expr><operator>.</operator><name>capabilities</name> <operator>=</operator> <name>AV_CODEC_CAP_SMALL_LAST_FRAME</name> <operator>|</operator> <name>AV_CODEC_CAP_DELAY</name> <operator>|</operator> <name>AV_CODEC_CAP_EXPERIMENTAL</name></expr>,
<expr><operator>.</operator><name>sample_fmts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> enum <name><name>AVSampleFormat</name><index>[]</index></name><operator>)</operator> <block>{<expr><name>AV_SAMPLE_FMT_S16</name></expr>, <expr><name>AV_SAMPLE_FMT_NONE</name></expr>}</block></expr>,
<expr><operator>.</operator><name>supported_samplerates</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name><name>int</name><index>[]</index></name><operator>)</operator> <block>{<expr><literal type="number">44100</literal></expr>, <expr><literal type="number">48000</literal></expr>, <expr><literal type="number">88200</literal></expr>, <expr><literal type="number">96000</literal></expr>, <expr><literal type="number">176400</literal></expr>, <expr><literal type="number">192000</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><operator>.</operator><name>channel_layouts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name><name>uint64_t</name><index>[]</index></name><operator>)</operator> <block>{<expr><name>AV_CH_LAYOUT_STEREO</name></expr>, <expr><name>AV_CH_LAYOUT_5POINT0_BACK</name></expr>, <expr><name>AV_CH_LAYOUT_5POINT1_BACK</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
